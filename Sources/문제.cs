// 2008년 9월에 제작을 시작한 CDeusExMachina가 이 프로그램의 전신입니다.
// 모든 문제 제작을 기계에 맡기겠다는 꿈을 가지고 제작되었으며,
// 인공지능 프로젝트의 초창기버전입니다.
// 2014년부터 C#으로 옮겨가면서 다시 제작하고 있습니다.
// 내년이면 CDeusExMachina가 10주년이 됩니다. (2017-10-14)

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Text.RegularExpressions;
using 변환;
using 강력하지만무거운변환;
using 구문분석;
using 검색_진화하는;

namespace 편집기의_제왕
{
    class 문제
    {
        public static string _문제DB루트폴더 = Application.StartupPath + "/txt/";

        public static int _현재번호;

        public static 검색 _검색;
        public static List<string> _어휘_이미출제한것들;
        public static List<string> _어법_이미출제한것들;

        public static List<string> _중의어_영단어;
	    public static List<string> _중의어_1_한글뜻;
	    public static List<string> _중의어_1_영어풀이;
	    public static List<string> _중의어_1_해설;

	    public static List<string> _중의어_2_한글뜻;
	    public static List<string> _중의어_2_영어풀이;
	    public static List<string> _중의어_2_해설;

	    public static List<string> _중의어_3_한글뜻;
	    public static List<string> _중의어_3_영어풀이;
	    public static List<string> _중의어_3_해설;

	    public static List<string> _중의어_4_한글뜻;
	    public static List<string> _중의어_4_영어풀이;
	    public static List<string> _중의어_4_해설;

	    public static List<string> _중의어_5_한글뜻;
	    public static List<string> _중의어_5_영어풀이;
	    public static List<string> _중의어_5_해설;

		public static bool _본문_해석_문장숫자확인여부 = false;
        static 문제()
        {
            _현재번호 = 1;

            _검색 = new 검색();
            _어휘_이미출제한것들 = new List<string>();
            _어법_이미출제한것들 = new List<string>();

	        _중의어_영단어 = new List<string>();
            _중의어_1_한글뜻 = new List<string>();
	        _중의어_1_영어풀이 = new List<string>();
	        _중의어_1_해설 = new List<string>();

	        _중의어_2_한글뜻 = new List<string>();
	        _중의어_2_영어풀이 = new List<string>();
	        _중의어_2_해설 = new List<string>();

	        _중의어_3_한글뜻 = new List<string>();
	        _중의어_3_영어풀이 = new List<string>();
	        _중의어_3_해설 = new List<string>();

	        _중의어_4_한글뜻 = new List<string>();
	        _중의어_4_영어풀이 = new List<string>();
            _중의어_4_해설 = new List<string>();
            
	        _중의어_5_한글뜻 = new List<string>();
	        _중의어_5_영어풀이 = new List<string>();
	        _중의어_5_해설 = new List<string>();

        }

        public static string 출제가능한모든내용표시(string 원래지문)
        {
            List<string> 문장단위의_문자열들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로_탭과개행문자살림(원래지문, ref 문장단위의_문자열들);


            string 처리결과지문 = "";

            foreach (string 현재문장 in 문장단위의_문자열들)
            {
                if (현재문장 != "\r" && 현재문장 != "\t")
                {
                    string 처리한_새로운_문장 = "";

                    List<string> 어절들 = new List<string>();

                    변환.문자열.어절들로(현재문장, ref 어절들);
                    for (int i = 0; i < 어절들.Count; i++)
                    {
                        int jump = 0;
                        string B4 = "", B3 = "", B2 = "", B1 = "", C = "", N1 = "", N2 = "", N3 = "";

                        if (i > 3) B4 = 어절들[i - 4]; else B4 = "";
                        if (i > 2) B3 = 어절들[i - 3]; else B3 = "";
                        if (i > 1) B2 = 어절들[i - 2]; else B2 = "";
                        if (i > 0) B1 = 어절들[i - 1]; else B1 = "";
                        C = 어절들[i];
                        if (i < 어절들.Count - 1) N1 = 어절들[i + 1]; else N1 = "";
                        if (i < 어절들.Count - 2) N2 = 어절들[i + 2]; else N2 = "";
                        if (i < 어절들.Count - 3) N3 = 어절들[i + 3]; else N3 = "";

                        string 처리한현재어절 = "";
                        if (어법문제후보표시_세부단계_가정법(B4, B3, B2, B1, C, ref 처리한현재어절)) 처리한_새로운_문장 += " " + 처리한현재어절;
						else if (어법문제후보표시_세부단계_to_동명사(B1, C, ref 처리한현재어절)) 처리한_새로운_문장 += " " + 처리한현재어절;
						else if (어법문제후보표시_세부단계_과거분사현재분사구분(B1, C, ref 처리한현재어절)) 처리한_새로운_문장 += " " + 처리한현재어절;
                        else if (어법문제후보표시_세부단계_관계사찾기(B1, C, N1, ref 처리한현재어절)) 처리한_새로운_문장 += " " + 처리한현재어절;
                        else if (어법문제후보표시_세부단계_is와are의구분(B1, C, ref 처리한현재어절)) 처리한_새로운_문장 += " " + 처리한현재어절;
                        else if (어법문제후보표시_세부단계_수동태안쓰는자동사(B1, C, N1, ref 처리한현재어절)) 처리한_새로운_문장 += " " + 처리한현재어절;
						else if (빈칸문제후보표시(C, N1, ref 처리한현재어절, ref jump)) 처리한_새로운_문장 += " " + 처리한현재어절;
						
                        else if (접속어문제후보표시(C, N1, ref 처리한현재어절, ref jump)) 처리한_새로운_문장 += " " + 처리한현재어절;
                        else 처리한_새로운_문장 += " " + C;

                        i += jump;
                    }

                    처리한_새로운_문장.Trim();

                    처리결과지문 += " " + 처리한_새로운_문장;
                }
                else
                    처리결과지문 += 현재문장;
            }

            return 처리결과지문;
        }

        public static string 동의어반의어(string T태그내용, string 해석)
        {
            #region 구현부
            string 본문 = 변환.문자열.문법문제표지제거(T태그내용);

            string 문제에들어갈본문 = 본문;

            if (본문.Trim() == "")
                return "";

            List<string> 어절들 = new List<string>();

            변환.문자열.어절들로(본문, ref 어절들);

            long 첫번째적은검색횟수 = 500000000;
            string 첫번째적은검색단어 = "";
            string 첫번째적은검색단어_원래것 = "";
            long 두번째적은검색횟수 = 500000000;
            string 두번째적은검색단어 = "";
            string 두번째적은검색단어_원래것 = "";
            long 세번째적은검색횟수 = 500000000;
            string 세번째적은검색단어 = "";
            string 세번째적은검색단어_원래것 = "";

            for (int i = 0; i < 어절들.Count; i++)
            {
                string 현재어절 = 변환.문자열.불필요문자제거(어절들[i]);

                if (!_검색.어휘빈칸예외단어(현재어절))
                {
                    if (_검색.동의어반의어(현재어절) != "")
                    {
                        // 검색횟수가 0이 아니되 가장 작은 것 3개를 고릅니다. 같은 단어여서도 안됩니다.
                        if ((현재어절.ToLower() == 현재어절) && (_검색.구글횟수(현재어절) != 0) && (_검색.구글횟수(현재어절) < 첫번째적은검색횟수))
                        {
                            첫번째적은검색횟수 = _검색.구글횟수(현재어절);
                            첫번째적은검색단어 = 현재어절;
                            첫번째적은검색단어_원래것 = 현재어절;
                        }
                    }
                    else if(!현재어절.EndsWith("ing") && !현재어절.EndsWith("ed"))
                    {
                        string 어절원형 = _검색.원형사전(현재어절);

                        if (_검색.동의어반의어(어절원형) != "")
                        {
                            // 검색횟수가 0이 아니되 가장 작은 것 3개를 고릅니다. 같은 단어여서도 안됩니다.
                            if ((_검색.구글횟수(어절원형) != 0) && (_검색.구글횟수(어절원형) < 첫번째적은검색횟수) && !_검색.어휘빈칸예외단어(어절원형))
                            {
                                첫번째적은검색횟수 = _검색.구글횟수(어절원형);
                                첫번째적은검색단어 = 어절원형;
                                첫번째적은검색단어_원래것 = 현재어절;
                            }
                        }
                    }
                }
            }

            for (int i = 0; i < 어절들.Count; i++)
            {
                string 현재어절 = 변환.문자열.불필요문자제거(어절들[i]);

                if (!_검색.어휘빈칸예외단어(현재어절))
                {
                    if (_검색.동의어반의어(현재어절) != "")
                    {

                        // 첫번째 단어가 두번째 단어를 포함하는 경우 문제가 생기는 것을 방지한다.
                        if ((현재어절.ToLower() == 현재어절) && (_검색.구글횟수(현재어절) != 0) && (_검색.구글횟수(현재어절) < 두번째적은검색횟수) && (현재어절.ToLower() != 첫번째적은검색단어.ToLower()) && (본문.IndexOf(현재어절.ToLower()) != 본문.IndexOf(첫번째적은검색단어.ToLower()))) 
                        {
                            두번째적은검색횟수 = _검색.구글횟수(현재어절);
                            두번째적은검색단어 = 현재어절;
                            두번째적은검색단어_원래것 = 현재어절;
                        }
                    }
                    else if(!현재어절.EndsWith("ing") && !현재어절.EndsWith("ed"))
                    {
                        string 어절원형 = _검색.원형사전(현재어절);

                        if (_검색.동의어반의어(어절원형) != "")
                        {

                            // 첫번째 단어가 두번째 단어를 포함하는 경우 문제가 생기는 것을 방지한다.
                            if ((어절원형.ToLower() == 어절원형) && (_검색.구글횟수(어절원형) != 0) && (_검색.구글횟수(어절원형) < 두번째적은검색횟수) && (어절원형.ToLower() != 첫번째적은검색단어.ToLower()) && (본문.IndexOf(어절원형.ToLower()) != 본문.IndexOf(첫번째적은검색단어.ToLower())))
                            {
                                두번째적은검색횟수 = _검색.구글횟수(어절원형);
                                두번째적은검색단어 = 어절원형;
                                두번째적은검색단어_원래것 = 현재어절;
                            }

                        }
                    }
                }
            }

            foreach (string 현재어절 in 어절들)
            {
                string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                if (현재어절.Contains(불필요문자제거한어절))
                {
                    // 검색횟수가 0이 아니되 가장 작은 것 3개를 고릅니다. 같은 단어여서도 안됩니다.
                    if ((불필요문자제거한어절.ToLower() == 불필요문자제거한어절) && (_검색.동의어반의어(불필요문자제거한어절) != "") && (_검색.구글횟수(불필요문자제거한어절) != 0) && (_검색.구글횟수(불필요문자제거한어절) < 세번째적은검색횟수) && (불필요문자제거한어절.ToLower() != 첫번째적은검색단어.ToLower()) && (본문.IndexOf(불필요문자제거한어절.ToLower()) != 본문.IndexOf(첫번째적은검색단어.ToLower())) && (본문.IndexOf(불필요문자제거한어절.ToLower()) != 본문.IndexOf(두번째적은검색단어.ToLower())) && (불필요문자제거한어절.ToLower() != 두번째적은검색단어.ToLower()) && !_검색.어휘빈칸예외단어(불필요문자제거한어절))
                    {
                        세번째적은검색횟수 = _검색.구글횟수(불필요문자제거한어절);
                        세번째적은검색단어 = 불필요문자제거한어절;
                    }
                }
            }

            string 출제문제 = "";

            if (첫번째적은검색단어 != "")
            {
                string 동의어반의어검색값 = _검색.동의어반의어(첫번째적은검색단어);
                
                if(동의어반의어검색값.Contains("|ANT|")) // 반의어를 포함하는 경우
                {
                    string 동의어문자열 = 동의어반의어검색값.Substring(동의어반의어검색값.IndexOf("|SYN|") + 5, 동의어반의어검색값.IndexOf("|ANT|") - 5);
                    string 반의어문자열 = 동의어반의어검색값.Substring(동의어반의어검색값.IndexOf("|ANT|") + 5);

                    string[] 동의어문자열_배열 = 동의어문자열.Replace(".", "").Split(',');
                    string[] 반의어문자열_배열 = 반의어문자열.Replace(".", "").Split(',');

                    if (동의어문자열_배열.Length > 3) // 동의어가 4개 이상이므로, 뜻이 반대인 것 문제 하나만 내면 된다.
                    {

                        출제문제 += "<CAKE>\n";
                        출제문제 += "\t<Q> " + _현재번호 + ". 밑줄 친 부분과 반대 의미를 가진 말로 가장 적절한 것을 고르시오.  </Q>\n";
                        출제문제 += "\t<T>\n\t";
                        출제문제 += 문제에들어갈본문.Trim().Replace(첫번째적은검색단어_원래것, "[" + 첫번째적은검색단어_원래것 + "]") + "\n";
                        출제문제 += "\t</T>\n";

                        출제문제 += "\t<A>\r\n";

                        int 문장dna = 현재문장DNA(문제에들어갈본문);
                        문장dna = 문장dna % 5;

                        if (문장dna == 0)
                        {
                            출제문제 += "\t<A1> " + 반의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 동의어문자열_배열[0].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 동의어문자열_배열[1].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 동의어문자열_배열[2].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 동의어문자열_배열[3].ToLower() + " </A5>\r\n";
                        }
                        else if (문장dna == 1)
                        {
                            출제문제 += "\t<A1> " + 동의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 반의어문자열_배열[0].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 동의어문자열_배열[1].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 동의어문자열_배열[2].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 동의어문자열_배열[3].ToLower() + " </A5>\r\n";
                        }
                        else if (문장dna == 2)
                        {
                            출제문제 += "\t<A1> " + 동의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 동의어문자열_배열[1].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 반의어문자열_배열[0].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 동의어문자열_배열[2].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 동의어문자열_배열[3].ToLower() + " </A5>\r\n";
                        }
                        else if (문장dna == 3)
                        {
                            출제문제 += "\t<A1> " + 동의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 동의어문자열_배열[1].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 동의어문자열_배열[2].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 반의어문자열_배열[0].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 동의어문자열_배열[3].ToLower() + " </A5>\r\n";
                        }
                        else if (문장dna == 4)
                        {
                            출제문제 += "\t<A1> " + 동의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 동의어문자열_배열[1].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 동의어문자열_배열[2].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 동의어문자열_배열[3].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 반의어문자열_배열[0].ToLower() + " </A5>\r\n";
                        }


                        출제문제 += "\t</A>\r\n";

                        출제문제 += "\t<정답>\n";

                        if (문장dna == 0){ 출제문제 += "\t정답 ①번\r\n"; }
                        if (문장dna == 1) { 출제문제 += "\t정답 ②번\r\n"; }
                        if (문장dna == 2) { 출제문제 += "\t정답 ③번\r\n"; }
                        if (문장dna == 3) { 출제문제 += "\t정답 ④번\r\n"; }
                        if (문장dna == 4) { 출제문제 += "\t정답 ⑤번\r\n"; }

                        출제문제 += "\t</정답>\n";
                        출제문제 += "\t<해석>\n";
                        출제문제 += 해석 + "\n";
                        출제문제 += "\t</해석>\n";
                        출제문제 += "</CAKE>\n";

                    }
                }
                else
                {
                    string 동의어문자열 = 동의어반의어검색값.Substring(동의어반의어검색값.IndexOf("|SYN|") + 5);
                }
            }


            if (두번째적은검색단어 != "")
            {
                string 동의어반의어검색값 = _검색.동의어반의어(두번째적은검색단어);

                if (동의어반의어검색값.Contains("|ANT|")) // 반의어를 포함하는 경우
                {
                    string 동의어문자열 = 동의어반의어검색값.Substring(동의어반의어검색값.IndexOf("|SYN|") + 5, 동의어반의어검색값.IndexOf("|ANT|") - 5);
                    string 반의어문자열 = 동의어반의어검색값.Substring(동의어반의어검색값.IndexOf("|ANT|") + 5);

                    string[] 동의어문자열_배열 = 동의어문자열.Replace(".", "").Split(',');
                    string[] 반의어문자열_배열 = 반의어문자열.Replace(".", "").Split(',');

                    if (동의어문자열_배열.Length > 3) // 동의어가 4개 이상이므로, 뜻이 반대인 것 문제 하나만 내면 된다.
                    {

                        출제문제 += "<CAKE>\n";
                        출제문제 += "\t<Q> " + string.Format("{0}", _현재번호) + ". 밑줄 친 부분과 반대 의미를 가진 말로 가장 적절한 것을 고르시오.  </Q>\n";
                        출제문제 += "\t<T>\n\t";
                        출제문제 += 문제에들어갈본문.Trim().Replace(두번째적은검색단어_원래것, "[" + 두번째적은검색단어_원래것 + "]") + "\n";
                        출제문제 += "\t</T>\n";

                        출제문제 += "\t<A>\r\n";

                        int 문장dna = 현재문장DNA(문제에들어갈본문);
                        문장dna = 문장dna % 5;

                        if (문장dna == 0)
                        {
                            출제문제 += "\t<A1> " + 반의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 동의어문자열_배열[0].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 동의어문자열_배열[1].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 동의어문자열_배열[2].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 동의어문자열_배열[3].ToLower() + " </A5>\r\n";
                        }
                        else if (문장dna == 1)
                        {
                            출제문제 += "\t<A1> " + 동의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 반의어문자열_배열[0].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 동의어문자열_배열[1].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 동의어문자열_배열[2].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 동의어문자열_배열[3].ToLower() + " </A5>\r\n";
                        }
                        else if (문장dna == 2)
                        {
                            출제문제 += "\t<A1> " + 동의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 동의어문자열_배열[1].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 반의어문자열_배열[0].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 동의어문자열_배열[2].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 동의어문자열_배열[3].ToLower() + " </A5>\r\n";
                        }
                        else if (문장dna == 3)
                        {
                            출제문제 += "\t<A1> " + 동의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 동의어문자열_배열[1].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 동의어문자열_배열[2].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 반의어문자열_배열[0].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 동의어문자열_배열[3].ToLower() + " </A5>\r\n";
                        }
                        else if (문장dna == 4)
                        {
                            출제문제 += "\t<A1> " + 동의어문자열_배열[0].ToLower() + " </A1>\r\n";
                            출제문제 += "\t<A2> " + 동의어문자열_배열[1].ToLower() + " </A2>\r\n";
                            출제문제 += "\t<A3> " + 동의어문자열_배열[2].ToLower() + " </A3>\r\n";
                            출제문제 += "\t<A4> " + 동의어문자열_배열[3].ToLower() + " </A4>\r\n";
                            출제문제 += "\t<A5> " + 반의어문자열_배열[0].ToLower() + " </A5>\r\n";
                        }


                        출제문제 += "\t</A>\r\n";

                        출제문제 += "\t<정답>\n";

                        if (문장dna == 0) { 출제문제 += "\t정답 ①번\r\n"; }
                        if (문장dna == 1) { 출제문제 += "\t정답 ②번\r\n"; }
                        if (문장dna == 2) { 출제문제 += "\t정답 ③번\r\n"; }
                        if (문장dna == 3) { 출제문제 += "\t정답 ④번\r\n"; }
                        if (문장dna == 4) { 출제문제 += "\t정답 ⑤번\r\n"; }

                        출제문제 += "\t</정답>\n";
                        출제문제 += "\t<해석>\n";
                        출제문제 += 해석 + "\n";
                        출제문제 += "\t</해석>\n";
                        출제문제 += "</CAKE>\n";

                    }
                }
                else
                {
                    string 동의어문자열 = 동의어반의어검색값.Substring(동의어반의어검색값.IndexOf("|SYN|") + 5);
                }
            }

            #endregion
            return 출제문제;
        }

        public static string 어형을_바꾸어_보기에서_알맞은말_골라쓰기(string T태그내용, string 해석)
        {
            #region 구현부
            string 본문 = 변환.문자열.문법문제표지제거(T태그내용);

            string 문제에들어갈본문 = 본문;

            if (본문.Trim() == "")
                return "";

            List<string> 어절들 = new List<string>();

            변환.문자열.어절들로(본문, ref 어절들);

            long 첫번째적은검색횟수 = 500000000;
            string 첫번째적은검색단어 = "";
            long 두번째적은검색횟수 = 500000000;
            string 두번째적은검색단어 = "";
            long 세번째적은검색횟수 = 500000000;
            string 세번째적은검색단어 = "";

            string 정답A = ""; string 정답B = ""; string 정답C = "";

            foreach (string 현재어절 in 어절들)
            {
                string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                if (현재어절.Contains(불필요문자제거한어절))
                {
                    // 검색횟수가 0이 아니되 가장 작은 것 3개를 고릅니다. 같은 단어여서도 안됩니다.
                    if ((불필요문자제거한어절.ToLower() == 불필요문자제거한어절) && (_검색.구글횟수(불필요문자제거한어절) != 0) && (_검색.구글횟수(불필요문자제거한어절) < 첫번째적은검색횟수) && !_검색.어휘빈칸예외단어(불필요문자제거한어절))
                    {
                        첫번째적은검색횟수 = _검색.구글횟수(불필요문자제거한어절);
                        첫번째적은검색단어 = 불필요문자제거한어절;
                    }

                }
            }

            foreach (string 현재어절 in 어절들)
            {
                string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                if (현재어절.Contains(불필요문자제거한어절))
                {
                    // 검색횟수가 0이 아니되 가장 작은 것 3개를 고릅니다. 같은 단어여서도 안됩니다.
                    if ((불필요문자제거한어절.ToLower() == 불필요문자제거한어절) && (_검색.구글횟수(불필요문자제거한어절) != 0) && (_검색.구글횟수(불필요문자제거한어절) < 두번째적은검색횟수) && (불필요문자제거한어절.ToLower() != 첫번째적은검색단어.ToLower()) && (본문.IndexOf(불필요문자제거한어절.ToLower()) != 본문.IndexOf(첫번째적은검색단어.ToLower())) && !_검색.어휘빈칸예외단어(불필요문자제거한어절))
                    {
                        두번째적은검색횟수 = _검색.구글횟수(불필요문자제거한어절);
                        두번째적은검색단어 = 불필요문자제거한어절;
                    }
                }
            }

            foreach (string 현재어절 in 어절들)
            {
                string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                if (현재어절.Contains(불필요문자제거한어절))
                {
                    // 검색횟수가 0이 아니되 가장 작은 것 3개를 고릅니다. 같은 단어여서도 안됩니다.
                    if ((불필요문자제거한어절.ToLower() == 불필요문자제거한어절) && (_검색.구글횟수(불필요문자제거한어절) != 0) && (_검색.구글횟수(불필요문자제거한어절) < 세번째적은검색횟수) && (불필요문자제거한어절.ToLower() != 첫번째적은검색단어.ToLower()) && (본문.IndexOf(불필요문자제거한어절.ToLower()) != 본문.IndexOf(첫번째적은검색단어.ToLower())) && (본문.IndexOf(불필요문자제거한어절.ToLower()) != 본문.IndexOf(두번째적은검색단어.ToLower())) && (불필요문자제거한어절.ToLower() != 두번째적은검색단어.ToLower()) && !_검색.어휘빈칸예외단어(불필요문자제거한어절))
                    {
                        세번째적은검색횟수 = _검색.구글횟수(불필요문자제거한어절);
                        세번째적은검색단어 = 불필요문자제거한어절;
                    }
                }
            }


            int 첫번째적은검색단어위치 = -1;
            int 두번째적은검색단어위치 = -1;
            int 세번째적은검색단어위치 = -1;

            for (int i = 0 ; i < 어절들.Count; i++)
            {
                string 현재어절 = 어절들[i];

                string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                if (     (불필요문자제거한어절 == 첫번째적은검색단어) && (첫번째적은검색단어위치 == -1)) { 첫번째적은검색단어위치 = i; }
                else if ((불필요문자제거한어절 == 두번째적은검색단어) && (두번째적은검색단어위치 == -1)) { 두번째적은검색단어위치 = i; }
                else if ((불필요문자제거한어절 == 세번째적은검색단어) && (세번째적은검색단어위치 == -1)) { 세번째적은검색단어위치 = i; }
            }



            if (첫번째적은검색단어 == "" || 두번째적은검색단어 == "" || 세번째적은검색단어 == "")
				return "";

            if ((첫번째적은검색단어위치 < 두번째적은검색단어위치) && (첫번째적은검색단어위치 < 세번째적은검색단어위치))
            {
                if (두번째적은검색단어위치 < 세번째적은검색단어위치)
                {
                    // Replace를 해버리면, "___(B)___rs."와 같은 사태가 벌어진다.
                    foreach(string 현재어절 in 어절들)
                    {
                        string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                        if(불필요문자제거한어절 == 첫번째적은검색단어){문제에들어갈본문 += 현재어절.Replace(첫번째적은검색단어, "___(A)___") + " ";}
                        else if(불필요문자제거한어절 == 두번째적은검색단어){문제에들어갈본문 += 현재어절.Replace(두번째적은검색단어, "___(B)___") + " ";}
                        else if(불필요문자제거한어절 == 세번째적은검색단어){문제에들어갈본문 += 현재어절.Replace(세번째적은검색단어, "___(C)___") + " ";}
                        else 문제에들어갈본문 += 현재어절 + " ";
                    }

                    정답A = 첫번째적은검색단어;
                    정답B = 두번째적은검색단어;
                    정답C = 세번째적은검색단어;
                }
                else
                {
                    foreach(string 현재어절 in 어절들)
                    {
                        string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                        if(불필요문자제거한어절 == 첫번째적은검색단어){문제에들어갈본문 += 현재어절.Replace(첫번째적은검색단어, "___(A)___") + " ";}
                        else if(불필요문자제거한어절 == 세번째적은검색단어) {문제에들어갈본문 += 현재어절.Replace(세번째적은검색단어, "___(B)___") + " ";}
                        else if(불필요문자제거한어절 == 두번째적은검색단어) {문제에들어갈본문 += 현재어절.Replace(두번째적은검색단어, "___(C)___") + " ";}
                        else 문제에들어갈본문 += 현재어절 + " ";
                    }

                    //문제에들어갈본문 = 문제에들어갈본문.Replace(첫번째적은검색단어, "___(A)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(세번째적은검색단어, "___(B)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(두번째적은검색단어, "___(C)___");

                    정답A = 첫번째적은검색단어;
                    정답B = 세번째적은검색단어;
                    정답C = 두번째적은검색단어;

                }
            }
            if ((두번째적은검색단어위치 < 첫번째적은검색단어위치) && (두번째적은검색단어위치 < 세번째적은검색단어위치))
            {
                if (첫번째적은검색단어위치 < 세번째적은검색단어위치)
                {
                    foreach (string 현재어절 in 어절들)
                    {
                        string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                        if (불필요문자제거한어절 == 두번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(두번째적은검색단어, "___(A)___") + " "; }
                        else if (불필요문자제거한어절 == 첫번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(첫번째적은검색단어, "___(B)___") + " "; }
                        else if (불필요문자제거한어절 == 세번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(세번째적은검색단어, "___(C)___") + " "; }
                        else 문제에들어갈본문 += 현재어절 + " ";
                    }

                    //문제에들어갈본문 = 문제에들어갈본문.Replace(두번째적은검색단어, "___(A)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(첫번째적은검색단어, "___(B)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(세번째적은검색단어, "___(C)___");

                    정답A = 두번째적은검색단어;
                    정답B = 첫번째적은검색단어;
                    정답C = 세번째적은검색단어;
                }
                else
                {
                    foreach (string 현재어절 in 어절들)
                    {
                        string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                        if (불필요문자제거한어절 == 두번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(두번째적은검색단어, "___(A)___") + " "; }
                        else if (불필요문자제거한어절 == 세번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(세번째적은검색단어, "___(B)___") + " "; }
                        else if (불필요문자제거한어절 == 첫번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(첫번째적은검색단어, "___(C)___") + " "; }
                        else 문제에들어갈본문 += 현재어절 + " ";
                    }

                    //문제에들어갈본문 = 문제에들어갈본문.Replace(두번째적은검색단어, "___(A)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(세번째적은검색단어, "___(B)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(첫번째적은검색단어, "___(C)___");

                    정답A = 두번째적은검색단어;
                    정답B = 세번째적은검색단어;
                    정답C = 첫번째적은검색단어;
                }
            }
            if ((세번째적은검색단어위치 < 첫번째적은검색단어위치) && (세번째적은검색단어위치 < 두번째적은검색단어위치))
            {
                if (첫번째적은검색단어위치 < 두번째적은검색단어위치)
                {
                    foreach (string 현재어절 in 어절들)
                    {
                        string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                        if (불필요문자제거한어절 == 세번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(세번째적은검색단어, "___(A)___") + " "; }
                        else if (불필요문자제거한어절 == 첫번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(첫번째적은검색단어, "___(B)___") + " "; }
                        else if (불필요문자제거한어절 == 두번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(두번째적은검색단어, "___(C)___") + " "; }
                        else 문제에들어갈본문 += 현재어절 + " ";
                    }

                    //문제에들어갈본문 = 문제에들어갈본문.Replace(세번째적은검색단어, "___(A)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(첫번째적은검색단어, "___(B)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(두번째적은검색단어, "___(C)___");

                    정답A = 세번째적은검색단어;
                    정답B = 첫번째적은검색단어;
                    정답C = 두번째적은검색단어;
                }
                else
                {
                    foreach (string 현재어절 in 어절들)
                    {
                        string 불필요문자제거한어절 = 변환.문자열.불필요문자제거(현재어절);

                        if (불필요문자제거한어절 == 세번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(세번째적은검색단어, "___(A)___") + " "; }
                        else if (불필요문자제거한어절 == 두번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(두번째적은검색단어, "___(B)___") + " "; }
                        else if (불필요문자제거한어절 == 첫번째적은검색단어) { 문제에들어갈본문 += 현재어절.Replace(첫번째적은검색단어, "___(C)___") + " "; }
                        else 문제에들어갈본문 += 현재어절 + " ";
                    }

                    //문제에들어갈본문 = 문제에들어갈본문.Replace(세번째적은검색단어, "___(A)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(두번째적은검색단어, "___(B)___");
                    //문제에들어갈본문 = 문제에들어갈본문.Replace(첫번째적은검색단어, "___(C)___");

                    정답A = 세번째적은검색단어;
                    정답B = 두번째적은검색단어;
                    정답C = 첫번째적은검색단어;
                }
            }
            #endregion
            #region 표시

            string 출제문제 = "";

            출제문제 += "<CAKE>\n";
            출제문제 += "\t<Q> " + string.Format("{0}", _현재번호) + ". 빈칸에 들어갈 알맞은 말을 보기에서 골라 쓰되 필요하다면 어형을 바꾸시오.  </Q>\n";
            출제문제 += "\t<T>\n\t";
            출제문제 += 문제에들어갈본문.Trim() + "\n";
            출제문제 += "\t<TBAR></TBAR>\n";

            List<string> 보기들 = new List<string>();
            보기들.Add(_검색.원형없으면원래단어(첫번째적은검색단어));
            보기들.Add(_검색.원형없으면원래단어(두번째적은검색단어));
            보기들.Add(_검색.원형없으면원래단어(세번째적은검색단어));

			string 오답1 = "", 오답2 = "", 오답3 = "";

			_검색.잘못된보기들에서오답3개만들기(첫번째적은검색단어, 두번째적은검색단어, 세번째적은검색단어, ref 오답1, ref 오답2, ref 오답3);

            보기들.Add(오답1);
            보기들.Add(오답2);
            보기들.Add(오답3);
			보기들.Sort();

            출제문제 += "\t" + 보기들[0].ToLower();
            출제문제 += ", " + 보기들[1].ToLower();
            출제문제 += ", " + 보기들[2].ToLower();
            출제문제 += ", " + 보기들[3].ToLower();
            출제문제 += ", " + 보기들[4].ToLower();
            출제문제 += ", " + 보기들[5].ToLower();
            출제문제 += "\n";
            출제문제 += "\t</T>\n";
            출제문제 += "\t<정답>\n";
            출제문제 += "\t정답 (A) : " + 정답A + ", 정답 (B) : " + 정답B + ", 정답 (C) : " + 정답C + "\n";
			출제문제 += "\t</정답>\n";
			출제문제 += "\t<해석>\n";
			출제문제 += 해석 + "\n";
			출제문제 += "\t</해석>\n";
			출제문제 += "</CAKE>\n";

            _현재번호++;
           
            return 출제문제;
            #endregion
        }

        #region 빈칸
        public static string 빈칸(string 태그있는본문, string 해석, string 보기파일경로)
        {
			bool 문제만들기성공 = false;

			string ret = "";

			List<string> 보기들 = new List<string>();
			List<string> 지금만든문제들 = new List<string>();


			변환.Ansi파일.문자열들로(보기파일경로, ref 보기들);
			if (보기들.Count() < 6) return "";

			int i = 0;

			bool 계속하기 = true;

			string 원래본문 = 변환.문자열.문법문제표지제거(태그있는본문); 


			while(계속하기 == true)
			{
				int 빈칸시작위치 = 태그있는본문.IndexOf("{빈칸}", i); 
				if(빈칸시작위치 == -1) break;

				int 빈칸종료위치 = 태그있는본문.IndexOf("{/빈칸}", 빈칸시작위치);
				if(빈칸종료위치 == -1) break;

				int 다음빈칸위치 = 태그있는본문.IndexOf("{빈칸}", 빈칸시작위치 + 1);

				
				if(다음빈칸위치 < 빈칸종료위치 && 다음빈칸위치 != -1)
				{
					i = 다음빈칸위치;
				}
				else
				{
					i = 빈칸종료위치;

					string 빈칸사이의_태그있는_내용 = 태그있는본문.Substring(빈칸시작위치 + 4, 빈칸종료위치 - 빈칸시작위치 - 4);
					string 빈칸사이의_태그없는_내용 = 변환.문자열.문법문제표지제거(빈칸사이의_태그있는_내용);
					
					if(보기들.Contains(빈칸사이의_태그없는_내용))
					{
						string 정답 = 빈칸사이의_태그없는_내용;
						string 현재번호없는문제출제결과 = "";
						string 지금만든문제 = 빈칸문제XML만들기(ref 보기들, 정답, 원래본문.Replace(정답, "______"), 해석, ref 현재번호없는문제출제결과);
						if(!지금만든문제들.Contains(현재번호없는문제출제결과))
						{ 
							지금만든문제들.Add(현재번호없는문제출제결과);
							ret += 지금만든문제;
						}

						문제만들기성공 = true;
					}
				}
				
			}

			if(문제만들기성공 == false)
			{
				for(int k = 0 ; k < 보기들.Count; k++)
				{
					string 현재보기들 = 보기들[k];

					if(!현재보기들.Contains(" ")) break; // 적어도 구는 되어야 자동 빈칸 문제를 내 준다.

					string 현재번호없는문제출제결과 = "";
					if(원래본문.Contains(현재보기들))
						ret += 빈칸문제XML만들기(ref 보기들, 현재보기들, 원래본문.Replace(현재보기들, "______"), 해석, ref 현재번호없는문제출제결과);

				}
			}


            return ret;
        }

		public static string 빈칸문제XML만들기(ref List<string> 보기들, string 정답, string 빈칸있는본문, string 해석, ref string 현재번호없는버전)
		{
			string 정답번호_스트링 = "";

			string 오답1 = "", 오답2 = "", 오답3 = "", 오답4 = "";

			보기들에서오답4개만들기(ref 보기들, 정답, ref 오답1, ref 오답2, ref 오답3, ref 오답4);

			string 현재번호있는버전 = "<CAKE>\r\n";
			현재번호있는버전 += "\t<Q> " + _현재번호;

			현재번호없는버전 = ". 다음 글의 빈칸에 들어갈 말로 가장 적절한 것을 고르시오. </Q> \r\n";

			현재번호없는버전 += "\t<T>\r\n";
			현재번호없는버전 += 빈칸있는본문 + "\r\n";
			현재번호없는버전 += "\t</T>\r\n";
			현재번호없는버전 += "\t<A>\r\n";



			List<string> 보기들5개 = new List<string>();
			보기들5개.Add(정답);
			보기들5개.Add(오답1);
			보기들5개.Add(오답2);
			보기들5개.Add(오답3);
			보기들5개.Add(오답4);

			보기들5개.Sort();

			

			if (보기들5개[0] == 정답)
			{
				현재번호없는버전 += "\t<A1> " + 보기들5개[0] + " </A1>\r\n";
				현재번호없는버전 += "\t<A2> " + 보기들5개[1] + " </A2>\r\n";
				현재번호없는버전 += "\t<A3> " + 보기들5개[2] + " </A3>\r\n";
				현재번호없는버전 += "\t<A4> " + 보기들5개[3] + " </A4>\r\n";
				현재번호없는버전 += "\t<A5> " + 보기들5개[4] + " </A5>\r\n";
				정답번호_스트링 = "정답 ①번";
			}
			if (보기들5개[1] == 정답)
			{
				현재번호없는버전 += "\t<A1> " + 보기들5개[0] + " </A1>\r\n";
				현재번호없는버전 += "\t<A2> " + 보기들5개[1] + " </A2>\r\n";
				현재번호없는버전 += "\t<A3> " + 보기들5개[2] + " </A3>\r\n";
				현재번호없는버전 += "\t<A4> " + 보기들5개[3] + " </A4>\r\n";
				현재번호없는버전 += "\t<A5> " + 보기들5개[4] + " </A5>\r\n";
				정답번호_스트링 = "정답 ②번";
			}
			if (보기들5개[2] == 정답)
			{
				현재번호없는버전 += "\t<A1> " + 보기들5개[0] + " </A1>\r\n";
				현재번호없는버전 += "\t<A2> " + 보기들5개[1] + " </A2>\r\n";
				현재번호없는버전 += "\t<A3> " + 보기들5개[2] + " </A3>\r\n";
				현재번호없는버전 += "\t<A4> " + 보기들5개[3] + " </A4>\r\n";
				현재번호없는버전 += "\t<A5> " + 보기들5개[4] + " </A5>\r\n";
				정답번호_스트링 = "정답 ③번";
			}
			if (보기들5개[3] == 정답)
			{
				현재번호없는버전 += "\t<A1> " + 보기들5개[0] + " </A1>\r\n";
				현재번호없는버전 += "\t<A2> " + 보기들5개[1] + " </A2>\r\n";
				현재번호없는버전 += "\t<A3> " + 보기들5개[2] + " </A3>\r\n";
				현재번호없는버전 += "\t<A4> " + 보기들5개[3] + " </A4>\r\n";
				현재번호없는버전 += "\t<A5> " + 보기들5개[4] + " </A5>\r\n";

				정답번호_스트링 = "정답 ④번";
			}
			if (보기들5개[4] == 정답)
			{
				현재번호없는버전 += "\t<A1> " + 보기들5개[0] + " </A1>\r\n";
				현재번호없는버전 += "\t<A2> " + 보기들5개[1] + " </A2>\r\n";
				현재번호없는버전 += "\t<A3> " + 보기들5개[2] + " </A3>\r\n";
				현재번호없는버전 += "\t<A4> " + 보기들5개[3] + " </A4>\r\n";
				현재번호없는버전 += "\t<A5> " + 보기들5개[4] + " </A5>\r\n";

				정답번호_스트링 = "정답 ⑤번";
			}

			현재번호없는버전 += "\t</A>\r\n";
			현재번호없는버전 += "\t<정답>\r\n";
			현재번호없는버전 += "\t" + 정답번호_스트링 + "\r\n";
			현재번호없는버전 += "\t</정답>\r\n";
			현재번호없는버전 += "\t<해석>\r\n";
			현재번호없는버전 += "\t" + 해석 + "\r\n";
			현재번호없는버전 += "\t</해석>\r\n";
			현재번호없는버전 += "</CAKE>\r\n";

			_현재번호++;

			현재번호있는버전 += 현재번호없는버전;
			return 현재번호있는버전;
		}

		public static void 보기들에서오답4개만들기(ref List<string> 보기들, string 정답, ref string 오답1, ref string 오답2, ref string 오답3, ref string 오답4)
		{
			List<정오답보기> 오답후보들 = new List<정오답보기>();
			bool 평서문 = true;

			if (변환.문자열.Right(정답, 1) == "?") 평서문 = false;


			foreach(string 현재보기들 in 보기들)
			{
				if(현재보기들 != 정답)
				{ 
					if((평서문 == true && 변환.문자열.Right(현재보기들, 1) != "?") || (평서문 == false && 변환.문자열.Right(현재보기들, 1) == "?"))
						오답후보들.Add(new 정오답보기() { 정오답보기스트링 = 현재보기들.Trim(), 가중치 = 1000 - Math.Abs(현재보기들.Trim().Length - 정답.Length)});
				}
			}
			오답후보들.Sort();

			오답1 = 오답후보들[0].ToString();
			오답2 = 오답후보들[1].ToString();
			오답3 = 오답후보들[2].ToString();
			오답4 = 오답후보들[3].ToString();

			if(변환.문자열.알파벳소문자여부확인(변환.문자열.Left(정답, 1)))
			{
				오답1 = 변환.문자열.Left(오답1, 1).ToLower() + 오답1.Substring(1);
				오답2 = 변환.문자열.Left(오답2, 1).ToLower() + 오답2.Substring(1);
				오답3 = 변환.문자열.Left(오답3, 1).ToLower() + 오답3.Substring(1);
				오답4 = 변환.문자열.Left(오답4, 1).ToLower() + 오답4.Substring(1);
			}
			else
			{
				오답1 = 변환.문자열.Left(오답1, 1).ToUpper() + 오답1.Substring(1);
				오답2 = 변환.문자열.Left(오답2, 1).ToUpper() + 오답2.Substring(1);
				오답3 = 변환.문자열.Left(오답3, 1).ToUpper() + 오답3.Substring(1);
				오답4 = 변환.문자열.Left(오답4, 1).ToUpper() + 오답4.Substring(1);
			}

            if ((정답.EndsWith(".") || 정답.EndsWith("!") || 정답.EndsWith("?")) && !오답1.EndsWith(".") && !오답1.EndsWith("!") && !오답1.EndsWith("?")) { 오답1 += "."; }
            if ((정답.EndsWith(".") || 정답.EndsWith("!") || 정답.EndsWith("?")) && !오답2.EndsWith(".") && !오답2.EndsWith("!") && !오답2.EndsWith("?")) { 오답2 += "."; }
            if ((정답.EndsWith(".") || 정답.EndsWith("!") || 정답.EndsWith("?")) && !오답3.EndsWith(".") && !오답3.EndsWith("!") && !오답3.EndsWith("?")) { 오답3 += "."; }
            if ((정답.EndsWith(".") || 정답.EndsWith("!") || 정답.EndsWith("?")) && !오답4.EndsWith(".") && !오답4.EndsWith("!") && !오답4.EndsWith("?")) { 오답4 += "."; }

            if ((!정답.EndsWith(".") && !정답.EndsWith("!") && !정답.EndsWith("?")) && (오답1.EndsWith(".") || 오답1.EndsWith("!") || 오답1.EndsWith("?"))) { 오답1 = 오답1.Substring(0, 오답1.Length - 1); }
            if ((!정답.EndsWith(".") && !정답.EndsWith("!") && !정답.EndsWith("?")) && (오답2.EndsWith(".") || 오답2.EndsWith("!") || 오답2.EndsWith("?"))) { 오답2 = 오답2.Substring(0, 오답2.Length - 1); }
            if ((!정답.EndsWith(".") && !정답.EndsWith("!") && !정답.EndsWith("?")) && (오답3.EndsWith(".") || 오답3.EndsWith("!") || 오답3.EndsWith("?"))) { 오답3 = 오답3.Substring(0, 오답3.Length - 1); }
            if ((!정답.EndsWith(".") && !정답.EndsWith("!") && !정답.EndsWith("?")) && (오답4.EndsWith(".") || 오답4.EndsWith("!") || 오답4.EndsWith("?"))) { 오답4 = 오답4.Substring(0, 오답4.Length - 1); }


        }

        public static bool 빈칸문제후보표시(string C, string N1, ref string 결과, ref int jump)
        {
            if (변환.문자열.문법문제표지제거(C).ToLower() == "as" && 변환.문자열.문법문제표지제거(N1) == "if") { 
                
                결과 = "{빈칸}" + C + " "+ N1 + "{/빈칸}"; jump = 1;
                결과 = 결과.Replace("{빈칸}{빈칸}", "{빈칸}");
                결과 = 결과.Replace("{/빈칸}{/빈칸}", "{/빈칸}");



                return true; 
            }
            else            return false;

        }

		public static bool 접속어문제후보표시(string C, string N1, ref string 결과, ref int jump)
        {
            if((C.문법문제표지제거() == "In" || C.문법문제표지제거() == "in")  && 변환.문자열.문법문제표지제거(N1).Left(8) == "contrast")
            {
                결과 = "{흐름}{빈칸}" + C + " " + N1 + "{/빈칸}";
                결과 = 결과.Replace("contrast,{/빈칸}", "contrast{/빈칸},");

                결과 = 결과.Replace("{흐름}{빈칸}{흐름}{빈칸}", "{흐름}{빈칸}");
                결과 = 결과.Replace("{/빈칸},{/빈칸}", "{/빈칸},");

                jump = 1;

                return true;
            }
            else if (변환.문자열.문법문제표지제거(C) == "although") { 
                결과 = "{빈칸}{어법:≠despite:}" + C + "{/빈칸}";
                결과 = 결과.Replace("{빈칸}{어법:≠despite:}{흐름}{빈칸}{어법:≠despite:}", "{빈칸}{어법:≠despite:}");
                결과 = 결과.Replace("{/빈칸}{/빈칸}", "{/빈칸}");
                return true; 
            }
			else if (변환.문자열.문법문제표지제거(C) == "Although")
			{
				결과 = "{흐름}{빈칸}{어법:≠Despite:}" + C + "{/빈칸}";
				결과 = 결과.Replace("{흐름}{빈칸}{어법:≠Despite:}{흐름}{빈칸}{어법:≠Despite:}", "{흐름}{빈칸}{어법:≠Despite:}");
				결과 = 결과.Replace("{/빈칸}{/빈칸}", "{/빈칸}");
				return true;
			}
			else if (변환.문자열.문법문제표지제거(C).ToLower() == "although")
			{
				결과 = "{흐름}{빈칸}{어법:≠despite:}" + C + "{/빈칸}";
				결과 = 결과.Replace("{흐름}{빈칸}{어법:≠despite:}{흐름}{빈칸}{어법:≠despite:}", "{흐름}{빈칸}{어법:≠despite:}");
				결과 = 결과.Replace("{/빈칸}{/빈칸}", "{/빈칸}");
				return true;
			}
			else if (변환.문자열.문법문제표지제거(C).ToLower() == "despite") {
                결과 = "{빈칸}{어법:≠although:}" + C + "{/빈칸}"; 
                결과 = 결과.Replace("{빈칸}{어법:≠although:}{빈칸}{어법:≠although:}", "{빈칸}{어법:≠although:}");
                결과 = 결과.Replace("{/빈칸}{/빈칸}", "{/빈칸}");
                return true;
            }
            else if (변환.문자열.문법문제표지제거(C).ToLower() == "because" && 변환.문자열.문법문제표지제거(N1).ToLower() == "of") 
            {
                결과 = "{어법:of 빼면 안됨:}" + C + " " + N1;
                결과 = 결과.Replace("{어법:of 빼면 안됨:}{어법:of 빼면 안됨:}", "{어법:of 빼면 안됨:}");
                jump = 1;
                return true;
            }
            else if (변환.문자열.문법문제표지제거(C).ToLower() == "because")
            {
                결과 = "{어법:≠because of:}" + C;
                결과 = 결과.Replace("{어법:≠because of:}{어법:≠because of:}", "{어법:≠because of:}");
                return true;
            }


            else return false;
        }

        #endregion

        #region 일치
        public static string 일치_한글(string 본문, string 해석, bool 에러메시지표시여부)
        {
            if (본문 == "") return "";
            string 올바른_보기1 = "", 올바른_보기2 = "", 올바른_보기3 = "", 올바른_보기4 = "", 잘못된_보기 = "";

            if (!일치_해석에서_올바른_보기_네_개_잘못된_보기_한_개_만들기(해석, ref 올바른_보기1, ref 올바른_보기2, ref 올바른_보기3, ref 올바른_보기4, ref 잘못된_보기, 에러메시지표시여부)) return "";
            return 일치_XML문제만들기(본문, 해석, 올바른_보기1, 올바른_보기2, 올바른_보기3, 올바른_보기4, 잘못된_보기);

        }

        public static bool 일치_해석에서_올바른_보기_네_개_잘못된_보기_한_개_만들기(string 해석, ref string 올바른_보기1, ref string 올바른_보기2, ref string 올바른_보기3, ref string 올바른_보기4, ref string 잘못된_보기, bool 에러메시지표시여부)
        {
			string 꼬투리 = "";

			if (!일치_한글_잘못된_보기_만들기(해석, ref 잘못된_보기, ref 꼬투리, 에러메시지표시여부)) return false;
	  
			// 해석을 여러개의 문장으로 나눕니다.
	        // 그 중에서 지문으로 내기 애매한 것을 제거합니다.
	        if(!일치_한글_올바른_보기_만들기(해석, 잘못된_보기, 꼬투리, ref 올바른_보기1, ref 올바른_보기2, ref 올바른_보기3, ref 올바른_보기4)) return false;


	        return true;
        }

		// 이 녀석을 좀 제대로 만들어야 된다.
		// 문장이 네 개가 넘어간다고 치면, 이걸 점수를 매겨가지고, 그럴싸한 것들만을 뽑아서 올바른 보기를 만들 필요가 있단 말이다.
		// 점수1|후보1 : 00520|이것은 보기 문장입니다.
		// 점수2|후보2 : 03020|저는 많이 쉬어야 합니다.
		// 점수3|후보3 : 00120|애들이 이상합니다.
		// 점수4|후보4 : 04024|개고생 했습니다.
		// 점수를 정렬한다.
        public static bool 일치_한글_올바른_보기_만들기(string 해석, string 잘못된_보기, string 꼬투리, ref string 올바른_보기1, ref string 올바른_보기2, ref string 올바른_보기3, ref string 올바른_보기4)
        {
            List<string> 해석문장들 = new List<string>();


            강력하지만무거운변환.문자열.문장단위의_문자열들로(해석, ref 해석문장들);

			// 점수를 매기는 함수를 만듭니다.


            List<string> 점수와해석문장들 = new List<string>();

			string[] 꼬투리들 = null;

			if(꼬투리.Contains(','))				꼬투리들 = 꼬투리.Split(',');



/*
            foreach (string 현재해석문장 in 해석문장들)
            {
                string s = 일치_현재문장을어떻게든일치보기로만들수있도록개조함(현재해석문장);

		        s = s.Trim();

		        if(s != "")
		        {
			        if(올바른_보기1 == "")		올바른_보기1 = s;
			        else if(올바른_보기2 == "")	올바른_보기2 = s;
			        else if(올바른_보기3 == "")	올바른_보기3 = s;
			        else if(올바른_보기4 == "")	올바른_보기4 = s;
		        }
	        }

	        if(올바른_보기4 == "")	return false;
*/

            foreach (string 현재해석문장 in 해석문장들)
            {
                string 현재문장 = 일치_현재문장을어떻게든일치보기로만들수있도록개조함(현재해석문장);

		        현재문장 = 현재문장.Trim();

		        if(현재문장 != "")
		        {
					// 점수가 낮을수록 좋다.
					int 점수 = 0; 

					// 현재 문장에 물음표가 있다면 점수를 올린다. 사실 사용하기 어려운 수준이다.
					if(현재문장.Contains("?"))	점수 += 8000;

					// 현재 문장에 느낌표가 있어도 사용하기 상당히 곤란하다.
					else if(현재문장.Contains("!")) 점수 += 7000;

					// "이것", "저것", "그것"도 약간은 곤란하다.
					else if(현재문장.Contains("이것") || 현재문장.Contains("저것") || 현재문장.Contains("그것")) 점수 += 3000;

					// "그 "로 시작하면 살짝 어색하다.
					if(현재문장.StartsWith("이를 ")) 점수 += 1000;

					// "그 "로 시작하면 살짝 어색하다.
					if(현재문장.StartsWith("이 ") || 현재문장.StartsWith("그 ") || 현재문장.StartsWith("저 ")) 점수 += 500;

					// 문장의 길이가 비슷할 수록 더 좋은 후보로 선정된다.
					점수 += Math.Abs(잘못된_보기.Length - 현재문장.Length) * 10;

					// 꼬투리에 있는 말이 있다면 점수가 낮아진다. 왜냐하면 꼬투리에 있는 말은 사실이므로, 사실과 거짓말이 함께 나올 경우, 거짓말이 금방 들통나기 때문이다.
					if(꼬투리.Contains(","))
					{
						for(int i = 0 ; i < 꼬투리들.Count(); i++)
						{
							if(현재문장.Contains(꼬투리들[i]))
							{
								점수 += 100;
							}
						}

					}
					else
					{
						if(현재문장.Contains(꼬투리))
							점수 += 100;
					}


					string 점수_해석문장 = String.Format("{0:00000}|{1}", 점수, 현재문장);

					점수와해석문장들.Add(점수_해석문장);
				}

			}

			if(점수와해석문장들.Count < 4) return false;

			점수와해석문장들.Sort();
			올바른_보기1 = 점수와해석문장들[0].Substring(점수와해석문장들[0].IndexOf("|") + 1);
			올바른_보기2 = 점수와해석문장들[1].Substring(점수와해석문장들[1].IndexOf("|") + 1);
			올바른_보기3 = 점수와해석문장들[2].Substring(점수와해석문장들[2].IndexOf("|") + 1);
			올바른_보기4 = 점수와해석문장들[3].Substring(점수와해석문장들[3].IndexOf("|") + 1);

			
	        return true;
        }

        public static string 일치_현재문장을어떻게든일치보기로만들수있도록개조함(string 성형전)
        {
            성형전 = 성형전.Replace("그래서", "");
            성형전 = 성형전.Replace("그러나,", "");
            성형전 = 성형전.Replace("그러나", "");
            성형전 = 성형전.Replace(" 심지어 ", " ");
            성형전 = 성형전.Replace("사실,", "");
            성형전 = 성형전.Replace(" 곧 ", " ");
            성형전 = 성형전.Replace(" 전혀 ", " ");
            성형전 = 성형전.Replace(" 매우 ", " ");
            성형전 = 성형전.Replace(" 다시는 ", " ");
            성형전 = 성형전.Replace(" 결코 ", " ");
            성형전 = 성형전.Replace(" 여전히 ", " ");
            성형전 = 성형전.Replace(" 더 이상 ", " ");
            성형전 = 성형전.Replace(" 반드시 ", " ");
            성형전 = 성형전.Replace(" 다시 ", " ");
            성형전 = 성형전.Replace("거나 ", "고 ");
            성형전 = 성형전.Replace(" 임시로 ", " ");
            성형전 = 성형전.Replace(" 아마도 ", " ");
            성형전 = 성형전.Replace("는 것도 ", "는 것은 ");
            성형전 = 성형전.Replace("이것을 알기 위해, ", "");
            성형전 = 성형전.Replace("이것을 알기 위해 ", "");
            성형전 = 성형전.Replace("예를 들면, ", "");
            성형전 = 성형전.Replace("예를 들면 ", "");
            성형전 = 성형전.Replace("마지막으로, ", " ");
            성형전 = 성형전.Replace("마지막으로 ", " ");
            성형전 = 성형전.Replace("첫째, ", " ");
            성형전 = 성형전.Replace("첫째 ", " ");
            성형전 = 성형전.Replace("그런 후 ", " ");

            return 성형전;
        }

        public static bool 일치_한글_잘못된_보기_만들기(string 해석, ref string 잘못된_보기, ref string 꼬투리, bool 에러메시지표시여부)
        {
            string 해석_임시;
            해석_임시 = 해석;
            해석_임시 = 해석_임시.Replace("아니다", "");


            if ((해석_임시.Contains("니다.")) &&
                (
                    (해석_임시.Contains(" 나는 ")) || (해석_임시.Contains(" 내가 ")) || (해석_임시.Contains(" 나의 "))
                    || (해석_임시.Contains(" 그는 ")) || (해석_임시.Contains(" 그가 ")) || (해석_임시.Contains(" 그의 "))
                    || (해석_임시.Contains(" 그녀는 ")) || (해석_임시.Contains(" 그녀가 ")) || (해석_임시.Contains(" 그녀의 "))
                    || (해석_임시.Contains(" 그들은 ")) || (해석_임시.Contains(" 그들이 ")) || (해석_임시.Contains(" 그들의 "))
                )
            )
				잘못된_보기 = 일치_한글_잘못된_문장_만들기(해석, ref 꼬투리, "나는_쌩판거짓말입니다", 에러메시지표시여부);
            else if (
                    (해석_임시.Contains(" 나는 ")) || (해석_임시.Contains(" 내가 ")) || (해석_임시.Contains(" 나의 "))
                    || (해석_임시.Contains(" 그는 ")) || (해석_임시.Contains(" 그가 ")) || (해석_임시.Contains(" 그의 "))
                    || (해석_임시.Contains(" 그녀는 ")) || (해석_임시.Contains(" 그녀가 ")) || (해석_임시.Contains(" 그녀의 "))
                    )
				잘못된_보기 = 일치_한글_잘못된_문장_만들기(해석, ref 꼬투리, "나는_쌩판거짓말", 에러메시지표시여부);
            else if (
                    (해석_임시.Contains(" 그들은 ")) || (해석_임시.Contains(" 그들이 ")) || (해석_임시.Contains(" 그들의 "))
                    )
				잘못된_보기 = 일치_한글_잘못된_문장_만들기(해석, ref 꼬투리, "그들은_쌩판거짓말", 에러메시지표시여부);
            else if (해석_임시.Contains("니다."))
				잘못된_보기 = 일치_한글_잘못된_문장_만들기(해석, ref 꼬투리, "쌩판거짓말입니다", 에러메시지표시여부);
            else
				잘못된_보기 = 일치_한글_잘못된_문장_만들기(해석, ref 꼬투리, "쌩판거짓말", 에러메시지표시여부);

            if (잘못된_보기 != "")
                return true;
            else
			{
                return false;
			}
        }

        public static string 일치_한글_잘못된_문장_만들기(string 해석, ref string 꼬투리, string 옵션, bool 에러메시지표시여부)
        {
            string 거짓말파일경로;
            List<string> 말바꿀_목록들 = new List<string>();
            List<string> 쌩판거짓말_목록들 = new List<string>();
            List<string> 거짓말할_꼬투리들 = new List<string>();
            List<string> 쌩판거짓말들 = new List<string>();

            if (옵션 == "나는_쌩판거짓말입니다")
                거짓말파일경로 = _문제DB루트폴더 + "일치_나는_쌩판거짓말입니다.qst";
            else if (옵션 == "나는_쌩판거짓말")
                거짓말파일경로 = _문제DB루트폴더 + "일치_나는_쌩판거짓말.qst";
            else if (옵션 == "그들은_쌩판거짓말")
                거짓말파일경로 = _문제DB루트폴더 + "일치_그들은_쌩판거짓말.qst";
            else if (옵션 == "쌩판거짓말입니다")
                거짓말파일경로 = _문제DB루트폴더 + "일치_쌩판거짓말입니다.qst";
            else if (옵션 == "쌩판거짓말")
                거짓말파일경로 = _문제DB루트폴더 + "일치_쌩판거짓말.qst";
            else
                return "";

            변환.Ansi파일.문자열들로(거짓말파일경로, ref 쌩판거짓말_목록들);

            foreach (string 쌩판거짓말_목록 in 쌩판거짓말_목록들)
            {
                if (쌩판거짓말_목록.Contains("|"))
                {
                    string[] 쌩판거짓말_목록_배열 = 쌩판거짓말_목록.Split('|');

                    거짓말할_꼬투리들.Add(쌩판거짓말_목록_배열[0]);
                    쌩판거짓말들.Add(쌩판거짓말_목록_배열[1]);
                }
                else { MessageBox.Show("거짓말 만드는 사전 형식에 오류가 있습니다. \"꼬투리|거짓말\"의 형태를 유지하여 입력하십시오."); }
            }

            for (int i = 0 ; i < 거짓말할_꼬투리들.Count; i++)
            {
                string 현재의_거짓말할_꼬투리 = 거짓말할_꼬투리들[i];

                if (!현재의_거짓말할_꼬투리.Contains(","))
                {
                    if (해석.Contains(현재의_거짓말할_꼬투리))
					{	
						꼬투리 = 현재의_거짓말할_꼬투리;
						return 쌩판거짓말들[i];
					}
                }
                else
                {
                    string[] 현재의_거짓말할_꼬투리들 = 현재의_거짓말할_꼬투리.Split(',');

                    bool 꼬투리가_지문에_모두_있는지 = true;

                    for (int j = 0; j < 현재의_거짓말할_꼬투리들.Count(); j++)
                    {
						if(현재의_거짓말할_꼬투리들[j].Contains("!"))
						{
							if(해석.Contains(현재의_거짓말할_꼬투리들[j].Replace("!", "")))
							{
								꼬투리가_지문에_모두_있는지 = false;
								break;
							}
						}
						else
						{
							if (!해석.Contains(현재의_거짓말할_꼬투리들[j]))
							{
								꼬투리가_지문에_모두_있는지 = false;
								break;
							}
						}
                    }

                    if (꼬투리가_지문에_모두_있는지 == true)
					{
						꼬투리 = 현재의_거짓말할_꼬투리;
                        return 쌩판거짓말들[i];
					}
                }
            }

			if(에러메시지표시여부)
	            MessageBox.Show(string.Format("{0}의 옵션으로 검색하였으나, 거짓말을 만들지 못하였습니다. 프로그램은 계속됩니다.", 옵션));

            return "";
        }

        public static string 일치_XML문제만들기(string 본문, string 해석, string 올바른_보기1, string 올바른_보기2, string 올바른_보기3, string 올바른_보기4, string 잘못된_보기)
        {
	        string XML결과 = "";

	        XML결과 += "<CAKE>\r";
            XML결과 += "\t<Q> " + string.Format("{0}", _현재번호) + ". 다음 글의 내용과 일치하지 않는 것은? </Q>\r";

	        XML결과  += "\t<T>\r";

	        XML결과  += "\t" + 본문;
	        XML결과  += "\r";
	        XML결과  += "\t</T>\r";

			List<string> 보기들 = new List<string>();

			보기들.Add(올바른_보기1);
			보기들.Add(올바른_보기2);
			보기들.Add(올바른_보기3);
			보기들.Add(올바른_보기4);
			보기들.Add(잘못된_보기);

			보기들.Sort();

	        if(보기들[0] == 잘못된_보기)
	        {
		        XML결과 += "\t<A>\r";
		        XML결과 += "\t<A1> "; XML결과 += 잘못된_보기;		XML결과 += " </A1>\r";
		        XML결과 += "\t<A2> "; XML결과 += 올바른_보기4;	XML결과 += " </A2>\r";
		        XML결과 += "\t<A3> "; XML결과 += 올바른_보기2;	XML결과 += " </A3>\r";
		        XML결과 += "\t<A4> "; XML결과 += 올바른_보기3;	XML결과 += " </A4>\r";
		        XML결과 += "\t<A5> "; XML결과 += 올바른_보기1;	XML결과 += " </A5>\r";
		        XML결과 += "\t</A>\r";

		        XML결과 += "\t<정답>\r";
		        XML결과 += "\t정답 ①번\r";
	        }
	        else if(보기들[1] == 잘못된_보기)
	        {
		        XML결과 += "\t<A>\r";
		        XML결과 += "\t<A1> "; XML결과 += 올바른_보기3;	XML결과 += " </A1>\r";
		        XML결과 += "\t<A2> "; XML결과 += 잘못된_보기;		XML결과 += " </A2>\r";
		        XML결과 += "\t<A3> "; XML결과 += 올바른_보기1;	XML결과 += " </A3>\r";
		        XML결과 += "\t<A4> "; XML결과 += 올바른_보기2;	XML결과 += " </A4>\r";
		        XML결과 += "\t<A5> "; XML결과 += 올바른_보기4;	XML결과 += " </A5>\r";
		        XML결과 += "\t</A>\r";

				XML결과 += "\t<정답>\r";
				XML결과 += "\t정답 ②번\r";
	        }
	        else if(보기들[2] == 잘못된_보기)
	        {
		        XML결과 += "\t<A>\r";
		        XML결과 += "\t<A1> "; XML결과 += 올바른_보기4;	XML결과 += " </A1>\r";
		        XML결과 += "\t<A2> "; XML결과 += 올바른_보기2;	XML결과 += " </A2>\r";
		        XML결과 += "\t<A3> "; XML결과 += 잘못된_보기;		XML결과 += " </A3>\r";
		        XML결과 += "\t<A4> "; XML결과 += 올바른_보기3;	XML결과 += " </A4>\r";
		        XML결과 += "\t<A5> "; XML결과 += 올바른_보기1;	XML결과 += " </A5>\r";
		        XML결과 += "\t</A>\r";

				XML결과 += "\t<정답>\r";
				XML결과 += "\t정답 ③번\r";
	        }
	        else if(보기들[3] == 잘못된_보기)
	        {
		        XML결과 += "\t<A>\r";
		        XML결과 += "\t<A1> "; XML결과 += 올바른_보기1;	XML결과 += " </A1>\r";
		        XML결과 += "\t<A2> "; XML결과 += 올바른_보기2;	XML결과 += " </A2>\r";
		        XML결과 += "\t<A3> "; XML결과 += 올바른_보기4;	XML결과 += " </A3>\r";
		        XML결과 += "\t<A4> "; XML결과 += 잘못된_보기;		XML결과 += " </A4>\r";
		        XML결과 += "\t<A5> "; XML결과 += 올바른_보기3;	XML결과 += " </A5>\r";
		        XML결과 += "\t</A>\r";

				XML결과 += "\t<정답>\r";
				XML결과 += "\t정답 ④번\r";
	        }
	        else if(보기들[4] == 잘못된_보기)
	        {
		        XML결과 += "\t<A>\r";
		        XML결과 += "\t<A1> "; XML결과 += 올바른_보기1;	XML결과 += " </A1>\r";
		        XML결과 += "\t<A2> "; XML결과 += 올바른_보기4;	XML결과 += " </A2>\r";
		        XML결과 += "\t<A3> "; XML결과 += 올바른_보기3;	XML결과 += " </A3>\r";
		        XML결과 += "\t<A4> "; XML결과 += 올바른_보기2;	XML결과 += " </A4>\r";
		        XML결과 += "\t<A5> "; XML결과 += 잘못된_보기;		XML결과 += " </A5>\r";
		        XML결과 += "\t</A>\r";

				XML결과 += "\t<정답>\r";
				XML결과 += "\t정답 ⑤번\r";
	        }
			XML결과 += "\t</정답>\r";

			XML결과 += "\t<해석>\r";
			XML결과 += "\t" + 해석 + "\r";
			XML결과 += "\t</해석>\r";

			XML결과 += "</CAKE>\r";

            _현재번호++;

	        return XML결과;
        }
        #endregion
        #region 어법
        public static string 어법(string 본문, string 해석)
        {
            if (본문 == "") return "";
            string XML = "";
			
            XML += 어법문제출제_비교급_강조하는_Even_Much_Still_Far_ALot(본문, 해석);

			// 이하는 정오형식의 어법출제문제입니다.
			List<string> 본문의_단어들 = new List<string>();
			변환.문자열.탭과개행문자를살린어절들로(본문, ref 본문의_단어들);


			int 출제가능갯수 = 어법문제출제_1단계_출제가능문제갯수확인(ref 본문의_단어들);


            if (출제가능갯수 == 0)
            {		// 문법문제로 낼 것이 없습니다.
            }
            else if (출제가능갯수 == 1)
            {
                // 문법문제로 낼 것의 위치를 확인
                XML += 어법문제출제_2단계_XML형식문제출제(본문, 해석, 1);
            }
            #region 문법문제 하나 이상
            else if (출제가능갯수 == 2)
            {	
                XML += 어법문제출제_2단계_XML형식문제출제(본문, 해석, 2);
            }
            else if (출제가능갯수 == 3)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 1, 2);
            }
            else if (출제가능갯수 == 4)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 2, 3);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 2, 3);
            }
            else if (출제가능갯수 == 5)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 2, 4);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 3, 4);
            }
            else if (출제가능갯수 == 6)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 2, 4);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 3, 5);
            }
            else if (출제가능갯수 == 7)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 2, 4);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 3, 5);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 3, 6);
            }
            else if (출제가능갯수 == 8)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 3, 6);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 4, 7);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 5, 7);
            }
            else if (출제가능갯수 == 9)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 3, 6);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 4, 7);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 5, 8);
            }
            else if (출제가능갯수 == 10)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 3, 6);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 4, 7);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 5, 8);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 4, 9);
            }
            else if (출제가능갯수 == 11)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 4, 8);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 5, 9);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 6, 10);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 7, 10);
            }
            else if (출제가능갯수 == 12)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 4, 8);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 5, 9);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 6, 10);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 7, 11);
            }
            else if (출제가능갯수 == 13)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 4, 8);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 5, 9);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 6, 10);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 7, 11);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 6, 12);
            }
            else if (출제가능갯수 == 14)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 5, 9);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 6, 11);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 7, 12);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 8, 13);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 9, 13);
            }
            else if (출제가능갯수 == 15)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 5, 10);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 6, 11);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 7, 12);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 8, 13);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 9, 14);
            }
            else if (출제가능갯수 == 16)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 5, 10);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 6, 11);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 7, 12);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 8, 13);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 9, 14);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 7, 15);
            }
            else if (출제가능갯수 == 17)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 6, 12);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 7, 13);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 8, 14);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 9, 15);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 10, 16);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 11, 15);
            }
            else if (출제가능갯수 == 18)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 6, 12);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 7, 13);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 8, 14);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 9, 15);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 10, 16);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 11, 17);
            }
            else if (출제가능갯수 == 19)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 6, 12);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 7, 13);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 8, 14);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 9, 15);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 10, 16);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 11, 17);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 9, 18);
            }
            else if (출제가능갯수 == 20)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 7, 14);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 8, 15);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 9, 16);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 10, 17);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 11, 18);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 12, 19);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 13, 19);
            }
            else if (출제가능갯수 == 21)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 7, 14);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 8, 15);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 9, 16);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 10, 17);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 11, 18);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 12, 19);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 13, 20);
            }
            else if (출제가능갯수 == 22)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 8, 16);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 9, 17);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 10, 18);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 11, 19);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 12, 20);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 13, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 14, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 15, 21);
            }
            else if (출제가능갯수 == 23)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 8, 16);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 9, 17);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 10, 18);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 11, 19);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 12, 20);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 13, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 14, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 15, 22);
            }
            else if (출제가능갯수 == 24)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 8, 16);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 9, 17);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 10, 18);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 11, 19);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 12, 20);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 13, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 14, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 15, 23);
            }
            else if (출제가능갯수 == 25)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 9, 18);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 10, 19);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 11, 20);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 12, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 13, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 14, 23);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 15, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 16, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 17, 24);
            }
            else if (출제가능갯수 == 26)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 9, 18);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 10, 19);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 11, 20);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 12, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 13, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 14, 23);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 15, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 16, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 17, 25);
            }
            else if (출제가능갯수 == 27)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 9, 18);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 10, 19);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 11, 20);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 12, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 13, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 14, 23);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 15, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 16, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 17, 26);
            }
            else if (출제가능갯수 == 28)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 10, 20);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 11, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 12, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 13, 23);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 14, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 15, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 16, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 17, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 18, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 19, 27);
            }
            else if (출제가능갯수 == 29)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 10, 20);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 11, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 12, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 13, 23);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 14, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 15, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 16, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 17, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 18, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 19, 28);
            }
            else if (출제가능갯수 == 30)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 10, 20);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 11, 21);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 12, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 13, 23);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 14, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 15, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 16, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 17, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 18, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 19, 29);
            }
            else if (출제가능갯수 == 31)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 11, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 12, 23);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 13, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 14, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 15, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 16, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 17, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 18, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 19, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 20, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 21, 30);
            }
            else if (출제가능갯수 == 32)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 11, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 12, 23);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 13, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 14, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 15, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 16, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 17, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 18, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 19, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 20, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 21, 31);
            }
            else if (출제가능갯수 == 33)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 11, 22);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 12, 23);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 13, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 14, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 15, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 16, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 17, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 18, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 19, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 20, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 21, 32);
            }
            else if (출제가능갯수 == 34)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 12, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 13, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 14, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 15, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 16, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 17, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 18, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 19, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 20, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 21, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 22, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 23, 33);
            }
            else if (출제가능갯수 == 35)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 12, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 13, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 14, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 15, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 16, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 17, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 18, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 19, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 20, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 21, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 22, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 23, 34);
            }
            else if (출제가능갯수 == 36)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 12, 24);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 13, 25);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 14, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 15, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 16, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 17, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 18, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 19, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 20, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 21, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 22, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 23, 35);
            }
            else if (출제가능갯수 == 37)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 13, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 14, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 15, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 16, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 17, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 18, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 19, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 20, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 21, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 22, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 23, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 24, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 25, 36);
            }
            else if (출제가능갯수 == 38)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 13, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 14, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 15, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 16, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 17, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 18, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 19, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 20, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 21, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 22, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 23, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 24, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 25, 37);
            }
            else if (출제가능갯수 == 39)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 13, 26);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 14, 27);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 15, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 16, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 17, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 18, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 19, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 20, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 21, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 22, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 23, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 24, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 25, 38);
            }
            else if (출제가능갯수 == 40)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 14, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 15, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 16, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 17, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 18, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 19, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 20, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 21, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 22, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 23, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 24, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 25, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 26, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 27, 39);
            }
            else if (출제가능갯수 == 41)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 14, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 15, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 16, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 17, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 18, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 19, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 20, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 21, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 22, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 23, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 24, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 25, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 26, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 27, 40);
            }
            else if (출제가능갯수 == 42)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 14, 28);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 15, 29);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 16, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 17, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 18, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 19, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 20, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 21, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 22, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 23, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 24, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 25, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 26, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 27, 41);
            }
            else if (출제가능갯수 == 43)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 15, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 16, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 17, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 18, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 19, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 20, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 21, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 22, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 23, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 24, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 25, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 26, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 27, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 28, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 29, 42);
            }
            else if (출제가능갯수 == 44)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 15, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 16, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 17, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 18, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 19, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 20, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 21, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 22, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 23, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 24, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 25, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 26, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 27, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 28, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 29, 43);
            }
            else if (출제가능갯수 == 45)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 15, 30);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 16, 31);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 17, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 18, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 19, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 20, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 21, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 22, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 23, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 24, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 25, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 26, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 27, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 28, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 29, 44);
            }
            else if (출제가능갯수 == 46)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 16, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 17, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 18, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 19, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 20, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 21, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 22, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 23, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 24, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 25, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 26, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 27, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 28, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 29, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 30, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 31, 45);
            }
            else if (출제가능갯수 == 47)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 16, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 17, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 18, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 19, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 20, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 21, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 22, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 23, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 24, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 25, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 26, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 27, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 28, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 29, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 30, 46);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 31, 46);
            }
            else if (출제가능갯수 == 48)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 16, 32);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 17, 33);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 18, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 19, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 20, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 21, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 22, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 23, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 24, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 25, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 26, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 27, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 28, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 29, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 30, 46);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 31, 47);
            }
            else if (출제가능갯수 == 49)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 17, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 18, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 19, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 20, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 21, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 22, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 23, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 24, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 25, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 26, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 27, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 28, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 29, 46);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 30, 47);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 31, 48);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 32, 48);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 16, 33, 48);
            }
            else if (출제가능갯수 == 50)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 17, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 18, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 19, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 20, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 21, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 22, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 23, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 24, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 25, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 26, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 27, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 28, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 29, 46);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 30, 47);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 31, 48);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 32, 49);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 16, 33, 49);
            }
            else if (출제가능갯수 == 51)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 17, 34);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 18, 35);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 19, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 20, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 21, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 22, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 23, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 24, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 25, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 26, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 27, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 28, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 29, 46);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 30, 47);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 31, 48);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 32, 49);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 16, 33, 50);
            }
            else if (출제가능갯수 == 52)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 18, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 19, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 20, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 21, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 22, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 23, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 24, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 25, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 26, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 27, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 28, 46);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 29, 47);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 30, 48);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 31, 49);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 32, 50);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 33, 51);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 16, 34, 51);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 17, 35, 51);

            }
            else if (출제가능갯수 == 53)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 18, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 19, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 20, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 21, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 22, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 23, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 24, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 25, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 26, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 27, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 28, 46);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 29, 47);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 30, 48);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 31, 49);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 32, 50);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 33, 51);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 16, 34, 52);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 17, 35, 52);

            }
            else if (출제가능갯수 == 54)
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 18, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 19, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 20, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 21, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 22, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 23, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 24, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 25, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 26, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 27, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 28, 46);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 29, 47);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 30, 48);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 31, 49);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 32, 50);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 33, 51);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 16, 34, 52);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 17, 35, 53);

            }
            else
            {
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 0, 18, 36);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 1, 19, 37);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 2, 20, 38);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 3, 21, 39);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 4, 22, 40);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 5, 23, 41);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 6, 24, 42);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 7, 25, 43);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 8, 26, 44);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 9, 27, 45);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 10, 28, 46);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 11, 29, 47);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 12, 30, 48);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 13, 31, 49);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 14, 32, 50);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 15, 33, 51);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 16, 34, 52);
                XML += 어법문제출제_2단계_XML형식문제출제(ref 본문의_단어들, 해석, 17, 35, 53);
            }
            #endregion
            return XML;
        }

        public static string 어법문제출제_비교급_강조하는_Even_Much_Still_Far_ALot(string 지문, string 해석)
        {
	        string			XML = "";

            List<string> 지문의_단어들 = new List<string>();



	        string			C;	// current word
	        string			N1; // 1 word next
	        string			N2; // 2 word next



            변환.문자열.탭과개행문자를살린어절들로(지문, ref 지문의_단어들);

	        for(int i = 0 ; i < 지문의_단어들.Count ;i++)
	        {
											        C		= 지문의_단어들[i];
		        if(i < 지문의_단어들.Count() - 1)	N1		= 지문의_단어들[i+1];		else			N1		= "";
		        if(i < 지문의_단어들.Count() - 2)	N2		= 지문의_단어들[i+2];		else			N2		= "";	

		        if(((C == "even") || (C == "much")  || (C == "still")  || (C == "far") ) && _검색.비교급확인(N1))
		        {
			        XML += "<CAKE>\n";

			        XML += "\t<Q> " + _현재번호 + ". 다음 글을 읽고, 빈칸에 들어갈 말로 적절하지 않은 것을 고르시오. </Q>\r";

			        XML += "\t<T>\n";
			        XML += "\t";

			        for(int j = 0 ; j < i ; j++)	{	XML += 지문의_단어들[j];		XML += " ";}
			        XML += "[______] ";
			        for(int j = i + 1 ; j < 지문의_단어들.Count; j++)	{	XML += 지문의_단어들[j];		if(j < 지문의_단어들.Count - 1) XML += " ";}


			        XML += "\n";
			        XML += "\t</T>\n";

			        XML += "\t<A>\n";
			        XML += "\t<A1> even </A1>\n";
			        XML += "\t<A2> much </A2>\n";
			        XML += "\t<A3> still </A3>\n";
			        XML += "\t<A4> far </A4>\n";
			        XML += "\t<A5> very </A5>\n";
			        XML += "\t</A>\n";

			        XML += "\t<정답>\n";
			        XML += "\t정답 ⑤번\n";

			        XML += "\t</정답>\n";
			        XML += "</CAKE>\n";

                    _현재번호++;
		        }

		        if(((C == "Even") || (C == "Much")  || (C == "Still")  || (C == "Far") ) && _검색.비교급확인(N1))
		        {
			        XML += "<CAKE>\n";


			        XML += "\t<Q> " + _현재번호 + ". 다음 글을 읽고, 빈칸에 들어갈 말로 적절하지 않은 것을 고르시오. </Q>\r";

			        XML += "\t<T>\n";
			        XML += "\t";

			        for(int j = 0 ; j < i ; j++)	{	XML += 지문의_단어들[j];		XML += " ";}
			        XML += "[______] ";
			        for(int j = i + 1 ; j < 지문의_단어들.Count; j++)	{	XML += 지문의_단어들[j];		if(j < 지문의_단어들.Count - 1) XML += " ";}


			        XML += "\n";
			        XML += "\t</T>\n";

			        XML += "\t<A>\n";
			        XML += "\t<A1> Even </A1>\n";
			        XML += "\t<A2> Much </A2>\n";
			        XML += "\t<A3> Still </A3>\n";
			        XML += "\t<A4> Far </A4>\n";
			        XML += "\t<A5> Very </A5>\n";
			        XML += "\t</A>\n";

			        XML += "\t<정답>\n";
			        XML += "\t정답 ⑤번\n";

			        XML += "\t</정답>\n";
			        XML += "</CAKE>\n";

                    _현재번호++;
		        }

		        if((C == "a") && (N1 == "lot") && _검색.비교급확인(N2))
		        {
			        XML += "<CAKE>\n";

                    XML += "\t<Q> " + _현재번호 + ". 다음 글을 읽고, 빈칸에 들어갈 말로 적절하지 않은 것을 고르시오. </Q>\r";

			        XML += "\t<T>\n";
			        XML += "\t";

			        for(int j = 0 ; j < i ; j++)	{	XML += 지문의_단어들[j];		XML += " ";}
			        XML += "[______] ";
			        for(int j = i + 2 ; j < 지문의_단어들.Count; j++)	{	XML += 지문의_단어들[j];		if(j < 지문의_단어들.Count - 1) XML += " ";}


			        XML += "\n";
			        XML += "\t</T>\n";

			        XML += "\t<A>\n";
			        XML += "\t<A1> even </A1>\n";
			        XML += "\t<A2> much </A2>\n";
			        XML += "\t<A3> still </A3>\n";
			        XML += "\t<A4> a lot </A4>\n";
			        XML += "\t<A5> very </A5>\n";
			        XML += "\t</A>\n";

			        XML += "\t<정답>\n";
			        XML += "\t정답 ⑤번\n";

			        XML += "\t</정답>\n";
			        XML += "</CAKE>\n";

                    _현재번호++;
		        }

		        if((C == "A") && (N1 == "lot") && _검색.비교급확인(N2))
		        {
			        XML += "<CAKE>\n";

                    XML += "\t<Q> " + _현재번호 + ". 다음 글을 읽고, 빈칸에 들어갈 말로 적절하지 않은 것을 고르시오. </Q>\r";

			        XML += "\t<T>\n";
			        XML += "\t";

			        for(int j = 0 ; j < i ; j++)	{	XML += 지문의_단어들[j];		XML += " ";}
			        XML += "[______] ";
			        for(int j = i + 2 ; j < 지문의_단어들.Count; j++)	{	XML += 지문의_단어들[j];		if(j < 지문의_단어들.Count - 1) XML += " ";}


			        XML += "\n";
			        XML += "\t</T>\n";

			        XML += "\t<A>\n";
			        XML += "\t<A1> Even </A1>\n";
			        XML += "\t<A2> Much </A2>\n";
			        XML += "\t<A3> Still </A3>\n";
			        XML += "\t<A4> A lot </A4>\n";
			        XML += "\t<A5> Very </A5>\n";
			        XML += "\t</A>\n";

			        XML += "\t<정답>\n";
			        XML += "\t정답 ⑤번\n";

			        XML += "\t</정답>\n";
			        XML += "</CAKE>\n";

			        _현재번호++;
		        }

		        if((C == "A") && (N1 == "Lot") && _검색.비교급확인(N2))
		        {
			        XML += "<CAKE>\n";


			        XML += "\t<Q> " + _현재번호 + ". 다음 글을 읽고, 빈칸에 들어갈 말로 적절하지 않은 것을 고르시오. </Q>\r";

			        XML += "\t<T>\n";
			        XML += "\t";

			        for(int j = 0 ; j < i ; j++)	{	XML += 지문의_단어들[j];		XML += " ";}
			        XML += "[______] ";
			        for(int j = i + 2 ; j < 지문의_단어들.Count; j++)	{	XML += 지문의_단어들[j];		if(j < 지문의_단어들.Count - 1) XML += " ";}


			        XML += "\n";
			        XML += "\t</T>\n";

			        XML += "\t<A>\n";
			        XML += "\t<A1> Even </A1>\n";
			        XML += "\t<A2> Much </A2>\n";
			        XML += "\t<A3> Still </A3>\n";
			        XML += "\t<A4> A Lot </A4>\n";
			        XML += "\t<A5> Very </A5>\n";
			        XML += "\t</A>\n";

			        XML += "\t<정답>\n";
			        XML += "\t정답 ⑤번\n";

			        XML += "\t</정답>\n";
			        XML += "</CAKE>\n";

			        _현재번호++;
		        }

	        }

	        return XML;
        }
        public static int 어법문제출제_1단계_출제가능문제갯수확인(ref List<string> 단어들)
        {
            _어법_이미출제한것들.Clear();

	        int				jump = 0;
	        string			sRes, SNULL = "";

	        string			B9;	// 9 word before
	        string			B8;	// 8 word before
	        string			B7;	// 7 word before
	        string			B6;	// 6 word before
	        string			B5;	// 5 word before
	        string			B4;	// 4 word before

	        string			B3;	// 3 word before
	        string			B2; // 2 word before
	        string			B1;	// 1 word before
	        string			C;	// current word
	        string			N1; // 1 word next
	        string			N2; // 2 word next
	        string			N3; // 3 word next

	        int nCreatedQuestion = 0;

	        // B3, B2, B1, C, N1, N2, N3
	        for(int i = 0 ; i < 단어들.Count ;i++)
	        {
		        if(i > 8)						B9		= 단어들[i-9];		else			B9		= "";
		        if(i > 7)						B8		= 단어들[i-8];		else			B8		= "";
		        if(i > 6)						B7		= 단어들[i-7];		else			B7		= "";
		        if(i > 5)						B6		= 단어들[i-6];		else			B6		= "";
		        if(i > 4)						B5		= 단어들[i-5];		else			B5		= "";
		        if(i > 3)						B4		= 단어들[i-4];		else			B4		= "";
		        if(i > 2)						B3		= 단어들[i-3];		else			B3		= "";
		        if(i > 1)						B2		= 단어들[i-2];		else			B2		= "";
		        if(i > 0)						B1		= 단어들[i-1];		else			B1		= "";
										        C		= 단어들[i];
		        if(i < 단어들.Count - 1)	N1		= 단어들[i+1];		else			N1		= "";
		        if(i < 단어들.Count - 2)	N2		= 단어들[i+2];		else			N2		= "";
		        if(i < 단어들.Count - 3)	N3		= 단어들[i+3];		else			N3		= "";





		        sRes = "";
		        if(어법문제출제_1단계_단어별_정답오답산출(B9, B8, B7, B6, B5, B4, B3, B2, B1, C, N1, N2, N3, ref jump, ref sRes, ref SNULL))
		        {
			        nCreatedQuestion++;

                    i += jump;
		        }
	        }
	        return nCreatedQuestion;
        }
        public static bool 어법문제출제_1단계_단어별_정답오답산출(string B9, string B8, string B7, string B6, string B5, string B4, string B3, string B2, string B1, string C, string N1, string N2, string N3, ref int jump, ref string result, ref string WrongAnswer)
        {
        //  매개 변수 설명
        //	CString			B3;	// 3 word before
        //	CString			B2; // 2 word before
        //	CString			B1;	// 1 word before
        //	CString			C;	// current word
        //	CString			N1; // 1 word next
        //	CString			N2; // 2 word next
        //	CString			N3; // 3 word next
        // jump란 이번 단어와 다음 단어를 가지고 하나의 단어 결과를 만들 때, 이 다음 처리에서는 다음 단어를 처리하지 않기 위해서 한번 건너 뛰라는 뜻이다.
            bool 출제가능성 = false;
	        jump = 0 ; // 기본 리셋, 절대 없어서는 안됨


	        if(어법문제출제_세부단계_기타어법문제(			B2,	B1,	C,	N1,	N2,	ref result, ref WrongAnswer, ref jump))	{		출제가능성 =  true;}		// 기타 잡 처리
            else if (어법문제출제_세부단계_가정법(B4, B3, B2, B1, C, ref result, ref WrongAnswer)) { jump = 0; 출제가능성 = true; }
            else if(어법문제출제_세부단계_지각동사(      B4,   B3, B2, B1, C, ref result, ref WrongAnswer)){ jump = 0 ;            출제가능성 =  true;}
            else if(어법문제출제_세부단계_사역동사(          B3,  B2, B1, C, ref result, ref WrongAnswer)){ jump = 0 ;            출제가능성 =  true;}
            else if(어법문제출제_세부단계_5형식To부정사(     B3,  B2, B1, C, N1, ref result, ref WrongAnswer)){ jump = 1 ;            출제가능성 =  true;}

            else if (어법문제출제_세부단계_is와are의구분(B1, C, ref result, ref WrongAnswer)) { jump = 0; 출제가능성 = true; }     // 과거분사인 경우, 과거분사와 현재분사의 구분
			else if (어법문제출제_세부단계_similarToWith(B1, C, ref result, ref WrongAnswer)) { jump = 0; 출제가능성 = true; }		// similar가 with는 안됨!!


			else if(어법문제출제_세부단계_Keep목적어FromIng와그냥Ing(B2,B1,C,N1, ref jump, ref result, ref WrongAnswer)) {      출제가능성 =  true;}
            else if(어법문제출제_세부단계_동명사와to부정사의구분(    B1, C, N1, ref jump, ref result, ref WrongAnswer)){        출제가능성 =  true;}
	        else if(어법문제출제_세부단계_전치사안쓰는타동사(	B2, B1,	C,	N1,	ref result, ref WrongAnswer))		{jump = 0	;	출제가능성 =  true;}		// 타동사이므로 전치사를 쓰지 않는 동사 확인
	        else if(어법문제출제_세부단계_수동태안쓰는자동사(		B1,	C,		ref	result, ref WrongAnswer))	{jump = 0	;	출제가능성 =  true;}		// 자동사이므로 수동태로 쓰지 않는 동사 확인
	        else if(어법문제출제_세부단계_4형식으로안쓰는3형식동사(		C,	N1,	ref result, ref WrongAnswer))	{jump = 1	;	출제가능성 =  true;}		// 4형식으로 쓰지 않는 3형식 동사들
	        else if(어법문제출제_세부단계_1형식동사의전치사확인(		C,	N1,		ref result, ref WrongAnswer))	{jump = 1	;	출제가능성 =  true;}		// 전치사를 빼먹기 쉬운 1형식 동사들
	        else if(어법문제출제_세부단계_조동사의과거형(			C,	N1,	N2,	ref result, ref WrongAnswer))	{jump = 0	;	출제가능성 =  true;}		// 조동사의 과거형
	        else if(어법문제출제_세부단계_구와절구분(					C,		ref	result, ref WrongAnswer))	{jump = 0	;	출제가능성 =  true;}
	        else if(어법문제출제_세부단계_형용사부사구분(				C,	N1,	ref result, ref WrongAnswer))	{jump = 0	;	출제가능성 =  true;}
	        else if(어법문제출제_세부단계_과거분사현재분사구분(		B1,	C,		ref	result, ref WrongAnswer))	{jump = 0	;	출제가능성 =  true;}		// 과거분사인 경우, 과거분사와 현재분사의 구분
	        else if(어법문제출제_세부단계_관계사찾기(					C,		ref	result, ref WrongAnswer))	{jump = 0	;	출제가능성 =  true;}		// 올바른 관계사 찾기


            if(출제가능성 == true)
            {
                if(!_어법_이미출제한것들.Contains(변환.문자열.문장부호제거(result)))
                {
                    _어법_이미출제한것들.Add(변환.문자열.문장부호제거(result));
                    return true;
                }
                else
                {
                    jump = 0;
                    result = C;
				 //   if(jump == 0) result = C;
				 //   if(jump == 1) result = string.Format("{0} {1}",			C, N1);
				 //   if(jump == 2) result = string.Format("{0} {1} {2}",		C, N1, N2);
				 //   if(jump == 3) result = string.Format("{0} {1} {2} {3}",	C, N1, N2, N3);
                    
                    return false;
                }
            }

            return false;
        }

        public static bool 어법문제출제_세부단계_지각동사(string B4, string B3, string B2, string B1, string C, ref string result, ref string WrongAnswer)
        {
            // 지각동사 목적어 원형
            if(_검색.지각동사인지확인(B2) && _검색.목적격대명사인지확인(B1) && _검색.Ing형이있는원형동사인지(변환.문자열.문장부호제거(C)))
            {
                WrongAnswer = string.Format("to {0}", 변환.문자열.문장부호제거(C));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(C), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }
            // 지각동사 목적어 ing
            if(_검색.지각동사인지확인(B2) && _검색.목적격대명사인지확인(B1) && _검색.Ing형인지(변환.문자열.문장부호제거(C)))
            {
                WrongAnswer = string.Format("to {0}", _검색.Ing형을원형으로(변환.문자열.문장부호제거(C)));
                result = string.Format("[to {0} / {1}]", _검색.Ing형을원형으로(변환.문자열.문장부호제거(C)), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }
            // 지각동사 전치사 목적어 원형
            if(_검색.지각동사_전치사인지확인(B3, B2) && _검색.목적격대명사인지확인(B1) && _검색.Ing형이있는원형동사인지(변환.문자열.문장부호제거(C)))
            {
                WrongAnswer = string.Format("to {0}", 변환.문자열.문장부호제거(C));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(C), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }
            // 지각동사 전치사 목적어 ing
            if(_검색.지각동사_전치사인지확인(B3, B2) && _검색.목적격대명사인지확인(B1) && _검색.Ing형인지(변환.문자열.문장부호제거(C)))
            {
                WrongAnswer = string.Format("to {0}", _검색.Ing형을원형으로(변환.문자열.문장부호제거(C)));
                result = string.Format("[to {0} / {1}]", _검색.Ing형을원형으로(변환.문자열.문장부호제거(C)), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }
            ////
            // 지각동사 명사구 원형
            if(_검색.지각동사인지확인(B3) && _검색.명사구인지확인(B2, B1) && _검색.Ing형이있는원형동사인지(변환.문자열.문장부호제거(C)))
            {
                WrongAnswer = string.Format("to {0}", 변환.문자열.문장부호제거(C));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(C), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }
            // 지각동사 명사구 ing
            if(_검색.지각동사인지확인(B3) && _검색.명사구인지확인(B2, B1) && _검색.Ing형인지(변환.문자열.문장부호제거(C)))
            {
                WrongAnswer = string.Format("to {0}", _검색.Ing형을원형으로(변환.문자열.문장부호제거(C)));
                result = string.Format("[to {0} / {1}]", _검색.Ing형을원형으로(변환.문자열.문장부호제거(C)), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }
            // 지각동사 명사구 목적어 원형
            if(_검색.지각동사_전치사인지확인(B4, B3) && _검색.명사구인지확인(B2, B1) && _검색.Ing형이있는원형동사인지(변환.문자열.문장부호제거(C)))
            {
                WrongAnswer = string.Format("to {0}", 변환.문자열.문장부호제거(C));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(C), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }
            // 지각동사 명사구 목적어 ing
            if(_검색.지각동사_전치사인지확인(B4, B3) && _검색.명사구인지확인(B2, B1) && _검색.Ing형인지(변환.문자열.문장부호제거(C)))
            {
                WrongAnswer = string.Format("to {0}", _검색.Ing형을원형으로(변환.문자열.문장부호제거(C)));
                result = string.Format("[to {0} / {1}]", _검색.Ing형을원형으로(변환.문자열.문장부호제거(C)), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }


            return false;
        }

        public static bool 어법문제출제_세부단계_가정법(string B4, string B3, string B2, string B1, string C, ref string result, ref string WrongAnswer)
        {
            if(B3 == "as" && B2 == "if" && _검색.단수주격대명사인지확인(B1) && C == "were")
            {
                WrongAnswer = "was";
                result = "[was / were]";
                return true;
            }

            if (B4 == "as" && B3 == "if" && _검색.명사구인지확인(B2, B1) && C == "were")
            {
                WrongAnswer = "was";
                result = "[was / were]";
                return true;
            }

            return false;
        }

        public static bool 어법문제후보표시_세부단계_가정법(string B4, string B3, string B2, string B1, string C, ref string 결과)
        {
            if (변환.문자열.문법문제표지제거(B3) == "as" && 변환.문자열.문법문제표지제거(B2) == "if" && _검색.단수주격대명사인지확인(변환.문자열.문법문제표지제거(B1)) && 변환.문자열.문법문제표지제거(C) == "were")
            {
                결과 = "{어법:≠was:}" + C;

                결과 = 결과.Replace("{어법:≠was:}{어법:≠was:}", "{어법:≠was:}");
                return true;
            }
            if (변환.문자열.문법문제표지제거(B4) == "as" && 변환.문자열.문법문제표지제거(B3) == "if" && _검색.명사구인지확인(변환.문자열.문법문제표지제거(B2), 변환.문자열.문법문제표지제거(B1)) && 변환.문자열.문법문제표지제거(C) == "were")
            {
                결과 = "{어법:≠was:}" + C;

                결과 = 결과.Replace("{어법:≠was:}{어법:≠was:}", "{어법:≠was:}");
                return true;
            }

            return false;
        }
        
        public static bool 어법문제출제_세부단계_사역동사(string B3, string B2, string B1, string C, ref string result, ref string WrongAnswer)
        {
            if(_검색.사역동사인지확인(B2) && _검색.목적격대명사인지확인(B1) && _검색.Ing형이있는원형동사인지(C))
            {
                WrongAnswer = string.Format("to {0}", 변환.문자열.문장부호제거(C));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(C), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }

            if(_검색.사역동사인지확인(B2) && _검색.명사인지확인(B1) && _검색.Ing형이있는원형동사인지(C))
            {
                WrongAnswer = string.Format("to {0}", 변환.문자열.문장부호제거(C));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(C), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }

            if(_검색.사역동사인지확인(B3) && _검색.명사구인지확인(B2, B1) && _검색.Ing형이있는원형동사인지(C))
            {
                WrongAnswer = string.Format("to {0}", 변환.문자열.문장부호제거(C));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(C), 변환.문자열.문장부호제거(C));

                result += C.Replace(변환.문자열.문장부호제거(C), "");
                return true;
            }

            return false;
        }
        public static bool 어법문제출제_세부단계_5형식To부정사(string B3, string B2, string B1, string C, string N1, ref string result, ref string WrongAnswer)
        {
            if(_검색.To부정사목적어로하는5형식동사인지확인(B2) && _검색.목적격대명사인지확인(B1) && C == "to" && _검색.Ing형이있는원형동사인지(N1))
            {
                WrongAnswer = _검색.원형을Ing로(변환.문자열.문장부호제거(N1));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(N1), _검색.원형을Ing로(변환.문자열.문장부호제거(N1)));

                result += N1.Replace(변환.문자열.문장부호제거(N1), "");
                return true;
            }

            if(_검색.To부정사목적어로하는5형식동사인지확인(B2) && _검색.명사인지확인(B1) && C == "to" && _검색.Ing형이있는원형동사인지(N1))
            {
                WrongAnswer = _검색.원형을Ing로(변환.문자열.문장부호제거(N1));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(N1), _검색.원형을Ing로(변환.문자열.문장부호제거(N1)));

                result += N1.Replace(변환.문자열.문장부호제거(N1), "");
                return true;
            }

            if(_검색.To부정사목적어로하는5형식동사인지확인(B3) && _검색.명사구인지확인(B2, B1) && C == "to" && _검색.Ing형이있는원형동사인지(N1))
            {
                WrongAnswer = _검색.원형을Ing로(변환.문자열.문장부호제거(N1));
                result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(N1), _검색.원형을Ing로(변환.문자열.문장부호제거(N1)));

                result += N1.Replace(변환.문자열.문장부호제거(N1), "");
                return true;
            }
            return false;
        }


        public static bool 어법문제출제_세부단계_Keep목적어FromIng와그냥Ing(string B2, string B1, string C, string 다음단어, ref int jump, ref string result, ref string WrongAnswer)
        {
            if(C == "from") // keep + 목적어 + from + ing형태인지 확인
            {
                if(_검색.Keep관련동사인지확인(B2) && _검색.목적격대명사인지확인(B1) && _검색.Ing형인지(변환.문자열.문장부호제거(다음단어)))
                {
                    jump = 1;
                    WrongAnswer = 변환.문자열.문장부호제거(다음단어);
                    result = string.Format("[from {0} / {1}]", WrongAnswer, WrongAnswer);

                    result += 다음단어.Replace(변환.문자열.문장부호제거(다음단어), ""); // 문장부호가 일반적으로 뒤에 있을 것으로 여기고 붙여줍니다.
                    return true;
                }
            }
            else
            {
                if(_검색.Keep관련동사인지확인(B2) && _검색.목적격대명사인지확인(B1) && _검색.Ing형인지(변환.문자열.문장부호제거(C)))
                {
                    WrongAnswer = string.Format("from {0}", 변환.문자열.문장부호제거(C));
                    result = string.Format("[from {0} / {1}]", 변환.문자열.문장부호제거(C), 변환.문자열.문장부호제거(C));

                    result += C.Replace(변환.문자열.문장부호제거(C), "");
                    return true;
                }
            }

            return false;
        }

        public static bool 어법문제출제_세부단계_동명사와to부정사의구분(string B1, string C, string 다음단어, ref int jump, ref string result, ref string WrongAnswer)
        {
            if (C == "to") // to 부정사일 가능성이 있다.
            {
                if (_검색.목적어를to부정사를쓰는동사인지확인(B1) && _검색.Ing형이있는원형동사인지(변환.문자열.문장부호제거(다음단어)))
                {
                    jump = 1;
                    WrongAnswer = _검색.원형을Ing로(변환.문자열.문장부호제거(다음단어));
                    result = string.Format("[to {0} / {1}]", 변환.문자열.문장부호제거(다음단어), WrongAnswer);

                    result += 다음단어.Replace(변환.문자열.문장부호제거(다음단어), ""); // 문장부호가 일반적으로 뒤에 있을 것으로 여기고 붙여줍니다.

                    return true;
                }
            }
            else
            {
                if (_검색.목적어를동명사를쓰는동사인지확인(B1) && _검색.Ing형인지(변환.문자열.문장부호제거(C)))
                {
                    WrongAnswer = string.Format("to {0}", _검색.Ing형을원형으로(변환.문자열.문장부호제거(C)));
                    result = string.Format("[{0} / {1}]", WrongAnswer, 변환.문자열.문장부호제거(C));

                    return true;
                }
            }

            return false;
        }

        public static bool 어법문제출제_세부단계_기타어법문제(string B2, string B1, string C, string N1, string N2, ref string result, ref string WrongAnswer, ref int jump)
        {
	        jump = 0;	// 기본은 점프하지 않는 것임

            // 문제로서의 가치는 있으나, 너무 없어 보임
			//					        if(C == "its")													{result = "[its / their]";							WrongAnswer = "their";						return true;}
			//					        if(C == "their")												{result = "[its / their]";							WrongAnswer = "its";						return true;}

	        if((B1 == "suitable")		&& (C == "for"))												{result = "[for / of]";								WrongAnswer = "of";							return true;}
	        if((B1 == "proper")			&& (C == "for"))												{result = "[for / of]";								WrongAnswer = "of";							return true;}
	        if((B1 == "easy")			&& (C == "for"))												{result = "[for / of]";								WrongAnswer = "of";							return true;}
	        if((B1 == "hard")			&& (C == "for"))												{result = "[for / of]";								WrongAnswer = "of";							return true;}
	        if((B1 == "possible")		&& (C == "for"))												{result = "[for / of]";								WrongAnswer = "of";							return true;}
	        if((B1 == "difficult")		&& (C == "for"))												{result = "[for / of]";								WrongAnswer = "of";							return true;}
		
	        if((B1 == "good")			&& (C == "of"))													{result = "[for / of]";								WrongAnswer = "for";						return true;}
	        if((B1 == "nice")			&& (C == "of"))													{result = "[for / of]";								WrongAnswer = "for";						return true;}
	        if((B1 == "kind")			&& (C == "of"))													{result = "[for / of]";								WrongAnswer = "for";						return true;}
	        if((B1 == "considerate")	&& (C == "of"))													{result = "[for / of]";								WrongAnswer = "for";						return true;}

	        if((B1 == "known")			&& (C == "to"))													{result = "[by / to]";								WrongAnswer = "by";							return true;}
	        if((B1 == "known")			&& (C == "as"))													{result = "[as / for]";								WrongAnswer = "for";							return true;}
	        if((B1 == "known")			&& (C == "for"))												{result = "[as / for]";								WrongAnswer = "as";							return true;}

	        if((B1 == "interested")		&& (C == "in"))													{result = "[by / in]";								WrongAnswer = "by";							return true;}
	        if((B1 == "surprised")		&& (C == "at"))													{result = "[at / by]";								WrongAnswer = "by";							return true;}
	        if((B1 == "satisfied")		&& (C == "with"))												{result = "[by / with]";							WrongAnswer = "by";							return true;}
	        if((B1 == "covered")		&& (C == "with"))												{result = "[by / with]";							WrongAnswer = "by";							return true;}
				
	        if((B1 == "doubt")			&& (C == "that"))												{result = "[if / that]";							WrongAnswer = "if";							return true;}
	        if((B1 == "doubt")			&& (C == "if"))													{result = "[if / that]";							WrongAnswer = "that";						return true;}
	
								        if(C == "trunks")												{result = "[trunk / trunks]";						WrongAnswer = "trunk";						return true;}

	        if((B1 == "such")			&& (C == "as"))													{result = "[as / that]";							WrongAnswer = "that";						return true;}
	        if((B1 == "such")			&& (C == "that"))												{result = "[as / that]";							WrongAnswer = "as";							return true;}
	
			if((B1 != "On") && (B1 != "on") && (C == "the")	&& (N1 == "other") && !N2.Contains("hand"))	{result = "[another / the other]";					WrongAnswer = "another";		jump = 1;	return true;}


			if((B2 != "On") && (B2 != "on") && (B1 != "the") && (C == "other") && !N1.Contains("hand"))	{result = "[another / other]";						WrongAnswer = "another";					return true;}
								        if(C == "another")												{result = "[another / other]";						WrongAnswer = "other";						return true;}



								        if((C == "such")	&& (N1 == "a"))								{result = "[a such / such a]";						WrongAnswer = "a such";			jump = 1;	return true;}

								        if((C == "may")		&& (N1 == "well"))							{result = "[may well / may as well]";				WrongAnswer = "may as well";	jump = 1;	return true;}
								        if((C == "may")		&& (N1 == "as")		&& (N2 == "well"))		{result = "[may well / may as well]";				WrongAnswer = "may well";		jump = 2;	return true;}
                                        if ((C == "used")   && (N1 == "to")     && _검색.Ing형이있는원형동사인지(N2)) { result = string.Format("[used to {0} / used to {1}]", N2, _검색.원형을Ing로(N2)); WrongAnswer = string.Format("used to {0}", _검색.원형을Ing로(N2)); jump = 2; return true; }
                                        if ((C == "used")   && (N1 == "to")     && _검색.Ing형인지(N2)) { result = string.Format("[used to {0} / used to {1}]", _검색.Ing형을원형으로(N2), N2); WrongAnswer = string.Format("used to {0}", _검색.Ing형을원형으로(N2)); jump = 2; return true; }

	        return false;
        }
        public static bool 어법문제출제_세부단계_전치사안쓰는타동사(string B2, string B1, string CurrentWord, string N1, ref string result, ref string WrongAnswer)
        {
	        string			sMark;
            List<string> VocaTable = new List<string>();


	        WrongAnswer = "";
	        result		= "";

	        if(     변환.문자열.Right(CurrentWord, 1) == ",")  {	CurrentWord = CurrentWord.Substring(0, CurrentWord.Length - 1);	sMark = ","; }
            else if (변환.문자열.Right(CurrentWord, 1) == ".") {    CurrentWord = CurrentWord.Substring(0, CurrentWord.Length - 1); sMark = "."; }
	        else							{	sMark = "";}


	        VocaTable.Add("marry,marry with");
	        VocaTable.Add("marries,marries with");
	        VocaTable.Add("married,married with");
	        VocaTable.Add("marrying,marrying with");

	        VocaTable.Add("mention,mention about");
	        VocaTable.Add("mentions,mentions about");
	        VocaTable.Add("mentioned,mentioned about");
	        VocaTable.Add("mentioning,mentioning about");

	        VocaTable.Add("discuss,discuss about");
	        VocaTable.Add("discusses,discusses about");
	        VocaTable.Add("discussed,discussed about");
	        VocaTable.Add("discussing,discussing about");

	        VocaTable.Add("resemble,resemble with");
	        VocaTable.Add("resembles,resembles with");
	        VocaTable.Add("resembled,resembled with");
	        VocaTable.Add("resembling,resembling with");

	        VocaTable.Add("inhabit,inhabit in");
	        VocaTable.Add("inhabits,inhabits in");
	        VocaTable.Add("inhabited,inhabited in");
	        VocaTable.Add("inhabiting,inhabiting in");
	        if((B2 != "out") && (B1 != "of"))
	        {
		        VocaTable.Add("reach,reach to");
		        VocaTable.Add("reaches,reaches to");
		        VocaTable.Add("reached,reached to");
		        VocaTable.Add("reaching,reaching to");
	        }

	        if(N1 != "to")
	        {
		        VocaTable.Add("approach,approach to");
		        VocaTable.Add("approaches,approaches to");
		        VocaTable.Add("approached,approached to");
		        VocaTable.Add("approaching,approaching to");
	        }

	        for(int i = 0 ;i < VocaTable.Count ; i++)
	        {
		        string s = VocaTable[i];

                string[] s배열 = s.Split(',');

		        if(CurrentWord == s배열[0]){ WrongAnswer = s배열[1]; }
	        }

	        if(WrongAnswer == ""){result = CurrentWord; result += sMark; return false;}
	        else
	        {
		        if(string.Compare(CurrentWord, WrongAnswer) > 0)
			        result = string.Format("[{0} / {1}]",WrongAnswer, CurrentWord);
		        else
			        result = string.Format("[{0} / {1}]",CurrentWord, WrongAnswer);
	        }
	        result += sMark;


	        return true;

        }

        public static bool 어법문제후보표시_세부단계_수동태안쓰는자동사(string B1, string 원래어절, string N1, ref string 결과)
        {
            if (B1.Contains("{어법:")) return false;
            if (B1.Contains("{어휘:")) return false;
            if (B1.Contains(":}")) return false;

            if (원래어절.Contains("{어법:")) return false;
            if (원래어절.Contains("{어휘:")) return false;
            if (원래어절.Contains(":}")) return false;


            B1 = B1.불필요제거();
            if (B1 == "the") { return false; } if (B1 == "a") { return false; }

            N1 = N1.불필요제거();

            List<string> 수동태안쓰는자동사목록 = new List<string>();

            수동태안쓰는자동사목록.Add("appears,is appeared"); 수동태안쓰는자동사목록.Add("appeared,was appeared"); 수동태안쓰는자동사목록.Add("appearing,appeared");
            수동태안쓰는자동사목록.Add("disappears,is disappeared"); 수동태안쓰는자동사목록.Add("disappeared,was disappeared"); 수동태안쓰는자동사목록.Add("disappearing,disappeared");
            수동태안쓰는자동사목록.Add("consists,is consisted"); 수동태안쓰는자동사목록.Add("consisted,was consisted"); 수동태안쓰는자동사목록.Add("consisting,consisted");
            수동태안쓰는자동사목록.Add("remains,is remained"); 수동태안쓰는자동사목록.Add("remained,was remained"); 수동태안쓰는자동사목록.Add("remaining,remained");
            수동태안쓰는자동사목록.Add("seems,is seemed"); 수동태안쓰는자동사목록.Add("seemed,was seemed"); 수동태안쓰는자동사목록.Add("seeming,seemed");

            string 불필요문자와문법표지제거한어절 = 원래어절.불필요제거();
            불필요문자와문법표지제거한어절 = 불필요문자와문법표지제거한어절.ToLower();

            구문자동분석 품사 = new 구문자동분석();

            if (품사.조동사(B1) && (불필요문자와문법표지제거한어절 == "result") && ((N1 == "in") || (N1 == "from"))) { 결과 = "{어법:≠be resulted:}" + 원래어절; return true; }
            else if ((불필요문자와문법표지제거한어절 == "result") && ((N1 == "in") || (N1 == "from"))) { 결과 = "{어법:≠is resulted:}" + 원래어절; return true; }
            else if ((불필요문자와문법표지제거한어절 == "results") && ((N1 == "in") || (N1 == "from"))) { 결과 = "{어법:≠is resulted:}" + 원래어절; return true; }
            else if ((불필요문자와문법표지제거한어절 == "resulted") && ((N1 == "in") || (N1 == "from"))) { 결과 = "{어법:≠was resulted:}" + 원래어절; return true;}



            if (품사.조동사(B1) && 불필요문자와문법표지제거한어절 == "appear") { 결과 = "{어법:≠be appeared:}" + 원래어절; return true; }
            else if (불필요문자와문법표지제거한어절 == "appear") { 결과 = "{어법:≠is appeared:}" + 원래어절; return true; }

            if (품사.조동사(B1) && 불필요문자와문법표지제거한어절 == "disappear") { 결과 = "{어법:≠be disappeared:}" + 원래어절; return true; }
            else if (불필요문자와문법표지제거한어절 == "disappear") { 결과 = "{어법:≠is disappeared:}" + 원래어절; return true; }

            if (품사.조동사(B1) && 불필요문자와문법표지제거한어절 == "consist") { 결과 = "{어법:≠be consisted:}" + 원래어절; return true; }
            else if (불필요문자와문법표지제거한어절 == "consist") { 결과 = "{어법:≠is consisted:}" + 원래어절; return true; }

            if (품사.조동사(B1) && 불필요문자와문법표지제거한어절 == "remain") { 결과 = "{어법:≠be remained:}" + 원래어절; return true; }
            else if (불필요문자와문법표지제거한어절 == "remain") { 결과 = "{어법:≠is remained:}" + 원래어절; return true; }

            if (품사.조동사(B1) && 불필요문자와문법표지제거한어절 == "seem") { 결과 = "{어법:≠be seemed:}" + 원래어절; return true; }
            else if (불필요문자와문법표지제거한어절 == "seem") { 결과 = "{어법:≠is seemed:}" + 원래어절; return true; }

            for (int i = 0; i < 수동태안쓰는자동사목록.Count; i++)
            {
                string s = 수동태안쓰는자동사목록[i];

                string[] s배열 = s.Split(',');

                if (불필요문자와문법표지제거한어절 == s배열[0])            { 결과 = "{어법:≠" + s배열[1] + ":}" + 원래어절; return true; }
            }


            return false;

        }

        public static bool 어법문제출제_세부단계_수동태안쓰는자동사(string B1,	string 현재어절, ref string result, ref string WrongAnswer)
        {
	        if(B1 == "the")	{	result = 현재어절; return false;}      if(B1 == "a")	{	result = 현재어절; return false;}

	        string			sMark;
            List<string> 수동태안쓰는자동사목록 = new List<string>();

	        WrongAnswer = "";
	        result		= "";

            if (변환.문자열.Right(현재어절, 1) == ",") { 현재어절 = 현재어절.Substring(0, 현재어절.Length - 1); sMark = ","; }
            else if (변환.문자열.Right(현재어절, 1) == ".") { 현재어절 = 현재어절.Substring(0, 현재어절.Length - 1); sMark = "."; }
            else { sMark = ""; }

	        수동태안쓰는자동사목록.Add("results,is resulted");	        수동태안쓰는자동사목록.Add("resulted,was resulted");
	        수동태안쓰는자동사목록.Add("appears,is appeared");	        수동태안쓰는자동사목록.Add("appeared,was appeared");	        수동태안쓰는자동사목록.Add("appearing,appeared");
	        수동태안쓰는자동사목록.Add("disappears,is disappeared");     수동태안쓰는자동사목록.Add("disappeared,was disappeared");  수동태안쓰는자동사목록.Add("disappearing,disappeared");
	        수동태안쓰는자동사목록.Add("consists,is consisted");	        수동태안쓰는자동사목록.Add("consisted,was consisted");	        수동태안쓰는자동사목록.Add("consisting,consisted");
	        수동태안쓰는자동사목록.Add("remains,is remained");	        수동태안쓰는자동사목록.Add("remained,was remained");	        수동태안쓰는자동사목록.Add("remaining,remained");
	        수동태안쓰는자동사목록.Add("seems,is seemed");	        수동태안쓰는자동사목록.Add("seemed,was seemed");	        수동태안쓰는자동사목록.Add("seeming,seemed");

            구문자동분석 품사 = new 구문자동분석();

            if (품사.조동사(B1) && 현재어절 == "result") { WrongAnswer = "be resulted"; } else if (현재어절 == "result") { WrongAnswer = "is resulted"; }
            if (품사.조동사(B1) && 현재어절 == "appear") { WrongAnswer = "be appeared"; } else if (현재어절 == "appear") { WrongAnswer = "is appeared"; }
            if (품사.조동사(B1) && 현재어절 == "disappear") { WrongAnswer = "be disappeared"; } else if (현재어절 == "disappear") { WrongAnswer = "is disappeared"; }
            if (품사.조동사(B1) && 현재어절 == "consist") { WrongAnswer = "be consisted"; } else if (현재어절 == "consist") { WrongAnswer = "is consisted"; }
            if (품사.조동사(B1) && 현재어절 == "remain") { WrongAnswer = "be remained"; } else if (현재어절 == "remain") { WrongAnswer = "is remained"; }
            if (품사.조동사(B1) && 현재어절 == "seem") { WrongAnswer = "be seemed"; } else if (현재어절 == "seem") { WrongAnswer = "is seemed"; }


            for (int i = 0; i < 수동태안쓰는자동사목록.Count; i++)
            {
                string s = 수동태안쓰는자동사목록[i];

                string[] s배열 = s.Split(',');

                if (현재어절 == s배열[0]) { WrongAnswer = s배열[1]; }
            }

            if (WrongAnswer == "") { result = 현재어절; result += sMark; return false; }
            else
            {
                if (string.Compare(현재어절, WrongAnswer) > 0)                    result = string.Format("[{0} / {1}]", WrongAnswer, 현재어절);
                else                                                             result = string.Format("[{0} / {1}]", 현재어절, WrongAnswer);
            }
            result += sMark;


            return true;
        }
        public static bool 어법문제출제_세부단계_4형식으로안쓰는3형식동사(string CurrentWord, string NextWord, ref string result, ref string WrongAnswer)
        {
	        if((CurrentWord == "say") && (NextWord == "to"))				{result = "[say / say to]";					WrongAnswer = "say";	return true;}
	        if((CurrentWord == "says") && (NextWord == "to"))				{result = "[says / says to]";				WrongAnswer = "says";	return true;}
	        if((CurrentWord == "said") && (NextWord == "to"))				{result = "[said / said to]";				WrongAnswer = "said";	return true;}

	        if((CurrentWord == "explain") && (NextWord == "to"))			{result = "[explain / explain to]";			WrongAnswer = "explain";	return true;}
	        if((CurrentWord == "explains") && (NextWord == "to"))			{result = "[explains / explains to]";		WrongAnswer = "explains";	return true;}
	        if((CurrentWord == "explained") && (NextWord == "to"))			{result = "[explained / explained to]";		WrongAnswer = "explained";	return true;}
	        if((CurrentWord == "explaining") && (NextWord == "to"))			{result = "[explaining / explaining to]";	WrongAnswer = "explaining";	return true;}

	        if((CurrentWord == "suggest") && (NextWord == "to"))			{result = "[suggest / suggest to]";			WrongAnswer = "suggest";	return true;}
	        if((CurrentWord == "suggests") && (NextWord == "to"))			{result = "[suggests / suggests to]";		WrongAnswer = "suggests";	return true;}
	        if((CurrentWord == "suggested") && (NextWord == "to"))			{result = "[suggested / suggested to]";		WrongAnswer = "suggested";	return true;}
	        if((CurrentWord == "suggesting") && (NextWord == "to"))			{result = "[suggesting / suggesting to]";	WrongAnswer = "suggesting";	return true;}

	        if((CurrentWord == "describe") && (NextWord == "to"))			{result = "[describe / describe to]";		WrongAnswer = "describe";	return true;}
	        if((CurrentWord == "describes") && (NextWord == "to"))			{result = "[describes / describes to]";		WrongAnswer = "describes";	return true;}
	        if((CurrentWord == "described") && (NextWord == "to"))			{result = "[described / described to]";		WrongAnswer = "described";	return true;}
	        if((CurrentWord == "describing") && (NextWord == "to"))			{result = "[describing / describing to]";	WrongAnswer = "describing";	return true;}

	        return false;
        }
        public static bool 어법문제출제_세부단계_1형식동사의전치사확인(string CurrentWord, string NextWord, ref string result, ref string WrongAnswer)
        {
	        WrongAnswer = "";
	        result		= "";


	        if((CurrentWord == "crash") && (NextWord == "into"))			{result = "[crash / crash into]";				WrongAnswer = "crash"; return true;}
	        if((CurrentWord == "crashes") && (NextWord == "into"))			{result = "[crashes / crashes into]";			WrongAnswer = "crashes"; return true;}
	        if((CurrentWord == "crashed") && (NextWord == "into"))			{result = "[crashed / crashed into]";			WrongAnswer = "crashed"; return true;}
	        if((CurrentWord == "crashing") && (NextWord == "into"))			{result = "[crashing / crashing into]";			WrongAnswer = "crashing"; return true;}

	        if((CurrentWord == "object") && (NextWord == "to"))				{result = "[object / object to]";				WrongAnswer = "object"; return true;}
	        if((CurrentWord == "objects") && (NextWord == "to"))			{result = "[objects / objects to]";				WrongAnswer = "objects"; return true;}
	        if((CurrentWord == "objected") && (NextWord == "to"))			{result = "[objected / objected to]";			WrongAnswer = "objected"; return true;}
	        if((CurrentWord == "objecting") && (NextWord == "to"))			{result = "[objecting / objecting to]";			WrongAnswer = "objecting"; return true;}

	        if((CurrentWord == "interfere") && (NextWord == "with"))		{result = "[interfere / interfere with]";		WrongAnswer = "interfere"; return true;}
	        if((CurrentWord == "interferes") && (NextWord == "with"))		{result = "[interferes / interferes with]";		WrongAnswer = "interferes"; return true;}
	        if((CurrentWord == "interfered") && (NextWord == "with"))		{result = "[interfered / interfered with]";		WrongAnswer = "interfered"; return true;}
	        if((CurrentWord == "interfering") && (NextWord == "with"))		{result = "[interfering / interfering with]";	WrongAnswer = "interfering"; return true;}

	        if((CurrentWord == "account") && (NextWord == "for"))			{result = "[account / account for]";			WrongAnswer = "account"; return true;}
	        if((CurrentWord == "accounts") && (NextWord == "for"))			{result = "[accounts / accounts for]";			WrongAnswer = "accounts"; return true;}
	        if((CurrentWord == "accounted") && (NextWord == "for"))			{result = "[accounted / accounted for]";		WrongAnswer = "accounted"; return true;}
	        if((CurrentWord == "accounting") && (NextWord == "for"))		{result = "[accounting / accounting for]";		WrongAnswer = "accounting"; return true;}

	        if((CurrentWord == "live") && (NextWord == "in"))				{result = "[live / live in]";					WrongAnswer = "live"; return true;}
	        if((CurrentWord == "lives") && (NextWord == "in"))				{result = "[lives / lives in]";					WrongAnswer = "lives"; return true;}
	        if((CurrentWord == "lived") && (NextWord == "in"))				{result = "[lived / lived in]";					WrongAnswer = "lived"; return true;}
	        if((CurrentWord == "living") && (NextWord == "in"))				{result = "[living / living in]";				WrongAnswer = "living"; return true;}

	        return false;
        }
        public static bool 어법문제출제_세부단계_조동사의과거형(string CurrentWord, string NextWord, string 다다음단어, ref string result, ref string WrongAnswer)
        {
            CurrentWord = CurrentWord.ToLower();
            NextWord = NextWord.ToLower();

	        WrongAnswer = "";
	        result		= "";

	        if((CurrentWord == "could")	 && (NextWord == "have") && _검색.Ed형인지(다다음단어))	{result = "[could / should]";WrongAnswer = "should";	return true;}
            if ((CurrentWord == "would") && (NextWord == "have") && _검색.Ed형인지(다다음단어)) { result = "[must / would]"; WrongAnswer = "must"; return true; }
            if ((CurrentWord == "should")&& (NextWord == "have") && _검색.Ed형인지(다다음단어)) { result = "[might / should]"; WrongAnswer = "might"; return true; }
            if ((CurrentWord == "must")  && (NextWord == "have") && _검색.Ed형인지(다다음단어)) { result = "[must / should]"; WrongAnswer = "should"; return true; }
            if ((CurrentWord == "might") && (NextWord == "have") && _검색.Ed형인지(다다음단어)) { result = "[might / should]"; WrongAnswer = "should"; return true; }


	        return false;
        }
        public static bool 어법문제출제_세부단계_구와절구분(string CurrentWord, ref string result, ref string WrongAnswer)
        {
	        if(CurrentWord == "while")			{result = "[while / during]";			WrongAnswer = "during";		return true;}
	        if(CurrentWord == "during")			{result = "[while / during]";			WrongAnswer = "while";		return true;}

	        if(CurrentWord == "although")		{result = "[although / despite]";		WrongAnswer = "despite";	return true;}
	        if(CurrentWord == "though")			{result = "[though / despite]";			WrongAnswer = "despite";		return true;}
	        if(CurrentWord == "despite")		{result = "[although / despite]";		WrongAnswer = "although";	return true;}

	        if(CurrentWord == "While")			{result = "[While / During]";			WrongAnswer = "During";		return true;}
	        if(CurrentWord == "During")			{result = "[While / During]";			WrongAnswer = "While";		return true;}

	        if(CurrentWord == "Although")		{result = "[Although / Despite]";		WrongAnswer = "Despite";	return true;}
	        if(CurrentWord == "Though")			{result = "[Though / Despite]";			WrongAnswer = "Despite";		return true;}
	        if(CurrentWord == "Despite")		{result = "[Although / Despite]";		WrongAnswer = "Although";	return true;}


	        return false;
        }
        public static bool 어법문제출제_세부단계_형용사부사구분(string CurrentWord, string 다음단어, ref string result, ref string WrongAnswer)
        {
            // 만약 다음단어가 명사라면 괜히 형용사 부사 구분하는 문제는 내지 않도록 하자.
            if (_검색.명사인지확인(변환.문자열.문장부호제거(다음단어))){ result = CurrentWord; return false; }

            string sMark;
            List<string> VocaTable = new List<string>();

            WrongAnswer = "";
            result = "";

            if (변환.문자열.Right(CurrentWord, 1) == ",") { CurrentWord = CurrentWord.Substring(0, CurrentWord.Length - 1); sMark = ","; }
            else if (변환.문자열.Right(CurrentWord, 1) == ".") { CurrentWord = CurrentWord.Substring(0, CurrentWord.Length - 1); sMark = "."; }
            else { sMark = ""; }

            변환.Ansi파일.문자열들로(_문제DB루트폴더 + "형용사_부사.txt", ref VocaTable);

            for (int i = 0; i < VocaTable.Count; i++)
            {
                string s = VocaTable[i];

                string[] s배열 = s.Split(',');

                if (CurrentWord == s배열[0]) { WrongAnswer = s배열[1]; }
                if (CurrentWord == s배열[1]) { WrongAnswer = s배열[0]; }

            }

            if (WrongAnswer == "") { result = CurrentWord; result += sMark; return false; }
            else
            {
                if (string.Compare(CurrentWord, WrongAnswer) > 0)
                    result = string.Format("[{0} / {1}]", WrongAnswer, CurrentWord);
                else
                    result = string.Format("[{0} / {1}]", CurrentWord, WrongAnswer);
            }
            result += sMark;


            return true;
        }


        public static bool 어법문제후보표시_세부단계_과거분사현재분사구분(string B1, string 원래어절, ref string 결과)
        {
            if (B1.Contains("{어법:")) return false;
            if (B1.Contains("{어휘:")) return false;
            if (B1.Contains(":}")) return false;

            if (원래어절.Contains("{어법:")) return false;
            if (원래어절.Contains("{어휘:")) return false;
            if (원래어절.Contains(":}")) return false;

            B1 = B1.불필요제거();

            if (B1 == "have") { return false; }    // 현재완료일때 뒤에 pp오는지 ing 오는지는 인간적으로 물어보지 말자.
            if (B1 == "has") { return false; }     // 여러가지 의미로 교육 효과가 없다.
            if (B1 == "had") { return false; }

            string 불필요문자와문법표지제거한어절 = 원래어절.불필요제거();
            불필요문자와문법표지제거한어절 = 불필요문자와문법표지제거한어절.ToLower();

            List<string> Ed_Ing표 = new List<string>();


            string Ed_Ing반대형태 = "";


            변환.Ansi파일.문자열들로(_문제DB루트폴더 + "Ed_Ing.txt", ref Ed_Ing표);

            for (int i = 0; i < Ed_Ing표.Count; i++)
            {
                string s = Ed_Ing표[i];

                string[] s배열 = s.Split(',');

                if (불필요문자와문법표지제거한어절 == s배열[0]) { Ed_Ing반대형태 = s배열[1]; }
                if (불필요문자와문법표지제거한어절 == s배열[1]) { Ed_Ing반대형태 = s배열[0]; }

            }

            if (Ed_Ing반대형태 == "") { return false;}
            else
            {
                결과 = "{어법:≠" + Ed_Ing반대형태 + ":}" + 원래어절;
                return true;
            }
        }

        public static bool 어법문제출제_세부단계_is와are의구분(string B1, string C, ref string result, ref string WrongAnswer)
        {
            if (B1.ToLower() == "what") return false;
            if (B1.ToLower() == "where") return false;
            if (B1.ToLower() == "which") return false;
            if (B1.ToLower() == "that") return false;
            if (B1.ToLower() == "who") return false;

            구문자동분석 구문분석용 = new 구문자동분석();

            if (B1 == "I" && C == "are") { result = "[am / are]"; WrongAnswer = "am"; return true; }

            if (!구문분석용.복수형명사가능성(B1) && C == "are") { result = "[is / are]"; WrongAnswer = "is"; return true; }
            if (구문분석용.복수형명사가능성(B1) && C == "is") { result = "[is / are]"; WrongAnswer = "are"; return true; }

            if (!구문분석용.복수형명사가능성(B1) && C == "were") { result = "[was / were]"; WrongAnswer = "was"; return true; }
            if (구문분석용.복수형명사가능성(B1) && C == "was") { result = "[was / were]"; WrongAnswer = "were"; return true; }

            return false;
        }

		//else if (어법문제출제_세부단계_similarToWith(C, N1, ref result, ref WrongAnswer)) { jump = 1; 출제가능성 = true; }		// similar가 with는 안됨!!
		public static bool 어법문제출제_세부단계_similarToWith(string B1, string C, ref string result, ref string WrongAnswer)
		{
			if (B1.ToLower() == "similar" && C == "to")
			{
				result = "[to / with]"; WrongAnswer = "with";

				return true;
			}
			else
				return false;
		}



		public static bool 어법문제출제_세부단계_과거분사현재분사구분(string B1, string C, ref string result, ref string Ed_Ing반대형태)
        {
            result = "";
            
            if(B1 == "have") {result = C; return false;}    // 현재완료일때 뒤에 pp오는지 ing 오는지는 인간적으로 물어보지 말자.
            if(B1 == "has") {result = C; return false;}     // 여러가지 의미로 교육 효과가 없다.
            if(B1 == "had") {result = C; return false;}     

            string 마침표_쉼표;
            List<string> Ed_Ing표 = new List<string>();

            Ed_Ing반대형태 = "";

            if (변환.문자열.Right(C, 1) == ",") { C = C.Substring(0, C.Length - 1); 마침표_쉼표 = ","; }
            else if (변환.문자열.Right(C, 1) == ".") { C = C.Substring(0, C.Length - 1); 마침표_쉼표 = "."; }
            else { 마침표_쉼표 = ""; }

            변환.Ansi파일.문자열들로(_문제DB루트폴더 + "Ed_Ing.txt", ref Ed_Ing표);

            for (int i = 0; i < Ed_Ing표.Count; i++)
            {
                string s = Ed_Ing표[i];

                string[] s배열 = s.Split(',');

                if (C == s배열[0]) { Ed_Ing반대형태 = s배열[1]; }
                if (C == s배열[1]) { Ed_Ing반대형태 = s배열[0]; }

            }

            if (Ed_Ing반대형태 == "") { result = C; result += 마침표_쉼표; return false; }
            else
            {
                if (string.Compare(C, Ed_Ing반대형태) > 0)
                    result = string.Format("[{0} / {1}]", Ed_Ing반대형태, C);
                else
                    result = string.Format("[{0} / {1}]", C, Ed_Ing반대형태);
            }
            result += 마침표_쉼표;


            return true;
        }

		public static bool 어법문제후보표시_세부단계_to_동명사(string B1, string 원래어절, ref string 결과)
		{
			string C = 원래어절.불필요제거();

			B1 = B1.불필요제거();

			if (B1 != "to") return false;

			if(_검색.Ing형인지(C)) 	{ 결과 = "{중요}" + 원래어절; return true; }

			return false;
		}

		public static bool 어법문제후보표시_세부단계_is와are의구분(string B1, string 원래어절, ref string 결과)
        {
            if (원래어절.Contains("{어법:")) return false;
            if (원래어절.Contains("{어휘:")) return false;
            if (원래어절.Contains(":}")) return false;

            string C = 원래어절.불필요제거();

            B1 = B1.불필요제거();

            if (B1.ToLower() == "what") return false;
            if (B1.ToLower() == "where") return false;
            if (B1.ToLower() == "which") return false;
            if (B1.ToLower() == "that") return false;
            if (B1.ToLower() == "who") return false;
			if (B1.ToLower() == "there") return false;
			if (B1.ToLower() == "here") return false;

			구문자동분석 구문분석용 = new 구문자동분석();

            if (B1 == "I" && C == "are") { 결과 = "{중요}{어법:≠am:}" + 원래어절; return true; }

            if (!구문분석용.복수형명사가능성(B1) && C == "are") { 결과 = "{중요}{어법:≠is:}" + 원래어절; return true; }
            if (구문분석용.복수형명사가능성(B1) && C == "is") { 결과 = "{중요}{어법:≠are:}" + 원래어절; return true; }

            if (!구문분석용.복수형명사가능성(B1) && C == "were") { 결과 = "{중요}{어법:≠was:}" + 원래어절; return true; }
            if (구문분석용.복수형명사가능성(B1) && C == "was") { 결과 = "{중요}{어법:≠were:}" + 원래어절; return true; }

            return false;
        }

        public static bool 어법문제후보표시_세부단계_관계사찾기(string B1, string 원래어절, string N1, ref string 결과)
        {
            if (원래어절.Contains("{어법:")) return false;
            if (원래어절.Contains("{어휘:")) return false;
            if (원래어절.Contains(":}")) return false;

            string 불필요문자와문법표지제거한어절 = 원래어절.불필요제거();
			N1 = N1.불필요제거();

            if (불필요문자와문법표지제거한어절 == "where") { 결과 = "{어법:≠which:}" + 원래어절; return true; }
            if (불필요문자와문법표지제거한어절 == "which") { 결과 = "{어법:≠what:}" + 원래어절; return true; }

			if (불필요문자와문법표지제거한어절 == "that" && 
				((N1.ToLower() != "week") || (N1.ToLower() != "month") || (N1.ToLower() != "year") || (N1.ToLower() != "boy") || (N1.ToLower() != "girl") || (N1.ToLower() != "lady") || (N1.ToLower() != "dog") || (N1.ToLower() != "cat"))
				) { 결과 = "{어법:≠what:}" + 원래어절; return true; }

            if (불필요문자와문법표지제거한어절 == "what") { 결과 = "{어법:≠that:}" + 원래어절; return true; }
            if (불필요문자와문법표지제거한어절 == "who") { 결과 = "{어법:≠which:}" + 원래어절; return true; }

            return false;
        }

        public static bool 어법문제출제_세부단계_관계사찾기(string CurrentWord, ref string result, ref string WrongAnswer)
        {
            if (CurrentWord == "where") { result = "[which / where]"; WrongAnswer = "which"; return true; }
            if (CurrentWord == "which")	{result = "[which / what]"; WrongAnswer = "what"; return true;}
	        if(CurrentWord == "that")	{result = "[that / what]"; WrongAnswer = "what"; return true;}
	        if(CurrentWord == "what")	{result = "[that / what]"; WrongAnswer = "that"; return true;}
	        if(CurrentWord == "who")	{result = "[which / who]"; WrongAnswer = "which"; return true;}

	        return false;
        }
        public static string 어법문제출제_2단계_XML형식문제출제(ref List<string> 지문의_단어들, string 해석, int a, int b, int c)
        {
            _어법_이미출제한것들.Clear();

	        int 건너뛸단어갯수 = 0;


			List<string> 단어배열형태의_처리결과 = new List<string>();

	        string			Res = "", WrongAnswer = "";

	        string			B9, B8, B7, B6, B5, B4, B3, B2, B1;	// ? word before
	        string			C;	// current word
	        string			N1, N2, N3; // ? word next

	        string			A_Right = "",A_Wrong = "",B_Right = "",B_Wrong = "",C_Right = "",C_Wrong = "";

	        int nCreatedQuestion = 0;


	        for(int i = 0 ; i < 지문의_단어들.Count ;i++)
	        {
		        if(i > 8)						B9		= 지문의_단어들[i-9];		else			B9		= "";
		        if(i > 7)						B8		= 지문의_단어들[i-8];		else			B8		= "";
		        if(i > 6)						B7		= 지문의_단어들[i-7];		else			B7		= "";
		        if(i > 5)						B6		= 지문의_단어들[i-6];		else			B6		= "";
		        if(i > 4)						B5		= 지문의_단어들[i-5];		else			B5		= "";
		        if(i > 3)						B4		= 지문의_단어들[i-4];		else			B4		= "";

		        if(i > 2)						B3		= 지문의_단어들[i-3];		else			B3		= "";
		        if(i > 1)						B2		= 지문의_단어들[i-2];		else			B2		= "";
		        if(i > 0)						B1		= 지문의_단어들[i-1];		else			B1		= "";
											    C		= 지문의_단어들[i];
		        if(i < 지문의_단어들.Count - 1)	N1		= 지문의_단어들[i+1];		else			N1		= "";
		        if(i < 지문의_단어들.Count - 2)	N2		= 지문의_단어들[i+2];		else			N2		= "";
		        if(i < 지문의_단어들.Count - 3)	N3		= 지문의_단어들[i+3];		else			N3		= "";
		

				// 건너뛸단어갯수라는 것은 예컨데, should have pp가 정답이라고 하면, 이것을 [should have pp / might have pp]와 같은 식으로 출제를 할텐데,
				// 문제를 출제하고 나면, should have pp가 모두 3단어니까, 그만큼을 띄어둔 다음 처리를 하라는 뜻입니다.

		        if(어법문제출제_1단계_단어별_정답오답산출(B9,B8,B7,B6,B5,B4,B3,B2,B1,C,N1,N2,N3, ref 건너뛸단어갯수, ref Res, ref WrongAnswer))
		        {
			        if(nCreatedQuestion == a)
			        {
                        단어배열형태의_처리결과.Add(string.Format("(A) {0}", Res)); 

				        if(			건너뛸단어갯수 == 0)	A_Right = C;
				        else if(	건너뛸단어갯수 == 1) 	A_Right = string.Format("{0} {1}",			C, N1);
				        else if(	건너뛸단어갯수 == 2) 	A_Right = string.Format("{0} {1} {2}",		C, N1, N2);
				        else if(	건너뛸단어갯수 == 3) 	A_Right = string.Format("{0} {1} {2} {3}",	C, N1, N2, N3);


				        A_Wrong = WrongAnswer;
			        }
			        else if(nCreatedQuestion == b)
			        {
                        단어배열형태의_처리결과.Add(string.Format("(B) {0}", Res));

				        if(			건너뛸단어갯수 == 0)	B_Right = C;
                        else if (건너뛸단어갯수 == 1)       B_Right = string.Format("{0} {1}", C, N1);
                        else if (건너뛸단어갯수 == 2)       B_Right = string.Format("{0} {1} {2}", C, N1, N2);
                        else if (건너뛸단어갯수 == 3)       B_Right = string.Format("{0} {1} {2} {3}", C, N1, N2, N3);

				        B_Wrong = WrongAnswer;
                    }
			        else if(nCreatedQuestion == c)
			        {
                        단어배열형태의_처리결과.Add(string.Format("(C) {0}", Res));

				        if(		 건너뛸단어갯수 == 0)	    C_Right = C;
                        else if (건너뛸단어갯수 == 1)       C_Right = string.Format("{0} {1}", C, N1);
                        else if (건너뛸단어갯수 == 2)       C_Right = string.Format("{0} {1} {2}", C, N1, N2);
                        else if (건너뛸단어갯수 == 3)       C_Right = string.Format("{0} {1} {2} {3}", C, N1, N2, N3);
				
				        C_Wrong = WrongAnswer;
			        }
			        else
			        {

				        if(		 건너뛸단어갯수 == 0)	    단어배열형태의_처리결과.Add(C);
                        else if (건너뛸단어갯수 == 1)       단어배열형태의_처리결과.Add(string.Format("{0} {1}", C, N1));
                        else if (건너뛸단어갯수 == 2)       단어배열형태의_처리결과.Add(string.Format("{0} {1} {2}", C, N1, N2));
                        else if (건너뛸단어갯수 == 3)       단어배열형태의_처리결과.Add(string.Format("{0} {1} {2} {3}", C, N1, N2, N3));

			        }

                    i += 건너뛸단어갯수;
			        nCreatedQuestion++;
		        }
		        else
			        단어배열형태의_처리결과.Add(Res);
	        }

            string result = "";
	        // 선택지를 만든다.
	        result += 어법문제출제_2단계_XML형식문제출제_문제와지문부분(단어배열형태의_처리결과);
	        result += 어법문제출제_2단계_XML형식문제출제_보기부분(해석, A_Right,A_Wrong,B_Right,B_Wrong,C_Right,C_Wrong);

	        return result;
        }


        public static string 어법문제출제_2단계_XML형식문제출제(string 지문, string 해석, int 출제가능숫자)
        {
            string result = "<CAKE>\r";
            string 정답 = "정답 : ";

            if(출제가능숫자 == 1)
                result += "\t<Q> " + _현재번호 + ". 밑줄 친 부분을 어법에 알맞게 고치시오. </Q>\r";
            else
                result += "\t<Q> " + _현재번호 + ". 밑줄 친 두 부분을 어법에 알맞게 고치시오. </Q>\r";


            result += "\t<T>\r";
            result += "\t";


            _어법_이미출제한것들.Clear();

            int 건너뛸단어갯수 = 0;

            List<string> 지문의_단어들 = new List<string>();

            string Res = "", WrongAnswer = "";

            string B9;	// 9 word before
            string B8;	// 8 word before
            string B7;	// 7 word before
            string B6;	// 6 word before
            string B5;	// 5 word before
            string B4;	// 4 word before

            string B3;	// 3 word before
            string B2; // 2 word before
            string B1;	// 1 word before
            string C;	// current word
            string N1; // 1 word next
            string N2; // 2 word next
            string N3; // 3 word next


            변환.문자열.탭과개행문자를살린어절들로(지문, ref 지문의_단어들);

            for (int i = 0; i < 지문의_단어들.Count; i++)
            {
                if (i > 8) B9 = 지문의_단어들[i - 9]; else B9 = "";
                if (i > 7) B8 = 지문의_단어들[i - 8]; else B8 = "";
                if (i > 6) B7 = 지문의_단어들[i - 7]; else B7 = "";
                if (i > 5) B6 = 지문의_단어들[i - 6]; else B6 = "";
                if (i > 4) B5 = 지문의_단어들[i - 5]; else B5 = "";
                if (i > 3) B4 = 지문의_단어들[i - 4]; else B4 = "";

                if (i > 2) B3 = 지문의_단어들[i - 3]; else B3 = "";
                if (i > 1) B2 = 지문의_단어들[i - 2]; else B2 = "";
                if (i > 0) B1 = 지문의_단어들[i - 1]; else B1 = "";
                C = 지문의_단어들[i];
                if (i < 지문의_단어들.Count - 1) N1 = 지문의_단어들[i + 1]; else N1 = "";
                if (i < 지문의_단어들.Count - 2) N2 = 지문의_단어들[i + 2]; else N2 = "";
                if (i < 지문의_단어들.Count - 3) N3 = 지문의_단어들[i + 3]; else N3 = "";



                if (어법문제출제_1단계_단어별_정답오답산출(B9, B8, B7, B6, B5, B4, B3, B2, B1, C, N1, N2, N3, ref 건너뛸단어갯수, ref Res, ref WrongAnswer))
                {
                    result += " [" + WrongAnswer + "]" + 변환.문자열.오른쪽불필요문자(C);
                    if (정답 == "정답 : ")
                        정답 += 변환.문자열.불필요문자제거(C);
                    else
                        정답 += ", " + 변환.문자열.불필요문자제거(C);
                }
                else
                {
                    result += " " + C;
                }

            }
            result += "\r";
            result += "\t<TBAR></TBAR>\r";
            result += "\t" + 해석 + "\r";

            result += "\t</T>\r";
            result += "\t<정답>\r";
            result += "\t" + 정답 + "\r";
            result += "\t</정답>\r";
            result += "</CAKE>\r";



            _현재번호++;


            return result;
        }
        public static string 어법문제출제_2단계_XML형식문제출제_문제와지문부분(List<string> 단어배열형태의_처리결과)
        {
	        string sRes = "<CAKE>\r";
            sRes += "\t<Q> " + _현재번호 + ". 네모 안에서 어법에 알맞는 표현을 고르시오. </Q>\r";
	        sRes += "\t<T>\r";
            sRes += "\t" + 변환.문자열들.단락으로(단어배열형태의_처리결과) + "\r";
	        sRes += "\t</T>\r";

            _현재번호++;
	        return sRes;
        }
        public static string 어법문제출제_2단계_XML형식문제출제_보기부분(string 해석, string A_Right, string A_Wrong, string B_Right, string B_Wrong, string C_Right, string C_Wrong)
        {
	        string s = "";

            A_Right = 변환.문자열.문장부호제거(A_Right);            A_Wrong = 변환.문자열.문장부호제거(A_Wrong);
            B_Right = 변환.문자열.문장부호제거(B_Right);            B_Wrong = 변환.문자열.문장부호제거(B_Wrong);
            C_Right = 변환.문자열.문장부호제거(C_Right);            C_Wrong = 변환.문자열.문장부호제거(C_Wrong);

			if (A_Right.CompareTo(A_Wrong) > 0)
			{
				if (B_Right.CompareTo(B_Wrong) > 0)
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s += "정답 ①번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s += "정답 ①번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
				}
				else
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s += "정답 ②번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s += "정답 ②번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
				}
			}
			else
			{
				if (B_Right.CompareTo(B_Wrong) > 0)
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A2>\r";
						s += "\t<A3> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s += "정답 ③번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A2>\r";
						s += "\t<A3> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s += "정답 ③번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
				}
				else
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A1>\r";
						s += "\t<A2> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A2>\r";
						s += "\t<A3> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A4>\r";
						s += "\t<A5> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s += "정답 ⑤번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A1>\r";
						s += "\t<A2> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A4>\r";
						s += "\t<A5> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s += "정답 ⑤번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
				}
			}

	        return s;
        }
        #endregion
        #region 어휘
        public static string 어휘(string 본문, string 해석)
        {
	        string			XML = "";

	        int cnt = 어휘_출제가능부분확인(본문);

	        if(cnt == 0)		{		return "";	
	        }
	        else if(cnt == 1)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문, 해석, 1);
	        }
	        else if(cnt == 2)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문, 해석, 2);
	        }
	        else if(cnt == 3)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,1,2); 
	        }                                                                          
	        else if(cnt == 4)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,2,3);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,2,3); 
	        }                                                                          
	        else if(cnt == 5)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,2,4);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,3,4); 
	        }                                                                          
	        else if(cnt == 6)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,2,4);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,3,5); 
	        }                                                                          
	        else if(cnt == 7)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,2,4);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,3,5); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,3,6);	
	        }                                                                          
	        else if(cnt == 8)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,3,6);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,4,7); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,5,7);	
	        }                                                                          
	        else if(cnt == 9)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,3,6);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,4,7); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,5,8);	
	        }                                                                          
	        else if(cnt == 10)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,3,6);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,4,7); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,5,8);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,4,9);	
	        }                                                                          
	        else if(cnt == 11)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,4,8);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,5,9); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,6,10);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,7,10);	
	        }                                                                          
	        else if(cnt == 12)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,4,8);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,5,9); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,6,10);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,7,11);	
	        }                                                                          
	        else if(cnt == 13)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,4,8);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,5,9); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,6,10);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,7,11);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,6,12);	
	        }                                                                          
	        else if(cnt == 14)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,5,9);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,6,11); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,7,12);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,8,13);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 4,9,13);	
	        }                                                                          
	        else if(cnt == 15)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,5,10);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,6,11); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,7,12);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,8,13);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 4,9,14);	
	        }                                                                          
	        else if(cnt == 16)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,5,10);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,6,11); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,7,12);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,8,13);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 4,9,14);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,7,15);	
	        }                                                                          
	        else if(cnt == 17)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,6,12);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,7,13); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,8,14);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,9,15);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 4,10,16);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 5,11,15);	
	        }                                                                          
	        else if(cnt == 18)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,6,12);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,7,13); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,8,14);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,9,15);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 4,10,16);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 5,11,17);	
	        }                                                                          
	        else if(cnt == 19)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,6,12);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,7,13); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,8,14);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,9,15);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 4,10,16);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 5,11,17);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,9,18);	
	        }                                                                          
	        else if(cnt == 20)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,7,14);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,8,15); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,9,16);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,10,17);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 4,11,18);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 5,12,19);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 6,13,19);	
	        }                                                                          
	        else if(cnt == 21)	{		XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 0,7,14);
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 1,8,15); 
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 2,9,16);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 3,10,17);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 4,11,18);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 5,12,19);	
								        XML += 어휘문제출제_2단계_XML형식문제출제(본문,해석, 6,13,20);
	        }


	        return XML;
        }
        public static string 어휘문제출제_2단계_XML형식문제출제(string 지문, string 해석, int 출제가능숫자)
        {
            string result = "<CAKE>\r";
            string 정답 = "";

            if(출제가능숫자 == 1)
                result += "\t<Q> " + _현재번호 + ". 밑줄 친 단어를 문맥에 맞게 고쳐 쓰시오. </Q>\r";
            else
                result += "\t<Q> " + _현재번호 + ". 밑줄 친 두 단어를 문맥에 맞게 고쳐 쓰시오. </Q>\r";


            result += "\t<T>\r";
            result += "\t";

            _어휘_이미출제한것들.Clear();

            List<string> 지문의_단어들 = new List<string>();

            string Res = "", WrongAnswer = "";

            string C;	// current word

            변환.문자열.탭과개행문자를살린어절들로(지문, ref 지문의_단어들);

            for (int i = 0; i < 지문의_단어들.Count; i++)
            {
                C = 지문의_단어들[i];

		        if(어휘_현재어절을문제낼수있는지확인(C, ref Res, ref WrongAnswer))
                {
					if (출제가능숫자 == 1)
					{
						result += " [" + WrongAnswer + "]" + 변환.문자열.오른쪽불필요문자(C);

						정답 = "정답 : " + 변환.문자열.불필요문자제거(C);
					}
					if (출제가능숫자 == 2)
					{
						if (정답 == "")
						{
							result += " (A) [" + WrongAnswer + "]" + 변환.문자열.오른쪽불필요문자(C);

							정답 = "정답 (A) : " + 변환.문자열.불필요문자제거(C);
						}
						else
						{
							result += " (B) [" + WrongAnswer + "]" + 변환.문자열.오른쪽불필요문자(C);

							정답 += ", (B) : " + 변환.문자열.불필요문자제거(C);
						}
					}
                }
                else
                {
                    result += " " + C;
                }

            }
            result += "\r";
            result += "\t<TBAR></TBAR>\r";
            result += "\t" + 해석 + "\r";

            result += "\t</T>\r";
            result += "\t<정답>\r";
            result += "\t" + 정답 + "\r";
            result += "\t</정답>\r";
            result += "</CAKE>\r";

            _현재번호++;

            return result;
        }

        public static string 어휘문제출제_2단계_XML형식문제출제(string 본문, string 해석, int a, int b, int c)
        {
            List<string> 어절들 = new List<string>();
            List<string> saResult = new List<string>();


	        string			현재어절, 처리결과 = "", 오답으로제시할것 = "";
	        string			A_Right = "",A_Wrong = "",B_Right = "",B_Wrong = "",C_Right = "",C_Wrong = "";

	        int nCreatedQuestion = 0;

            변환.문자열.탭과개행문자를살린어절들로(본문, ref 어절들);

            _어휘_이미출제한것들.Clear();

	        for(int i = 0 ; i < 어절들.Count() ;i++)
	        {
		        현재어절 = 어절들[i];
		        if(어휘_현재어절을문제낼수있는지확인(현재어절, ref 처리결과, ref 오답으로제시할것))
		        {
			        if(nCreatedQuestion == a)
                    { saResult.Add(string.Format("(A) {0}", 처리결과)); A_Right = 현재어절; A_Wrong = 오답으로제시할것; }
			        else if(nCreatedQuestion == b)
                    { saResult.Add(string.Format("(B) {0}", 처리결과)); B_Right = 현재어절; B_Wrong = 오답으로제시할것; }
			        else if(nCreatedQuestion == c)
                    { saResult.Add(string.Format("(C) {0}", 처리결과)); C_Right = 현재어절; C_Wrong = 오답으로제시할것; }
			        else
			        {
				        saResult.Add(현재어절);
			        }

			        nCreatedQuestion++;
		        }
		        else
			        saResult.Add(처리결과);
	        }
	        string result = "";
	        // 선택지를 만든다.
	        result += 어휘문제출제_1단계_XML형식문제출제(saResult);
	        result += 어휘문제출제_2단계_XML형식문제출제_보기해설부분(해석, A_Right,A_Wrong,B_Right,B_Wrong,C_Right,C_Wrong);

	        return result;
        }
        public static string 어휘문제출제_2단계_XML형식문제출제_보기해설부분(string 해석, string A_Right, string A_Wrong, string B_Right, string B_Wrong, string C_Right, string C_Wrong)
        {
	        string s = "";

            A_Right = 변환.문자열.문장부호제거(A_Right);            A_Wrong = 변환.문자열.문장부호제거(A_Wrong);
            B_Right = 변환.문자열.문장부호제거(B_Right);            B_Wrong = 변환.문자열.문장부호제거(B_Wrong);
            C_Right = 변환.문자열.문장부호제거(C_Right);            C_Wrong = 변환.문자열.문장부호제거(C_Wrong);

			if(A_Right.CompareTo(A_Wrong) > 0)
			{
				if(B_Right.CompareTo(B_Wrong) > 0)
				{
					if(C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s += "정답 ①번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s+= A_Right; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A1>\r";
						s += "\t<A2> "; s+= A_Right; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Right; s+= " </A2>\r";
						s += "\t<A3> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A3>\r";
						s += "\t<A4> "; s+= A_Wrong; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Wrong; s+= " </A4>\r";
						s += "\t<A5> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Wrong; s+= " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s+= "정답 ①번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s +=  "</CAKE>\r";
					}
				}
				else
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A1>\r";
						s += "\t<A2> "; s+= A_Right; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A2>\r";
						s += "\t<A3> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Wrong; s+= " </A3>\r";
						s += "\t<A4> "; s+= A_Right; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Wrong; s+= " </A4>\r";
						s += "\t<A5> "; s+= A_Wrong; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Wrong; s+= " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s+= "정답 ②번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s +=  "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A1>\r";
						s += "\t<A2> "; s+= A_Right; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A2>\r";
						s += "\t<A3> "; s+= A_Wrong; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Right; s+= " </A3>\r";
						s += "\t<A4> "; s+= A_Right; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Wrong; s+= " </A4>\r";
						s += "\t<A5> "; s+= A_Wrong; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Wrong; s+= " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s+= "정답 ②번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s +=  "</CAKE>\r";
					}
				}
			}
			else
			{
				if (B_Right.CompareTo(B_Wrong) > 0)
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s+= A_Right; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Right; s+= " </A1>\r";
						s += "\t<A2> "; s+= A_Right; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Wrong; s+= " </A2>\r";
						s += "\t<A3> "; s+= A_Right; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A3>\r";
						s += "\t<A4> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Wrong; s+= " </A4>\r";
						s += "\t<A5> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s+= "정답 ③번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s +=  "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A1>\r";
						s += "\t<A2> "; s+= A_Wrong; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Right; s+= " </A2>\r";
						s += "\t<A3> "; s+= A_Right; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A3>\r";
						s += "\t<A4> "; s+= A_Right; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Wrong; s+= " </A4>\r";
						s += "\t<A5> "; s+= A_Right; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Wrong; s+= " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s+= "정답 ③번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s +=  "</CAKE>\r";
					}
				}
				else
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Wrong; s+= " </A1>\r";
						s += "\t<A2> "; s+= A_Wrong; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Wrong; s+= " </A2>\r";
						s += "\t<A3> "; s+= A_Right; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Wrong; s+= " </A3>\r";
						s += "\t<A4> "; s+= A_Right; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Right; s+= " </A4>\r";
						s += "\t<A5> "; s+= A_Right; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s+= "정답 ⑤번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s +=  "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Wrong; s+= " </A1>\r";
						s += "\t<A2> "; s+= A_Wrong; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Wrong; s+= " </A2>\r";
						s += "\t<A3> "; s+= A_Wrong; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A3>\r";
						s += "\t<A4> "; s+= A_Right; s+= " …… "; s+= B_Wrong; s+= " …… "; s+= C_Right; s+= " </A4>\r";
						s += "\t<A5> "; s+= A_Right; s+= " …… "; s+= B_Right; s+= " …… "; s+= C_Right; s+= " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t"; s+= "정답 ⑤번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s +=  "</CAKE>\r";
					}
				}
			}

	        return s;
        }
        public static string 어휘문제출제_1단계_XML형식문제출제(List<string> saResult)
        {
	        string sRes = "";
	        sRes += "<CAKE>\r";
	        sRes += "\t<Q> " + _현재번호 + ". 네모 안에서 문맥에 알맞는 어휘를 고르시오. </Q>\r";
	        sRes += "\t<T>\r";
            sRes += "\t" + 변환.문자열들.단락으로(saResult) + "\r";
	        sRes += "\t</T>\r";
            _현재번호++;
	        return sRes;
        }
        public static bool 어휘_현재어절을문제낼수있는지확인(string 현재어절, ref string 처리결과, ref string 오답으로제시할것)
        {
            bool 현재어절의맨앞부분이대문자인지 = false;

            string 원본 = 현재어절;
	        string			sMark;

            List<string> VocaTable = new List<string>();

	        오답으로제시할것 = "";
	        처리결과		= "";

            if (변환.문자열.Right(현재어절, 1) == ",") { 현재어절 = 현재어절.Substring(0, 현재어절.Length - 1); sMark = ","; }
            else if (변환.문자열.Right(현재어절, 1) == ".") { 현재어절 = 현재어절.Substring(0, 현재어절.Length - 1); sMark = "."; }
            else { sMark = ""; }

            string 현재어절소문자화 = 현재어절.ToLower();

            if(현재어절소문자화 != 현재어절)
            {
                현재어절의맨앞부분이대문자인지 = true;

            }


            변환.Ansi파일.문자열들로(_문제DB루트폴더 + "voca.qst", ref VocaTable);



            for (int i = 0; i < VocaTable.Count; i++)
            {
                string s = VocaTable[i];

                string[] s배열 = s.Split(',');



                if (현재어절소문자화 == s배열[0]) { 오답으로제시할것 = s배열[1]; }
                if (현재어절소문자화 == s배열[1]) { 오답으로제시할것 = s배열[0]; }

            }



            if (오답으로제시할것 == "") { 처리결과 = 원본; return false; }
            else
            {
                if(현재어절의맨앞부분이대문자인지)
                {
                    오답으로제시할것 = 변환.문자열.Left(오답으로제시할것, 1).ToUpper() + 오답으로제시할것.Substring(1);
                }

                if (string.Compare(현재어절, 오답으로제시할것) > 0)
                    처리결과 = string.Format("[{0} / {1}]", 오답으로제시할것, 현재어절);
                else
                    처리결과 = string.Format("[{0} / {1}]", 현재어절, 오답으로제시할것);
            }

            if (_어휘_이미출제한것들.Contains(처리결과))
            {
                처리결과 = 원본;
                return false;
            }
            else
            {
                _어휘_이미출제한것들.Add(처리결과);
            }

            처리결과 += sMark;


	        return true;
        }
        public static int 어휘_출제가능부분확인(string 본문)
        {
	        string			sRes = "", 현재어절 = "", SNULL = "";

            List<string> 어절들 = new List<string>();

	        int nCreatedQuestion = 0;

            변환.문자열.탭과개행문자를살린어절들로(본문, ref 어절들);

            _어휘_이미출제한것들.Clear();

	        for(int i = 0 ; i < 어절들.Count() ;i++)
	        {
		        현재어절 = 어절들[i];
		        sRes = "";
		        if(어휘_현재어절을문제낼수있는지확인(현재어절,ref sRes, ref SNULL))
			        nCreatedQuestion++;
	        }
	        return nCreatedQuestion;
        }
        #endregion
        #region 접속어
        public static string 접속어(string 본문, string 해석)
        {
			int 접속어갯수 = 접속어_갯수_확인(본문);

			if (접속어갯수 == 0)
                return "";
			else if (접속어갯수 == 1)
            {
                string s = "";
                //								           정답			   보기1		    보기2			보기3	 		   보기4		  보기5
                s += 접속어_1개_문제(본문, 해석, "④",     "For example",  "As a result",  "Nevertheless", "On the contrary", "For example", "Though");
                s += 접속어_1개_문제(본문, 해석, "④",     " for example", "as a result", "nevertheless", "on the contrary", "for example", "though");

                s += 접속어_1개_문제(본문, 해석, "④", "For instance", "As a result", "Nevertheless", "On the contrary", "For instance", "Though");
                s += 접속어_1개_문제(본문, 해석, "④", " for instance", "as a result", "nevertheless", "on the contrary", "for instance", "though");

				s += 접속어_1개_문제(본문, 해석, "④", "Also,", "However", "Nevertheless", "On the contrary", "Also", "Though");
				s += 접속어_1개_문제(본문, 해석, "④", "So,", "However", "Nevertheless", "On the contrary", "So", "Though");

                s += 접속어_1개_문제(본문, 해석, "④", "Therefore", "However", "Nevertheless", "On the contrary", "Therefore", "Though");
                s += 접속어_1개_문제(본문, 해석, "④", " therefore", "however", "nevertheless", "on the contrary", "therefore", "though");

                s += 접속어_1개_문제(본문, 해석, "④", "In addition", "As a result", "Nevertheless", "On the contrary", "In addition", "Though");
                s += 접속어_1개_문제(본문, 해석, "④", " in addition", "as a result", "nevertheless", "on the contrary", "in addition", "though");

                s += 접속어_1개_문제(본문, 해석, "④", "Moreover", "As a result", "Nevertheless", "On the contrary", "Moreover", "Though");
                s += 접속어_1개_문제(본문, 해석, "④", " moreover", "as a result", "nevertheless", "on the contrary", "moreover", "though");

                s += 접속어_1개_문제(본문, 해석, "①", "As a result", "As a result", "Nevertheless", "On the contrary", "However", "Though");
                s += 접속어_1개_문제(본문, 해석, "①", " as a result", "as a result", "nevertheless", "on the contrary", "however", "though");

                s += 접속어_1개_문제(본문, 해석, "⑤", "At last", "Though", "Nevertheless", "On the contrary", "However", "At last");
                s += 접속어_1개_문제(본문, 해석, "⑤", " at last", "though", "nevertheless", "on the contrary", "however", "at last");

                s += 접속어_1개_문제(본문, 해석, "⑤", "Besides", "On the other hand", "Nevertheless", "On the contrary", "However", "Besides");
                s += 접속어_1개_문제(본문, 해석, "⑤", " besides", "on the other hand", "nevertheless", "on the contrary", "however", "besides");

                s += 접속어_1개_문제(본문, 해석, "⑤", "By the way", "On the other hand", "Nevertheless", "On the contrary", "However", "By the way");
                s += 접속어_1개_문제(본문, 해석, "⑤", " by the way", "on the other hand", "nevertheless", "on the contrary", "however", "by the way");

                s += 접속어_1개_문제(본문, 해석, "④", "However", "As a result", "In the long run", "Therefore", "However", "In a word");
                s += 접속어_1개_문제(본문, 해석, "④", " however", "as a result", "in the long run", "therefore", "however", "in a word");

                s += 접속어_1개_문제(본문, 해석, "⑤", "In a word", "On the other hand", "For example", "On the contrary", "However", "In a word");
                s += 접속어_1개_문제(본문, 해석, "⑤", " in a word", "on the other hand", "for example", "on the contrary", "however", "in a word");

                s += 접속어_1개_문제(본문, 해석, "⑤", "In conclusion", "Though", "Nevertheless", "On the contrary", "However", "In conclusion");
                s += 접속어_1개_문제(본문, 해석, "⑤", " in conclusion", "though", "nevertheless", "on the contrary", "however", "in conclusion");

                s += 접속어_1개_문제(본문, 해석, "⑤", "In fact", "On the other hand", "Nevertheless", "On the contrary", "However", "In fact");
                s += 접속어_1개_문제(본문, 해석, "⑤", " in fact", "on the other hand", "nevertheless", "on the contrary", "however", "in fact");

                s += 접속어_1개_문제(본문, 해석, "④", "On the other hand", "As a result", "In the long run", "Therefore", "On the other hand", "In a word");
                s += 접속어_1개_문제(본문, 해석, "④", " on the other hand", "as a result", "in the long run", "therefore", "on the other hand", "in a word");

                s += 접속어_1개_문제(본문, 해석, "⑤", "In the end", "Though", "Nevertheless", "On the contrary", "However", "In the end");
                s += 접속어_1개_문제(본문, 해석, "⑤", " in the end", "though", "nevertheless", "on the contrary", "however", "in the end");

                s += 접속어_1개_문제(본문, 해석, "⑤", "In the long run", "Though", "Nevertheless", "On the contrary", "However", "In the long run");
                s += 접속어_1개_문제(본문, 해석, "⑤", " in the long run", "though", "nevertheless", "on the contrary", "however", "in the long run");

                s += 접속어_1개_문제(본문, 해석, "③", "Nonetheless", "That is", "Therefore", "Nonetheless", "Because", "Moreover");
                s += 접속어_1개_문제(본문, 해석, "③", " nonetheless", "that is", "therefore", "nonetheless", "because", "moreover");

                s += 접속어_1개_문제(본문, 해석, "④", "On the contrary", "As a result", "In the long run", "Therefore", "On the contrary", "In a word");
                s += 접속어_1개_문제(본문, 해석, "④", " on the contrary", "as a result", "in the long run", "therefore", "on the contrary", "in a word");

                s += 접속어_1개_문제(본문, 해석, "④", "On the other hand", "As a result", "In the long run", "Therefore", "On the other hand", "In a word");
                s += 접속어_1개_문제(본문, 해석, "④", " on the other hand", "as a result", "in the long run", "therefore", "on the other hand", "in a word");

                s += 접속어_1개_문제(본문, 해석, "②", "Furthermore", "However", "Furthermore", "Nevertheless", "On the contrary", "By the way");
                s += 접속어_1개_문제(본문, 해석, "②", " furthermore", "however", "furthermore", "nevertheless", "on the contrary", "by the way");

                s += 접속어_1개_문제(본문, 해석, "①", "Although", "Although", "As a result", "Nevertheless", "On the contrary", "Therefore");
                s += 접속어_1개_문제(본문, 해석, "①", " although", "although", "as a result", "nevertheless", "on the contrary", "therefore");

                // 전치사지만,
                s += 접속어_1개_문제(본문, 해석, "①", "Despite",  "Despite", "For", "During", "After", "Because of");
                s += 접속어_1개_문제(본문, 해석, "①", " despite", "despite", "for", "during", "after", "because of");


                s += 접속어_1개_문제(본문, 해석, "③", "Nevertheless", "That is", "Therefore", "Nevertheless", "Because", "Moreover");
                s += 접속어_1개_문제(본문, 해석, "③", " nevertheless", "that is", "therefore", "nevertheless", "because", "moreover");


                s += 접속어_1개_문제(본문, 해석, "②", " Though ", "As a result", "Though", "Nevertheless", "By the way", "Therefore");
                s += 접속어_1개_문제(본문, 해석, "②", " though ", "as a result", "though", "nevertheless", "by the way", "therefore");

                s += 접속어_1개_문제(본문, 해석, "②", " Though,", "As a result", "Though", "Nevertheless", "By the way", "Therefore");
                s += 접속어_1개_문제(본문, 해석, "②", " though,", "as a result", "though", "nevertheless", "by the way", "therefore");

                s += 접속어_1개_문제(본문, 해석, "②", ",Though,", "As a result", "Though", "Nevertheless", "By the way", "Therefore");
                s += 접속어_1개_문제(본문, 해석, "②", ",though,", "as a result", "though", "nevertheless", "by the way", "therefore");

                s += 접속어_1개_문제(본문, 해석, "②", " Though.", "As a result", "Though", "Nevertheless", "By the way", "Therefore");
                s += 접속어_1개_문제(본문, 해석, "②", " though.", "as a result", "though", "nevertheless", "by the way", "therefore");

                s += 접속어_1개_문제(본문, 해석, "④", " Thus ", "However", "Nevertheless", "On the contrary", "Thus", "Though");
                s += 접속어_1개_문제(본문, 해석, "④", " thus ", "however", "nevertheless", "on the contrary", "thus", "though");

                s += 접속어_1개_문제(본문, 해석, "④", " Thus,", "However", "Nevertheless", "On the contrary", "Thus", "Though");
                s += 접속어_1개_문제(본문, 해석, "④", " thus,", "however", "nevertheless", "on the contrary", "thus", "though");

                s += 접속어_1개_문제(본문, 해석, "④", ",Thus,", "However", "Nevertheless", "On the contrary", "Thus", "Though");
                s += 접속어_1개_문제(본문, 해석, "④", ",thus,", "however", "nevertheless", "on the contrary", "thus", "though");

                s += 접속어_1개_문제(본문, 해석, "④", " Thus.", "However", "Nevertheless", "On the contrary", "Thus", "Though");
                s += 접속어_1개_문제(본문, 해석, "④", " thus.", "however", "nevertheless", "on the contrary", "thus", "though");

                return s;
            }
			else if (접속어갯수 == 2)
            {
                string 접속어1 = "", 접속어2 = "";
                접속어_2개_분배(본문, ref 접속어1, ref 접속어2);

                return 접속어_2개_문제(본문, 해석, 접속어1, 접속어2);
            }
			else if (접속어갯수 == 3)
            {
                return 접속어_3개_문제(본문, 해석, 0, 1, 2);
            }
			else if (접속어갯수 == 4)
            {
                string s = "";
                s += 접속어_3개_문제(본문, 해석, 0, 2, 3);
                s += 접속어_3개_문제(본문, 해석, 1, 2, 3);
                return s;
            }
			else if (접속어갯수 == 5)
            {
                string s = "";

                s += 접속어_3개_문제(본문, 해석, 0, 2, 4);
                s += 접속어_3개_문제(본문, 해석, 1, 3, 4);
                return s;
            }
			else
            {
                string s = "";
                s += 접속어_3개_문제(본문, 해석, 0, 2, 4);
                s += 접속어_3개_문제(본문, 해석, 1, 3, 5);
                return s;
			}
        }
      
        public static string 접속어_3개_문제(string 본문, string 해석, int a, int b, int c)
        {
            List<string> 어절들 = new List<string>();
            List<string> saResult = new List<string>();

	        string			A_Right = "",A_Wrong = "",B_Right = "",B_Wrong = "",C_Right = "",C_Wrong = "";

	        int nCreatedQuestion = 0;

            본문 = 본문.Replace("As a result of", "As=a=result=of");
            본문 = 본문.Replace("as a result of", "as=a=result=of");



            본문 = 본문.Replace("For example", "For_example"); // 예를 들어
            본문 = 본문.Replace("For instance", "For_instance"); // 예를 들어
            본문 = 본문.Replace("In addition", "In_addition"); // 덧붙여서
            본문 = 본문.Replace("As a result", "As_a_result"); // 결과적으로
            본문 = 본문.Replace("At last", "At_last"); // 결국에는
            본문 = 본문.Replace("By the way", "By_the_way"); // 그나저나 말이 나왔으니 말인데
            본문 = 본문.Replace("In a word", "In_a_word"); // 한마디로 말해서
            본문 = 본문.Replace("In conclusion", "In_conclusion"); // 결과적으로
            본문 = 본문.Replace("In fact", "In_fact"); // 사실
            본문 = 본문.Replace("On the other hand", "On_the_other_hand"); // 반면에
            본문 = 본문.Replace("In the end", "In_the_end"); // 결국에는
            본문 = 본문.Replace("In the long run", "In_the_long_run"); // 결국에는
            본문 = 본문.Replace("On the contrary", "On_the_contrary"); // 이와는 반대로

            본문 = 본문.Replace("for example", "for_example");
            본문 = 본문.Replace("for instance", "for_instance");
            본문 = 본문.Replace("in addition", "in_addition");
            본문 = 본문.Replace("as a result", "as_a_result");
            본문 = 본문.Replace("at last", "at_last");
            본문 = 본문.Replace("by the way", "by_the_way");
            본문 = 본문.Replace("in a word", "in_a_word");
            본문 = 본문.Replace("in conclusion", "in_conclusion");
            본문 = 본문.Replace("in fact", "in_fact");
            본문 = 본문.Replace("on the other hand", "on_the_other_hand");
            본문 = 본문.Replace("in the end", "in_the_end");
            본문 = 본문.Replace("in the long run", "in_the_long_run");
            본문 = 본문.Replace("on the contrary", "on_the_contrary");

            변환.문자열.탭과개행문자를살린어절들로(본문, ref 어절들);

            foreach(string 현재어절 in 어절들)
            {
                string 현재어절임시 = 현재어절;

		        string prefix = "";	string suffix = "";
                if (변환.문자열.Left(현재어절임시, 1) == " ") prefix = " "; if (변환.문자열.Left(현재어절임시, 1) == ",") prefix = ",";
                if (변환.문자열.Right(현재어절임시, 1) == " ") suffix = " "; if (변환.문자열.Right(현재어절임시, 1) == ",") suffix = ",";

		        string origCur;
                origCur = 현재어절임시;

                현재어절임시 = 현재어절임시.Trim();
                현재어절임시 = 현재어절임시.Replace(",", "");


		        string A_blank, B_blank, C_blank;
		        A_blank = string.Format("{0}___(A)___{1}", prefix, suffix);
		        B_blank = string.Format("{0}___(B)___{1}", prefix, suffix);
		        C_blank = string.Format("{0}___(C)___{1}", prefix, suffix);


                if (Connective_03_Lier(현재어절임시) != "")
		        {
			

			        if(nCreatedQuestion == a)
                    { saResult.Add(A_blank); A_Right = 현재어절임시; A_Wrong = Connective_03_Lier(현재어절임시); }
			        else if(nCreatedQuestion == b)
                    { saResult.Add(B_blank); B_Right = 현재어절임시; B_Wrong = Connective_03_Lier(현재어절임시); }
			        else if(nCreatedQuestion == c)
                    { saResult.Add(C_blank); C_Right = 현재어절임시; C_Wrong = Connective_03_Lier(현재어절임시); }
			        else
			        {
				        origCur.Replace("_", " ");
				        saResult.Add(origCur);
			        }

			        nCreatedQuestion++;
		        }
		        else
			        saResult.Add(origCur);
	        }
	        string result = "";

            A_Right = A_Right.Replace("_", " ");
            B_Right = B_Right.Replace("_", " ");
            C_Right = C_Right.Replace("_", " ");

	        // 선택지를 만든다.
	        result += Connective_03_XML_Front(ref saResult);
	        result += Connective_03_XML_Back(해석, A_Right,A_Wrong,B_Right,B_Wrong,C_Right,C_Wrong);

            result = result.Replace("As=a=result=of", "As a result of");
            result = result.Replace("as=a=result=of", "as a result of");

	        return result;
        }
        public static string Connective_03_XML_Front(ref List<string> saResult)
        {
	        string sRes = "<CAKE>\r";

		        sRes += "\t<Q> " + _현재번호 + ". 다음 글을 읽고, 빈칸에 들어갈 말로 가장 적절한 것을 고르시오. </Q>\r";

	        sRes += "\t<T>\r";
            sRes += "\t" + 변환.문자열들.단락으로(saResult) + "\r";
	        sRes += "\t</T>\r";

            _현재번호++;
            return sRes;
        }
        public static string Connective_03_XML_Back(string 해석, string A_Right, string A_Wrong, string B_Right, string B_Wrong, string C_Right, string C_Wrong)
        {
	        string s = "";

	        A_Right.Replace(",", "");
	        A_Right.Replace(".", "");
	        A_Wrong.Replace(",", "");
	        A_Wrong.Replace(".", "");

	        B_Right.Replace(",", "");
	        B_Right.Replace(".", "");
	        B_Wrong.Replace(",", "");
	        B_Wrong.Replace(".", "");

	        C_Right.Replace(",", "");
	        C_Right.Replace(".", "");
	        C_Wrong.Replace(",", "");
	        C_Wrong.Replace(".", "");

			if(A_Right.CompareTo(A_Wrong) > 0)
			{
				if(B_Right.CompareTo(B_Wrong) > 0)
				{
					if(C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A2>\r";
						s += "\t<A3> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A3>\r";
						s += "\t<A4> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t정답 ①번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t정답 ②번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
				}
				else
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A1>\r";
						s += "\t<A2> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A2>\r";
						s += "\t<A3> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A4>\r";
						s += "\t<A5> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t정답 ③번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A1>\r";
						s += "\t<A2> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A4>\r";
						s += "\t<A5> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t정답 ④번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
				}
			}
			else
			{
				if (B_Right.CompareTo(B_Wrong) > 0)
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A1>\r";
						s += "\t<A2> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A4>\r";
						s += "\t<A5> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t정답 ④번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A1>\r";
						s += "\t<A2> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A2>\r";
						s += "\t<A3> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A4>\r";
						s += "\t<A5> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t정답 ④번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
				}
				else
				{
					if (C_Right.CompareTo(C_Wrong) > 0)
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A1>\r";
						s += "\t<A2> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A2>\r";
						s += "\t<A3> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A3>\r";
						s += "\t<A4> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Right; s += " </A4>\r";
						s += "\t<A5> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t정답 ⑤번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
					else
					{
						s += "\t<A>\r";
						s += "\t<A0> (A) …… (B) …… (C) </A0>\r";
						s += "\t<A1> "; s += A_Right; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A1>\r";
						s += "\t<A2> "; s += A_Wrong; s += " …… "; s += B_Wrong; s += " …… "; s += C_Wrong; s += " </A2>\r";
						s += "\t<A3> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Wrong; s += " </A3>\r";
						s += "\t<A4> "; s += A_Wrong; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A4>\r";
						s += "\t<A5> "; s += A_Right; s += " …… "; s += B_Right; s += " …… "; s += C_Right; s += " </A5>\r";
						s += "\t</A>\r";
						s += "\t<정답>\r";
						s += "\t정답 ⑤번\r";
						s += "\t</정답>\r";
						s += "\t<해석>\r";
						s += "\t" + 해석 + "\r";
						s += "\t</해석>\r";
						s += "\t<해설>\r";
						s += "\t" + A_Right + ", " + B_Right + ", " + C_Right + "\r";
						s += "\t</해설>\r";
						s += "</CAKE>\r";
					}
				}
			}

	        return s;
        }
        public static string Connective_03_Lier(string W)
        {
            List<string> AR = new List<string>();
            List<string> AL = new List<string>();

            AR.Add("Despite"); AL.Add("Because of");

			AR.Add("Also"); AL.Add("Nonetheless");
			AR.Add("So"); AL.Add("Nonetheless");

	        AR.Add("For_example")		;	AL.Add("At last")			;
	        AR.Add("For_instance")		;	AL.Add("At last")			;
	        AR.Add("Therefore")			;	AL.Add("However")			;
	        AR.Add("In_addition")		;	AL.Add("However")			;
	        AR.Add("Moreover")			;	AL.Add("However")			;
	        AR.Add("As_a_result")		;	AL.Add("However")			;
	        AR.Add("At_last")			;	AL.Add("However")			;
	        AR.Add("Besides")			;	AL.Add("However")			;
	        AR.Add("By_the_way")		;	AL.Add("Therefore")		;
	        AR.Add("However")			;	AL.Add("In conclusion")	;
	        AR.Add("In_a_word")			;	AL.Add("On the contrary")	;
	        AR.Add("In_conclusion")		;	AL.Add("However")			;
	        AR.Add("In_fact")			;	AL.Add("Though")			;
	        AR.Add("On_the_other_hand")	;	AL.Add("In a word")		;
	        AR.Add("In_the_end")		;	AL.Add("However")			;
	        AR.Add("In_the_long_run")	;	AL.Add("However")			;
	        AR.Add("Nonetheless")		;	AL.Add("In a word")		;
	        AR.Add("On_the_contrary")	;	AL.Add("In a word")		;
	        AR.Add("On_the_other_hand")	;	AL.Add("In a word")		;
	        AR.Add("Thus")				;	AL.Add("Nonetheless")		;
	        AR.Add("Furthermore")		;	AL.Add("Nonetheless")		;
	        AR.Add("Although")			;	AL.Add("In a word")		;
	        AR.Add("Nevertheless")		;	AL.Add("In a word")		;
	        AR.Add("Though")			;	AL.Add("In a word")		;

	        for(int i = 0 ; i < AR.Count() ; i++)
	        {
		        string A	= AR[i];
		        string Al	= AL[i];

		        string a	= A;				a = a.ToLower();
                string al = Al;                 al = al.ToLower();

		        if(W == A) return Al;
		        if(W == a) return al;

	        }

	        return "";
        }

        // 입력받을 접속어 w
        // lv_lie : level of lie 1단계와 2단계가 있다.
        public static void 접속어_오답만들기(string 접속어, ref string 오답1, ref string 오답2)
        {
			if (접속어 == "Also") { 오답1 = "However"; 오답2 = "Nevertheless"; }
			if (접속어 == "So") { 오답1 = "However"; 오답2 = "Nevertheless"; }
            if (접속어 == "Despite") { 오답1 = "Because of"; 오답2 = "For"; } if (접속어 == "despite") { 오답1 = "because of"; 오답2 = "for"; }

	        if(접속어 == "For example")			{	오답1 = "At last"			;	오답2 = "Although"			;}	if(접속어 == "for example")			{	오답1 = "at last"			;	오답2 = "although"			;}
	        if(접속어 == "For instance")			{	오답1 = "At last"			;	오답2 = "Although"			;}	if(접속어 == "for instance")			{	오답1 = "at last"			;	오답2 = "although"			;}
	        if(접속어 == "Therefore")			{	오답1 = "However"			;	오답2 = "Nevertheless"		;}	if(접속어 == "therefore")			{	오답1 = "however"			;	오답2 = "nevertheless"		;}
	        if(접속어 == "In addition")			{	오답1 = "However"			;	오답2 = "Nevertheless"		;}	if(접속어 == "in addition")			{	오답1 = "however"			;	오답2 = "nevertheless"		;}
	        if(접속어 == "Moreover")				{	오답1 = "However"			;	오답2 = "Nevertheless"		;}	if(접속어 == "moreover")				{	오답1 = "however"			;	오답2 = "nevertheless"		;}
	        if(접속어 == "As a result")			{	오답1 = "However"			;	오답2 = "Nevertheless"		;}	if(접속어 == "as a result")			{	오답1 = "however"			;	오답2 = "nevertheless"		;}
	        if(접속어 == "At last")				{	오답1 = "However"			;	오답2 = "Nevertheless"		;}	if(접속어 == "at last")				{	오답1 = "however"			;	오답2 = "nevertheless"		;}
	        if(접속어 == "Besides")				{	오답1 = "However"			;	오답2 = "Nevertheless"		;}	if(접속어 == "besides")				{	오답1 = "however"			;	오답2 = "nevertheless"		;}
	        if(접속어 == "By the way")			{	오답1 = "Therefore"			;	오답2 = "In the end"			;}	if(접속어 == "by the way")			{	오답1 = "therefore"			;	오답2 = "in the end"			;}
	        if(접속어 == "However")				{	오답1 = "In conclusion"		;	오답2 = "Though"				;}	if(접속어 == "however")				{	오답1 = "in conclusion"		;	오답2 = "though"				;}
	        if(접속어 == "In a word")			{	오답1 = "On the contrary"	;	오답2 = "On the other hand"	;}	if(접속어 == "in a word")			{	오답1 = "on the contrary"	;	오답2 = "on the other hand"	;}
	        if(접속어 == "In conclusion")		{	오답1 = "However"			;	오답2 = "Nevertheless"		;}	if(접속어 == "in conclusion")		{	오답1 = "however"			;	오답2 = "nevertheless"		;}
	        if(접속어 == "In fact")				{	오답1 = "Though"				;	오답2 = "Although"			;}	if(접속어 == "in fact")				{	오답1 = "though"				;	오답2 = "although"			;}
	        if(접속어 == "On the other hand")	{	오답1 = "In a word"			;	오답2 = "In conclusion"		;}	if(접속어 == "on the other hand")	{	오답1 = "in a word"			;	오답2 = "in conclusion"		;}
	        if(접속어 == "In the end")			{	오답1 = "However"			;	오답2 = "Nevertheless"		;}	if(접속어 == "in the end")			{	오답1 = "however"			;	오답2 = "nevertheless"		;}
	        if(접속어 == "In the long run")		{	오답1 = "However"			;	오답2 = "Nevertheless"		;}	if(접속어 == "in the long run")		{	오답1 = "however"			;	오답2 = "nevertheless"		;}
	        if(접속어 == "Nonetheless")			{	오답1 = "In a word"			;	오답2 = "In conclusion"		;}	if(접속어 == "nonetheless")			{	오답1 = "in a word"			;	오답2 = "in conclusion"		;}
	        if(접속어 == "On the contrary")		{	오답1 = "In a word"			;	오답2 = "In conclusion"		;}	if(접속어 == "on the contrary")		{	오답1 = "in a word"			;	오답2 = "in conclusion"		;}
	        if(접속어 == "On the other hand")	{	오답1 = "In a word"			;	오답2 = "In conclusion"		;}	if(접속어 == "on the other hand")	{	오답1 = "in a word"			;	오답2 = "in conclusion"		;}
	        if(접속어 == "Thus")					{	오답1 = "Nonetheless"		;	오답2 = "Nevertheless"		;}	if(접속어 == "thus")					{	오답1 = "nonetheless"		;	오답2 = "nevertheless"		;}
	        if(접속어 == "Furthermore")			{	오답1 = "Nonetheless"		;	오답2 = "Nevertheless"		;}	if(접속어 == "furthermore")			{	오답1 = "nonetheless"		;	오답2 = "nevertheless"		;}
	        if(접속어 == "Although")				{	오답1 = "In a word"			;	오답2 = "In conclusion"		;}	if(접속어 == "although")				{	오답1 = "in a word"			;	오답2 = "in conclusion"		;}
	        if(접속어 == "Nevertheless")			{	오답1 = "In a word"			;	오답2 = "In conclusion"		;}	if(접속어 == "nevertheless")			{	오답1 = "in a word"			;	오답2 = "in conclusion"		;}
	        if(접속어 == "Though")				{	오답1 = "In a word"			;	오답2 = "In conclusion"		;}	if(접속어 == "though")				{	오답1 = "in a word"			;	오답2 = "in conclusion"		;}
        }

        // 접속어가 지문에 둘 포함 되었을 경우에 문제를 내는 함수
        public static string 접속어_2개_문제(string 본문, string 해석, string 접속어1, string 접속어2)
        {
	        if(접속어1 == "" || 접속어2 == "") { MessageBox.Show("접속어_2개_문제 에러");	return "";	}

	        // p 만들기
	        //----------------------------------------------------------------------------------
	        string A_prefix = "";	string A_suffix = "";
	        if(변환.문자열.Left(접속어1 ,1)	 == " ") A_prefix = " "; if(변환.문자열.Left(접속어1, 1)   == ",") A_prefix = ",";
            if(변환.문자열.Right(접속어1, 1) == " ") A_suffix = " "; if (변환.문자열.Right(접속어1, 1) == ",") A_suffix = ",";

	        string B_prefix = "";	string B_suffix = "";
            if (변환.문자열.Left(접속어2, 1) == " ")    B_prefix = " "; if (변환.문자열.Left(접속어2, 1) == ",")    B_prefix = ",";
            if (변환.문자열.Right(접속어2, 1) == " ")   B_suffix = " "; if (변환.문자열.Right(접속어2, 1) == ",")   B_suffix = ",";

	        string A_blank, B_blank;

            A_blank = string.Format("{0}___(A)___{1}", A_prefix, A_suffix);
            B_blank = string.Format("{0}___(B)___{1}", B_prefix, B_suffix);


            본문 = 본문.Replace("As a result of", "As_a_result_of");
            본문 = 본문.Replace("as a result of", "as_a_result_of");

	        본문 = 본문.Replace(접속어1, A_blank);			본문 = 본문.Replace(접속어2, B_blank);
	        //----------------------------------------------------------------------------------

            본문 = 본문.Replace("As_a_result_of", "As a result of");
            본문 = 본문.Replace("as_a_result_of", "as a result of");

	        접속어1 = 접속어1.Trim();	접속어1 = 접속어1.Replace(",", "");
	        접속어2 = 접속어2.Trim();	접속어2 = 접속어2.Replace(",", "");

	        string 접속어1_오답1 = "", 접속어1_오답2 = "", 접속어2_오답1 = "", 접속어2_오답2 = "";
	        접속어_오답만들기(접속어1, ref 접속어1_오답1, ref 접속어1_오답2);
	        접속어_오답만들기(접속어2, ref 접속어2_오답1, ref 접속어2_오답2);

            string a_line1 = "", a_line2 = "", a_line3 = "", a_line4 = "", a_line5 = "";

	        string 정답_번 = "";

			List<string> 접속어A보기들 = new List<string>();
			List<string> 접속어B보기들 = new List<string>();

			접속어A보기들.Add(접속어1);
			접속어A보기들.Add(접속어1_오답1);
			접속어A보기들.Add(접속어1_오답2);

			접속어B보기들.Add(접속어2);
			접속어B보기들.Add(접속어2_오답1);
			접속어B보기들.Add(접속어2_오답2);

			접속어A보기들.Sort();
			접속어B보기들.Sort();

			if(접속어A보기들[0] == 접속어1 && 접속어B보기들[0] == 접속어2)
	        {
			    a_line1 = 접속어1;			a_line1 += " …… ";		a_line1 += 접속어2;
			    a_line2 = 접속어1;			a_line2 += " …… ";		a_line2 += 접속어2_오답1;
			    a_line3 = 접속어1;			a_line3 += " …… ";		a_line3 += 접속어2_오답2;
			    a_line4 = 접속어1_오답1;		a_line4 += " …… ";		a_line4 += 접속어2_오답1;
			    a_line5 = 접속어1_오답1;		a_line5 += " …… ";		a_line5 += 접속어2;

		        정답_번 = "정답 ①번";
	        }
			else if (접속어A보기들[0] == 접속어1 && 접속어B보기들[1] == 접속어2)
	        {
			    a_line1 = 접속어1;			a_line1 += " …… ";		a_line1 += 접속어2_오답1;
			    a_line2 = 접속어1;			a_line2 += " …… ";		a_line2 += 접속어2;
			    a_line3 = 접속어1;			a_line3 += " …… ";		a_line3 += 접속어2_오답2;
			    a_line4 = 접속어1_오답1;		a_line4 += " …… ";		a_line4 += 접속어2;
			    a_line5 = 접속어1_오답1;		a_line5 += " …… ";		a_line5 += 접속어2_오답1;
		        정답_번 = "정답 ②번";
	        }
			else if (접속어A보기들[0] == 접속어1 && 접속어B보기들[2] == 접속어2)
	        {
			    a_line1 = 접속어1_오답2;		a_line1 += " …… ";		a_line1 += 접속어2;
			    a_line2 = 접속어1_오답1;		a_line2 += " …… ";		a_line2 += 접속어2;
			    a_line3 = 접속어1;			a_line3 += " …… ";		a_line3 += 접속어2;
			    a_line4 = 접속어1_오답1;		a_line4 += " …… ";		a_line4 += 접속어2_오답1;
			    a_line5 = 접속어1_오답2;		a_line5 += " …… ";		a_line5 += 접속어2_오답1;

		        정답_번 = "정답 ③번";
	        }
			else if (접속어A보기들[1] == 접속어1 && 접속어B보기들[0] == 접속어2)
			{
				a_line1 = 접속어1_오답1;	a_line1 += " …… "; a_line1 += 접속어2_오답1;
				a_line2 = 접속어1_오답1;	a_line2 += " …… "; a_line2 += 접속어2;
				a_line3 = 접속어1;		a_line3 += " …… "; a_line3 += 접속어2_오답2;
				a_line4 = 접속어1;		a_line4 += " …… "; a_line4 += 접속어2;
				a_line5 = 접속어1;		a_line5 += " …… "; a_line5 += 접속어2_오답1;

		        정답_번 = "정답 ④번";
			}
			else if (접속어A보기들[1] == 접속어1 && 접속어B보기들[1] == 접속어2)
			{
			    a_line1 = 접속어1_오답1;		a_line1 += " …… ";		a_line1 += 접속어2_오답2;
			    a_line2 = 접속어1_오답1;		a_line2 += " …… ";		a_line2 += 접속어2;
			    a_line3 = 접속어1;			a_line3 += " …… ";		a_line3 += 접속어2_오답1;
			    a_line4 = 접속어1;			a_line4 += " …… ";		a_line4 += 접속어2;
			    a_line5 = 접속어1;			a_line5 += " …… ";		a_line5 += 접속어2_오답2;

		        정답_번 = "정답 ④번";
			}
			else if (접속어A보기들[1] == 접속어1 && 접속어B보기들[2] == 접속어2)
			{
			    a_line1 = 접속어1_오답1;		a_line1 += " …… ";		a_line1 += 접속어2_오답1;
			    a_line2 = 접속어1_오답1;		a_line2 += " …… ";		a_line2 += 접속어2;
			    a_line3 = 접속어1_오답1;		a_line3 += " …… ";		a_line3 += 접속어2_오답2;
			    a_line4 = 접속어1;			a_line4 += " …… ";		a_line4 += 접속어2;
			    a_line5 = 접속어1;			a_line5 += " …… ";		a_line5 += 접속어2_오답1;

		        정답_번 = "정답 ④번";
			}
			else if (접속어A보기들[2] == 접속어1 && 접속어B보기들[0] == 접속어2)
			{
			    a_line1 = 접속어1;			a_line1 += " …… ";		a_line1 += 접속어2_오답1;
			    a_line2 = 접속어1_오답2;		a_line2 += " …… ";		a_line2 += 접속어2_오답1;
			    a_line3 = 접속어1_오답1;		a_line3 += " …… ";		a_line3 += 접속어2;
			    a_line4 = 접속어1_오답2;		a_line4 += " …… ";		a_line4 += 접속어2;
			    a_line5 = 접속어1;			a_line5 += " …… ";		a_line5 += 접속어2;

		        정답_번 = "정답 ⑤번";
			}
			else if (접속어A보기들[2] == 접속어1 && 접속어B보기들[1] == 접속어2)
			{
			    a_line1 = 접속어1;			a_line1 += " …… ";		a_line1 += 접속어2_오답1;
			    a_line2 = 접속어1_오답1;		a_line2 += " …… ";		a_line2 += 접속어2_오답1;
			    a_line3 = 접속어1_오답2;		a_line3 += " …… ";		a_line3 += 접속어2_오답1;
			    a_line4 = 접속어1_오답1;		a_line4 += " …… ";		a_line4 += 접속어2;
			    a_line5 = 접속어1;			a_line5 += " …… ";		a_line5 += 접속어2;
		        정답_번 = "정답 ⑤번";
			}
			else if (접속어A보기들[2] == 접속어1 && 접속어B보기들[2] == 접속어2)
			{
			    a_line1 = 접속어1;			a_line1 += " …… ";		a_line1 += 접속어2_오답1;
			    a_line2 = 접속어1_오답2;		a_line2 += " …… ";		a_line2 += 접속어2_오답1;
			    a_line3 = 접속어1_오답1;		a_line3 += " …… ";		a_line3 += 접속어2_오답1;
			    a_line4 = 접속어1_오답2;		a_line4 += " …… ";		a_line4 += 접속어2;
			    a_line5 = 접속어1;			a_line5 += " …… ";		a_line5 += 접속어2;
		        정답_번 = "정답 ⑤번";
	        }

	        string s;
	        s = "<CAKE>\n";
	        s += "\t<Q> " + _현재번호 + ". 다음 글을 읽고, 빈칸에 들어갈 말로 가장 적절한 것을 고르시오. </Q>\r";


	        s += "\t<T>\n";
	        s += 본문;
	        s += "\n";
	        s += "\t</T>\n";
	        s += "\t<A>\n";
	        s += "\t<A0> (A) …… (B) </A0>\n";
	        s += "\t<A1> "; s += a_line1; s += " </A1>\n";
	        s += "\t<A2> "; s += a_line2; s += " </A2>\n";
	        s += "\t<A3> "; s += a_line3; s += " </A3>\n";
	        s += "\t<A4> "; s += a_line4; s += " </A4>\n";
	        s += "\t<A5> "; s += a_line5; s += " </A5>\n";
	        s += "\t</A>\n";

	        s += "\t<정답>\n";
	        s += "\t " + 정답_번 + "\n";
			s += "\t</정답>\n";
			s += "\t<해석>\n";
			s += "\t" + 해석 + "\n";
			s += "\t</해석>\n";
			s += "\t<해설>\n";
			s += "\t" + 접속어1 + ", " + 접속어2 + "\n";
			s += "\t</해설>\n";
			s += "</CAKE>\n";

            _현재번호++;
	        return s;
        }
        public static void 접속어_2개_분배(string 본문, ref string 접속어1, ref string 접속어2)
        {
            본문 = 본문.Replace("As a result of", "As_a_result_of");
            본문 = 본문.Replace("as a result of", "as_a_result_of");

	        string tmp1 = "";
	        string tmp2 = "";

	        int nF1, nF2;


            List<string> ar = new List<string>();

            // 전치사지만 추가함 
            ar.Add("Despite");
            ar.Add("despite");

			ar.Add("Also,");
			ar.Add("So,");
            ar.Add("For example");
	        ar.Add(" for example")		;
	        ar.Add("For instance")		;
	        ar.Add(" for instance")		;
	        ar.Add("Therefore")			;
	        ar.Add(" therefore")		;
	        ar.Add("In addition")		;
	        ar.Add(" in addition")		;
	        ar.Add("Moreover")			;
	        ar.Add(" moreover")			;
	        ar.Add("As a result")		;
	        ar.Add(" as a result")		;
	        ar.Add("At last")			;
	        ar.Add(" at last")			;
	        ar.Add("Besides")			;
	        ar.Add(" besides")			;
	        ar.Add("By the way")		;
	        ar.Add(" by the way")		;
	        ar.Add("However")			;
	        ar.Add(" however")			;
	        ar.Add("In a word")			;
	        ar.Add(" in a word")		;
	        ar.Add("In conclusion")		;
	        ar.Add(" in conclusion")	;
	        ar.Add("In fact")			;
	        ar.Add(" in fact")			;
	        ar.Add("On the other hand")	;
	        ar.Add(" on the other hand");
	        ar.Add("In the end")		;
	        ar.Add(" in the end")		;
	        ar.Add("In the long run")	;
	        ar.Add(" in the long run")	;
	        ar.Add("Nonetheless")		;
	        ar.Add(" nonetheless")		;
	        ar.Add("On the contrary")	;
	        ar.Add(" on the contrary")	;
	        ar.Add("On the other hand")	;
	        ar.Add(" on the other hand");
	        ar.Add("Furthermore")		;
	        ar.Add(" furthermore")		;
	        ar.Add("Although")			;
	        ar.Add(" although")			;
	        ar.Add("Nevertheless")		;
	        ar.Add(" nevertheless")		;
	        ar.Add(" Though ")			;
	        ar.Add(" though ")			;
	        ar.Add(" Though,")			;
	        ar.Add(" though,")			;
	        ar.Add(",Though,")			;
	        ar.Add(",though,")			;
	        ar.Add(" Though.")			;
	        ar.Add(" though.")			;
	        ar.Add(" Thus ")			;
	        ar.Add(" thus ")			;
	        ar.Add(" Thus,")			;
	        ar.Add(" thus,")			;
	        ar.Add(",Thus,")			;
	        ar.Add(",thus,")			;
	        ar.Add(" Thus.")			;
	        ar.Add(" thus.")			;


             foreach( string 현재접속사 in ar)
             {
                 if (본문.Contains(현재접속사))
                 {
                     if (tmp1 == "") tmp1 = 현재접속사; else tmp2 = 현재접속사;
                 }
             }


	        nF1 = 본문.IndexOf(tmp1);
            nF2 = 본문.IndexOf(tmp2);

	        if(nF1 < nF2)
	        {	접속어1 = tmp1; 접속어2 = tmp2;	}
	        else
	        {	접속어1 = tmp2; 접속어2 = tmp1;	}
        }
        
        // 접속어가 지문에 하나 포함 되었을 경우에 문제를 내는 함수
        public static string 접속어_1개_문제(string p, string 해석, string 정답번호, string A, string A1, string A2, string A3, string A4, string A5)
        {
            p = p.Replace("As a result of", "As_a_result_of");
            p = p.Replace("as a result of", "as_a_result_of");

            p = p.Trim();

	        string s;
            if (A.Length < 3) return "";

	        if(p.Contains(A) && (p.IndexOf(A) != 0))
	        {
		        string underline = "______";

		        if(A.Substring(0, 1) == " ") underline = " ______";
                if(A.Substring(0, 1) == ",") underline = ",______";

                if (A.Substring(A.Length - 1, 1) == " ") underline += " ";
		        if(A.Substring(A.Length - 1, 1) == ",") underline += ",";
                if (A.Substring(A.Length - 1, 1) == ".") underline += ".";


		        p = p.Replace(A, underline);

                p = p.Replace("As_a_result_of", "As a result of");
                p = p.Replace("as_a_result_of", "as a result of");

		        A = A.Replace(".", "");
		        A = A.Replace(",", "");



		        s = "<CAKE>\n";

		        s += "\t<Q> " + _현재번호 + ". 다음 글을 읽고, 빈칸에 들어갈 말로 가장 적절한 것을 고르시오. </Q>\r";

		        s += "\t<T>\n";
		        s += p;
		        s += "\n";
		        s += "\t</T>\n";
		        s += "\t<A>\n";
		        s += "\t<A1> "; s += A1; s += " </A1>\n";
		        s += "\t<A2> "; s += A2; s += " </A2>\n";
		        s += "\t<A3> "; s += A3; s += " </A3>\n";
		        s += "\t<A4> "; s += A4; s += " </A4>\n";
		        s += "\t<A5> "; s += A5; s += " </A5>\n";
		        s += "\t</A>\n";

		        s += "\t<정답>\n";
		        s += "\t정답 ";	s+= 정답번호;	s += "번\n";
				s += "\t</정답>\n";
				s += "\t<해석>\n";
				s += "\t" + 해석 + "\n";
				s += "\t</해석>\n";
				s += "\t<해설>\n";
				s += "\t" + A + "\n";
				s += "\t</해설>\n";
				s += "</CAKE>\n";

                _현재번호++;

	        }
	        else
		        return "";

            return s;
        }

        public static int 접속어_갯수_확인(string p)
        {
            // 접속어가 문장의 맨 처음에 나오는 경우 이를 맞출 방법이 없으므로,
            // 맨 처음에 문장이 나오는 경우에는 문제를 내지 않습니다.
            p = p.Replace("As a result of", "이건내면안됨");
            p = p.Replace("as a result of", "이건내면안됨");

            p = p.Trim();
	        int n = 0;

			if (p.Contains("Also,") && (p.IndexOf("Also,") != 0)) n++; // Also도 대문자는 낼만 함
			if (p.Contains("So,") && (p.IndexOf("So,") != 0)) n++; // So도 대문자는 낼만 함

            if (p.Contains("Despite")               ) n++; // Despite는 전치사지만 낼만 함
            if (p.Contains("despite")) n++; // Despite는 전치사지만 낼만 함

            if (p.Contains("For example") && (p.IndexOf("For example") != 0)) n++;
	        if(p.Contains(" for example")			) n++;
	        if(p.Contains("For instance")			&& (p.IndexOf("For instance") != 0)) n++;
	        if(p.Contains(" for instance")			) n++;
	        if(p.Contains("Therefore")				&& (p.IndexOf("Therefore") != 0)) n++;
	        if(p.Contains(" therefore")				) n++;
	        if(p.Contains("In addition")			&& (p.IndexOf("In addition") != 0)) n++;
	        if(p.Contains(" in addition")			) n++;
	        if(p.Contains("Moreover")				&& (p.IndexOf("Moreover") != 0)) n++;
	        if(p.Contains(" moreover")				) n++;
	        if(p.Contains("As a result")			&& (p.IndexOf("As a result") != 0)) n++;
	        if(p.Contains(" as a result")			) n++;
	        if(p.Contains("At last")				&& (p.IndexOf("At last") != 0)) n++;
	        if(p.Contains(" at last")				) n++;
	        if(p.Contains("Besides")				&& (p.IndexOf("Besides") != 0)) n++;			
	        if(p.Contains(" besides")				) n++;			
	        if(p.Contains("By the way")				&& (p.IndexOf("By the way") != 0)) n++;
	        if(p.Contains(" by the way")				) n++;		
	        if(p.Contains("However")				&& (p.IndexOf("However") != 0)) n++;
	        if(p.Contains(" however")				) n++;			
	        if(p.Contains("In a word")				&& (p.IndexOf("In a word") != 0)) n++;		
	        if(p.Contains(" in a word")				) n++;		
	        if(p.Contains("In conclusion")			&& (p.IndexOf("In conclusion") != 0)) n++;	
	        if(p.Contains(" in conclusion")			) n++;	
	        if(p.Contains("In fact")				&& (p.IndexOf("In fact") != 0)) n++;
	        if(p.Contains(" in fact")				) n++;			
	        if(p.Contains("In the end")				&& (p.IndexOf("In the end") != 0)) n++;		
	        if(p.Contains(" in the end")				) n++;		
	        if(p.Contains("In the long run")		&& (p.IndexOf("In the long run") != 0)) n++;	
	        if(p.Contains(" in the long run")		) n++;	
	        if(p.Contains("Nonetheless")			&& (p.IndexOf("Nonetheless") != 0)) n++;		
	        if(p.Contains(" nonetheless")			) n++;		
	        if(p.Contains("On the contrary")		&& (p.IndexOf("On the contrary") != 0)) n++;	
	        if(p.Contains(" on the contrary")		) n++;	
	        if(p.Contains("On the other hand")		&& (p.IndexOf("On the other hand") != 0)) n++;
	        if(p.Contains(" on the other hand")		) n++;
	        if(p.Contains("Furthermore")			&& (p.IndexOf("Furthermore") != 0)) n++;
	        if(p.Contains(" furthermore")			) n++;		
	        if(p.Contains("Although")				&& (p.IndexOf("Although") != 0)) n++;			
	        if(p.Contains(" although")				) n++;			
	        if(p.Contains("Nevertheless")			&& (p.IndexOf("Nevertheless") != 0)) n++;		
	        if(p.Contains(" nevertheless")			) n++;		
	        if(p.Contains(" Though ")				) n++;			
	        if(p.Contains(" though ")				) n++;			
	        if(p.Contains(" Though,")				) n++;
	        if(p.Contains(" though,")				) n++;
	        if(p.Contains(",Though,")				) n++;
	        if(p.Contains(",though,")				) n++;
	        if(p.Contains(" Though.")				) n++;	
	        if(p.Contains(" though.")				) n++;	
	        if(p.Contains(" Thus ")					) n++;			
	        if(p.Contains(" thus ")					) n++;			
	        if(p.Contains(" Thus,")					) n++;
	        if(p.Contains(" thus,")					) n++;
	        if(p.Contains(",Thus,")					) n++;
	        if(p.Contains(",thus,")					) n++;
	        if(p.Contains(" Thus.")					) n++;	
	        if(p.Contains(" thus.")					) n++;	


	        return n;

        }
        #endregion
        #region 문장삽입
        public static string 문장삽입(string 본문, string 해석)
        {
			List<string> 문장삽입문제리스트 = new List<string>();
			문장삽입문제리스트.Add("However");
			문장삽입문제리스트.Add("however");
			문장삽입문제리스트.Add("For example");
			문장삽입문제리스트.Add("for example");
			문장삽입문제리스트.Add("was the answer");
			문장삽입문제리스트.Add("This was a mistake");
			문장삽입문제리스트.Add("But ");
			문장삽입문제리스트.Add("Yet ");
			문장삽입문제리스트.Add("But,");
			문장삽입문제리스트.Add("Yet,");
			문장삽입문제리스트.Add("This ");
			문장삽입문제리스트.Add("These ");
			문장삽입문제리스트.Add("Moreover");
			문장삽입문제리스트.Add("Furthermore");

			string 출제결과 = "";
			
			for(int i = 0 ; i < 문장삽입문제리스트.Count(); i++)
			{
				출제결과 += 문장삽입문제출제(문장삽입문제리스트[i], 본문, 해석);
			}

			return 출제결과;
        }

		public static string 문장삽입문제출제(string 대개는접속어, string 본문, string 해석)
		{
			string 출제결과 = "<CAKE>\r";

            if(대개는접속어 == "This ")
            {
                if (본문.StartsWith("This ")) return "";
            }

			if (대개는접속어 == "Moreover" || 대개는접속어 == "Furthermore")
				출제결과 += "\t<Q> " + _현재번호 + ". 글의 흐름으로 보아, 주어진 문장이 들어가기에 가장 적절한 곳은?▼ </Q>\r";
			else
				출제결과 += "\t<Q> " + _현재번호 + ". 글의 흐름으로 보아, 주어진 문장이 들어가기에 가장 적절한 곳은? </Q>\r";

			출제결과 += "\t<T>\r\t";

			if(!본문.Contains(대개는접속어)) return "";

			List<string> 문 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(본문, ref 문);
			if(문.Count() < 5) return "";



			string 접 = 대개는접속어; 
			string TB = "\r\t<TBAR></TBAR>\r\t";
			string T끝 = "\r\t</T>\r\t<정답>\r\t정답 ";
			#region 5
			if(문.Count() == 5)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) "+문[1]+" ( ② ) "+문[2]+" ( ③ ) "+문[3]+" ( ④ ) "+문[4]+" ( ⑤ )" + T끝 + "①";}
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + "( ① ) " + 문[0] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " ( ⑤ )" + T끝 + "②"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + "( ① ) " + 문[0] + " ( ② ) " + 문[1] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " ( ⑤ )" + T끝 + "③"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + "( ① ) " + 문[0] + " ( ② ) " + 문[1] + " ( ③ ) " + 문[2] + " ( ④ ) " + 문[4] + " ( ⑤ )" + T끝 + "④"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + "( ① ) " + 문[0] + " ( ② ) " + 문[1] + " ( ③ ) " + 문[2] + " ( ④ ) " + 문[3] + " ( ⑤ )" + T끝 + "⑤"; }
			}
			#endregion
			#region 6
			else if(문.Count() == 6)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " ( ⑤ ) " + 문[5] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + "( ① ) " + 문[0] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " ( ⑤ ) " + 문[5] + T끝 + "②"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + "( ① ) " + 문[0] + " ( ② ) " + 문[1] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " ( ⑤ ) " + 문[5] + T끝 + "③"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + "( ① ) " + 문[0] + " ( ② ) " + 문[1] + " ( ③ ) " + 문[2] + " ( ④ ) " + 문[4] + " ( ⑤ ) " + 문[5] + T끝 + "④"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + "( ① ) " + 문[0] + " ( ② ) " + 문[1] + " ( ③ ) " + 문[2] + " ( ④ ) " + 문[3] + " ( ⑤ ) " + 문[5] + T끝 + "⑤"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 7
			else if(문.Count() == 7)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " ( ⑤ ) " + 문[5] + " " + 문[6] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + " ( ② ) " + 문[3] + " ( ③ ) " + 문[4] + " ( ④ ) " + 문[5] + " ( ⑤ ) " + 문[6] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[3] + " ( ③ ) " + 문[4] + " ( ④ ) " + 문[5] + " ( ⑤ ) " + 문[6] + T끝 + "②"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[4] + " ( ④ ) " + 문[5] + " ( ⑤ ) " + 문[6] + T끝 + "③"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[5] + " ( ⑤ ) " + 문[6] + T끝 + "④"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " ( ⑤ ) " + 문[6] + T끝 + "⑤"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " " + 문[5] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 8
			else if (문.Count() == 8)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + " ( ② ) " + 문[3] + " ( ③ ) " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[3] + " ( ③ ) " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + T끝 + "②"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + T끝 + "③"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + T끝 + "④"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " ( ⑤ ) " + 문[6] + " " + 문[7] + T끝 + "⑤"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " " + 문[5] + " ( ⑤ ) " + 문[7] + T끝 + "⑤"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 9
			else if (문.Count() == 9)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + " " + 문[8] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + " ( ② ) " + 문[3] + " ( ③ ) " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + " " + 문[8] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[3] + " ( ③ ) " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + " " + 문[8] + T끝 + "②"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + " " + 문[8] + T끝 + "③"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[7] + " " + 문[8] + T끝 + "④"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " " + 문[4] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[8] + T끝 + "④"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " ( ④ ) " + 문[4] + " " + 문[5] + " ( ⑤ ) " + 문[7] + " " + 문[8] + T끝 + "⑤"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[8] + T끝 + "⑤"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 10
			else if (문.Count() == 10)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[8] + " " + 문[9] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + " ( ② ) " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[8] + " " + 문[9] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[8] + " " + 문[9] + T끝 + "②"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[4] + " ( ③ ) " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[8] + " " + 문[9] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[8] + " " + 문[9] + T끝 + "③"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " " + 문[4] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[8] + " " + 문[9] + T끝 + "④"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + T끝 + "④"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " ( ③ ) " + 문[3] + " " + 문[4] + " ( ④ ) " + 문[5] + " " + 문[6] + " ( ⑤ ) " + 문[8] + " " + 문[9] + T끝 + "⑤"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[9] + T끝 + "⑤"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " " + 문[8] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 11
			else if (문.Count() == 11)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + T끝 + "②"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + T끝 + "③"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + T끝 + "③"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + T끝 + "④"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + T끝 + "④"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[9] + " " + 문[10] + T끝 + "⑤"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[10] + T끝 + "⑤"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[8] + " " + 문[9] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 12
			else if (문.Count() == 12)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + " " + 문[11] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + " " + 문[11] + T끝 + "②"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + " " + 문[11] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + " " + 문[11] + T끝 + "③"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + " " + 문[11] + T끝 + "③"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[9] + " " + 문[10] + " " + 문[11] + T끝 + "④"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + T끝 + "④"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[9] + " " + 문[10] + " " + 문[11] + T끝 + "⑤"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[10] + " " + 문[11] + T끝 + "⑤"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[11] + T끝 + "⑤"; }
				else if (문[11].Contains(접)) { 출제결과 += 문[11] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[8] + " " + 문[9] + " " + 문[10] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 13
			else if (문.Count() == 13)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "②"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "③"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "③"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "④"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "④"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " ( ③ ) " + 문[4] + " " + 문[5] + " ( ④ ) " + 문[6] + " " + 문[7] + " ( ⑤ ) " + 문[9] + " " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "⑤"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[5] + " " + 문[6] + " ( ④ ) " + 문[7] + " " + 문[8] + " ( ⑤ ) " + 문[10] + " " + 문[11] + " " + 문[12] + T끝 + "⑤"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[8] + " " + 문[9] + " ( ⑤ ) " + 문[11] + " " + 문[12] + T끝 + "⑤"; }
				else if (문[11].Contains(접)) { 출제결과 += 문[11] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[8] + " " + 문[9] + " " + 문[10] + " ( ⑤ ) " + 문[12] + T끝 + "⑤"; }
				else if (문[12].Contains(접)) { 출제결과 += 문[12] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " " + 문[8] + " ( ④ ) " + 문[9] + " " + 문[10] + " " + 문[11] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 14
			else if (문.Count() == 14)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " " + 문[2] + " " + 문[3] + " " + 문[4] + " ( ② ) " + 문[5] + " " + 문[6] + " " + 문[7] + " " + 문[8] + " ( ③ ) " + 문[9] + " " + 문[10] + " ( ④ ) " + 문[11] + " " + 문[12] + " ( ⑤ ) " + 문[13] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + " " + 문[3] + " " + 문[4] + " " + 문[5] + " ( ② ) " + 문[6] + " " + 문[7] + " ( ③ ) " + 문[8] + " " + 문[9] + " ( ④ ) " + 문[10] + " " + 문[11] + " ( ⑤ ) " + 문[12] + " " + 문[13] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[3] + " " + 문[4] + " " + 문[5] + " " + 문[6] + " ( ② ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ③ ) " + 문[10] + " " + 문[11] + " ( ④ ) " + 문[12] + " " + 문[13] + " ( ⑤ ) " + T끝 + "①"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[4] + " " + 문[5] + " " + 문[6] + " ( ③ ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ④ ) " + 문[10] + " " + 문[11] + " " + 문[12] + " ( ⑤ ) " + 문[13] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " " + 문[3] + " ( ② ) " + 문[5] + " " + 문[6] + " " + 문[7] + " ( ③ ) " + 문[8] + " " + 문[9] + " " + 문[10] + " ( ④ ) " + 문[11] + " " + 문[12] + " " + 문[13] + " ( ⑤ ) " + T끝 + "②"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " ( ③ ) " + 문[6] + " " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ④ ) " + 문[10] + " " + 문[11] + " " + 문[12] + " ( ⑤ ) " + 문[13] + T끝 + "③"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ④ ) " + 문[10] + " " + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + T끝 + "③"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " " + 문[5] + " " + 문[6] + " ( ③ ) " + 문[8] + " " + 문[9] + " " + 문[10] + " " + 문[11] + " ( ④ ) " + 문[12] + " " + 문[13] + " ( ⑤ ) " + T끝 + "③"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + " " + 문[3] + " " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[9] + " " + 문[10] + " " + 문[11] + " " + 문[12] + " ( ⑤ ) " + 문[13] + T끝 + "④"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[3] + " " + 문[4] + " " + 문[5] + " " + 문[6] + " ( ③ ) " + 문[7] + " " + 문[8] + " ( ④ ) " + 문[10] + " " + 문[11] + " " + 문[12] + " " + 문[13] + " ( ⑤ ) " + T끝 + "④"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ④ ) " + 문[11] + " " + 문[12] + " " + 문[13] + " ( ⑤ ) " + T끝 + "④"; }
				else if (문[11].Contains(접)) { 출제결과 += 문[11] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " ( ④ ) " + 문[8] + " " + 문[9] + " " + 문[10] + " ( ⑤ ) " + 문[12] + " " + 문[13] + T끝 + "⑤"; }
				else if (문[12].Contains(접)) { 출제결과 += 문[12] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " " + 문[8] + " ( ④ ) " + 문[9] + " " + 문[10] + " " + 문[11] + " ( ⑤ ) " + 문[13] + T끝 + "⑤"; }
				else if (문[13].Contains(접)) { 출제결과 += 문[13] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[2] + " " + 문[3] + " ( ② ) " + 문[4] + " " + 문[5] + " ( ③ ) " + 문[6] + " " + 문[7] + " " + 문[8] + " ( ④ ) " + 문[9] + " " + 문[10] + " " + 문[11] + " " + 문[12] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 15
			else if (문.Count() == 15)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + " " + 문[2] + " " + 문[3] + " " + 문[4] + " ( ② ) " + 문[5] + " " + 문[6] + " " + 문[7] + " " + 문[8] + " ( ③ ) " + 문[9] + " " + 문[10] + " ( ④ ) " + 문[11] + " " + 문[12] + " ( ⑤ ) " + 문[13] + " " + 문[14] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + " " + 문[3] + " " + 문[4] + " " + 문[5] + " ( ② ) " + 문[6] + " " + 문[7] + " ( ③ ) " + 문[8] + " " + 문[9] + " ( ④ ) " + 문[10] + " " + 문[11] + " ( ⑤ ) " + 문[12] + " " + 문[13] + " " + 문[14] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + " " + 문[1] + " ( ① ) " + 문[3] + " " + 문[4] + " " + 문[5] + " " + 문[6] + " ( ② ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ③ ) " + 문[10] + " " + 문[11] + " ( ④ ) " + 문[12] + " " + 문[13] + " ( ⑤ ) " + 문[14] + T끝 + "①"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " ( ② ) " + 문[4] + " " + 문[5] + " " + 문[6] + " ( ③ ) " + 문[7] + " " + 문[8] + " " + 문[9] + " ( ④ ) " + 문[10] + " " + 문[11] + " " + 문[12] + " ( ⑤ ) " + 문[13] + " " + 문[14] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + " " + 문[2] + " " + 문[3] + " ( ② ) " + 문[5] + " " + 문[6] + " " + 문[7] + " ( ③ ) " + 문[8] + " " + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + T끝 + "②"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + T끝 + "③"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ③ ) " + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + T끝 + "③"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + T끝 + "③"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + T끝 + "④"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[7] + 문[8] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + T끝 + "④"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + T끝 + "④"; }
				else if (문[11].Contains(접)) { 출제결과 += 문[11] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + " ( ④ ) " + 문[8] + 문[9] + 문[10] + " ( ⑤ ) " + 문[12] + 문[13] + 문[14] + T끝 + "⑤"; }
				else if (문[12].Contains(접)) { 출제결과 += 문[12] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + " ( ⑤ ) " + 문[13] + 문[14] + T끝 + "⑤"; }
				else if (문[13].Contains(접)) { 출제결과 += 문[13] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[14] + T끝 + "⑤"; }
				else if (문[14].Contains(접)) { 출제결과 += 문[14] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 16
			else if (문.Count() == 16)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + 문[8] + " ( ③ ) " + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + " ( ⑤ ) " + 문[12] + 문[13] + 문[14] + 문[15] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + 문[1] + " ( ① ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ② ) " + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + T끝 + "①"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + " ( ② ) " + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + T끝 + "②"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + T끝 + "③"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ③ ) " + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + T끝 + "③"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + T끝 + "③"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + T끝 + "④"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[7] + 문[8] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + T끝 + "④"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + T끝 + "④"; }
				else if (문[11].Contains(접)) { 출제결과 += 문[11] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + " ( ④ ) " + 문[8] + 문[9] + 문[10] + " ( ⑤ ) " + 문[12] + 문[13] + 문[14] + 문[15] + T끝 + "⑤"; }
				else if (문[12].Contains(접)) { 출제결과 += 문[12] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + T끝 + "⑤"; }
				else if (문[13].Contains(접)) { 출제결과 += 문[13] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[14] + 문[15] + T끝 + "⑤"; }
				else if (문[14].Contains(접)) { 출제결과 += 문[14] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[15] + T끝 + "⑤"; }
				else if (문[15].Contains(접)) { 출제결과 += 문[15] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 17
			else if (문.Count() == 17)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + 문[8] + " ( ③ ) " + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[15] + 문[16] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + 문[1] + " ( ① ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ② ) " + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + T끝 + "①"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + 문[16] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + " ( ② ) " + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + T끝 + "②"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + 문[16] + T끝 + "③"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ③ ) " + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + 문[16] + T끝 + "③"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + T끝 + "③"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + 문[16] + T끝 + "④"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[7] + 문[8] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + T끝 + "④"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + T끝 + "④"; }
				else if (문[11].Contains(접)) { 출제결과 += 문[11] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + T끝 + "④"; }
				else if (문[12].Contains(접)) { 출제결과 += 문[12] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + 문[16] + T끝 + "⑤"; }
				else if (문[13].Contains(접)) { 출제결과 += 문[13] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + T끝 + "⑤"; }
				else if (문[14].Contains(접)) { 출제결과 += 문[14] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[15] + 문[16] + T끝 + "⑤"; }
				else if (문[15].Contains(접)) { 출제결과 += 문[15] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[16] + T끝 + "⑤"; }
				else if (문[16].Contains(접)) { 출제결과 += 문[16] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 18
			else if (문.Count() == 18)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + 문[8] + " ( ③ ) " + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + 문[1] + " ( ① ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ② ) " + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + T끝 + "①"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + " ( ② ) " + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "②"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "③"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ③ ) " + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "③"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "③"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + T끝 + "③"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[7] + 문[8] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "④"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "④"; }
				else if (문[11].Contains(접)) { 출제결과 += 문[11] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + T끝 + "④"; }
				else if (문[12].Contains(접)) { 출제결과 += 문[12] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + " ( ⑤ ) " + 문[13] + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "⑤"; }
				else if (문[13].Contains(접)) { 출제결과 += 문[13] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + T끝 + "⑤"; }
				else if (문[14].Contains(접)) { 출제결과 += 문[14] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + T끝 + "⑤"; }
				else if (문[15].Contains(접)) { 출제결과 += 문[15] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[16] + 문[17] + T끝 + "⑤"; }
				else if (문[16].Contains(접)) { 출제결과 += 문[16] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[17] + T끝 + "⑤"; }
				else if (문[17].Contains(접)) { 출제결과 += 문[17] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + 문[16] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 19
			else if (문.Count() == 19)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + 문[8] + " ( ③ ) " + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + 문[18] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + 문[1] + " ( ① ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ② ) " + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + T끝 + "①"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + " ( ② ) " + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + 문[18] + T끝 + "②"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ④ ) " + 문[14] + 문[15] + 문[16] + 문[17] + " ( ⑤ ) " + 문[18] + T끝 + "②"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ③ ) " + 문[7] + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + 문[18] + T끝 + "③"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + T끝 + "③"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + T끝 + "③"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + 문[8] + " ( ③ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ④ ) " + 문[14] + 문[15] + 문[16] + 문[17] + " ( ⑤ ) " + 문[18] + T끝 + "③"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + 문[18] + T끝 + "④"; }
				else if (문[11].Contains(접)) { 출제결과 += 문[11] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + T끝 + "④"; }
				else if (문[12].Contains(접)) { 출제결과 += 문[12] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + 문[8] + " ( ③ ) " + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + T끝 + "④"; }
				else if (문[13].Contains(접)) { 출제결과 += 문[13] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + 문[18] + T끝 + "⑤"; }
				else if (문[14].Contains(접)) { 출제결과 += 문[14] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + 문[18] + T끝 + "⑤"; }
				else if (문[15].Contains(접)) { 출제결과 += 문[15] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + T끝 + "⑤"; }
				else if (문[16].Contains(접)) { 출제결과 += 문[16] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[17] + 문[18] + T끝 + "⑤"; }
				else if (문[17].Contains(접)) { 출제결과 += 문[17] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ④ ) " + 문[14] + 문[15] + 문[16] + " ( ⑤ ) " + 문[18] + T끝 + "⑤"; }
				else if (문[18].Contains(접)) { 출제결과 += 문[18] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ④ ) " + 문[14] + 문[15] + 문[16] + 문[17] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			#region 20
			else if (문.Count() == 20)
			{
				if (문[0].Contains(접)) { 출제결과 += 문[0] + TB + "( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + 문[8] + " ( ③ ) " + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "①"; }
				else if (문[1].Contains(접)) { 출제결과 += 문[1] + TB + 문[0] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "①"; }
				else if (문[2].Contains(접)) { 출제결과 += 문[2] + TB + 문[0] + 문[1] + " ( ① ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ② ) " + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "①"; }
				else if (문[3].Contains(접)) { 출제결과 += 문[3] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "②"; }
				else if (문[4].Contains(접)) { 출제결과 += 문[4] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + " ( ② ) " + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "②"; }
				else if (문[5].Contains(접)) { 출제결과 += 문[5] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ④ ) " + 문[14] + 문[15] + 문[16] + 문[17] + " ( ⑤ ) " + 문[18] + 문[19] + T끝 + "②"; }
				else if (문[6].Contains(접)) { 출제결과 += 문[6] + TB + 문[0] + " ( ① ) " + 문[1] + " ( ② ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ③ ) " + 문[7] + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "③"; }
				else if (문[7].Contains(접)) { 출제결과 += 문[7] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + " ( ② ) " + 문[3] + 문[4] + 문[5] + 문[6] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "③"; }
				else if (문[8].Contains(접)) { 출제결과 += 문[8] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "③"; }
				else if (문[9].Contains(접)) { 출제결과 += 문[9] + TB + 문[0] + " ( ① ) " + 문[1] + 문[2] + 문[3] + 문[4] + " ( ② ) " + 문[5] + 문[6] + 문[7] + 문[8] + " ( ③ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ④ ) " + 문[14] + 문[15] + 문[16] + 문[17] + " ( ⑤ ) " + 문[18] + 문[19] + T끝 + "③"; }
				else if (문[10].Contains(접)) { 출제결과 += 문[10] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "④"; }
				else if (문[11].Contains(접)) { 출제결과 += 문[11] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "④"; }
				else if (문[12].Contains(접)) { 출제결과 += 문[12] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + 문[8] + " ( ③ ) " + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "④"; }
				else if (문[13].Contains(접)) { 출제결과 += 문[13] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + " ( ④ ) " + 문[9] + 문[10] + 문[11] + 문[12] + " ( ⑤ ) " + 문[14] + 문[15] + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "⑤"; }
				else if (문[14].Contains(접)) { 출제결과 += 문[14] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + " ( ③ ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ④ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ⑤ ) " + 문[15] + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "⑤"; }
				else if (문[15].Contains(접)) { 출제결과 += 문[15] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + " ( ④ ) " + 문[11] + 문[12] + 문[13] + 문[14] + " ( ⑤ ) " + 문[16] + 문[17] + 문[18] + 문[19] + T끝 + "⑤"; }
				else if (문[16].Contains(접)) { 출제결과 += 문[16] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + " ( ② ) " + 문[4] + 문[5] + 문[6] + 문[7] + " ( ③ ) " + 문[8] + 문[9] + 문[10] + 문[11] + " ( ④ ) " + 문[12] + 문[13] + 문[14] + 문[15] + " ( ⑤ ) " + 문[17] + 문[18] + 문[19] + T끝 + "⑤"; }
				else if (문[17].Contains(접)) { 출제결과 += 문[17] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ④ ) " + 문[14] + 문[15] + 문[16] + " ( ⑤ ) " + 문[18] + 문[19] + T끝 + "⑤"; }
				else if (문[18].Contains(접)) { 출제결과 += 문[18] + TB + 문[0] + 문[1] + " ( ① ) " + 문[2] + 문[3] + 문[4] + 문[5] + " ( ② ) " + 문[6] + 문[7] + 문[8] + 문[9] + " ( ③ ) " + 문[10] + 문[11] + 문[12] + 문[13] + " ( ④ ) " + 문[14] + 문[15] + 문[16] + 문[17] + 문[18] + " ( ⑤ ) " + T끝 + "⑤"; }
			}
			#endregion
			else
			{
				return "";
			}

			출제결과 += "번\r";
			출제결과 += "\t</정답>\r";
			출제결과 += "\t<해석>\r";
			출제결과 += 해석 + "\r";
			출제결과 += "\t</해석>\r";
			출제결과 += "</CAKE>\r";

			return 출제결과;
		}

		
        public static void 문장삽입_Q(List<string> 적절하게나뉜문장들, ref string q, ref string r)
        {
	        int q1 = 0,q2 = 0,q3 = 0,q4 = 0,q5 = 0, nr = 0;

	        // 현재 q에 들어갈 것은 보기가 되는 문장입니다.
	        q = 문장삽입_Core(적절하게나뉜문장들, ref q1,ref q2,ref q3,ref q4,ref q5, ref nr);			q += "\r";
	        // 문제가 생성되지 않았음을 의미합니다.
	        if(nr == 0) {r = ""; return;}

	        q += "\t<TBAR></TBAR>\r\n";							q += "\t";

	        for(int i = 0; i < 적절하게나뉜문장들.Count() + 1; i++)
	        {
		        if(i == q1) q += " ( ① ) ";
		        if(i == q2) q += " ( ② ) ";
		        if(i == q3) q += " ( ③ ) ";
		        if(i == q4) q += " ( ④ ) ";
		        if(i == q5) q += " ( ⑤ ) ";

		        if(i != 적절하게나뉜문장들.Count()){	q += " ";	q += 적절하게나뉜문장들[i];}
	        }

	        if(nr == 1)		  r = string.Format("\t정답 ①번");
            else if (nr == 2) r = string.Format("\t정답 ②번");
            else if (nr == 3) r = string.Format("\t정답 ③번");
            else if (nr == 4) r = string.Format("\t정답 ④번");
            else if (nr == 5) r = string.Format("\t정답 ⑤번");
        }
        // r : 정답
        public static string 문장삽입_Core(List<string> rr, ref int q1, ref int q2, ref int q3, ref int q4, ref int q5, ref int r)
        {
	        int				n_right_answer = -1;
	        string			s_right_answer = "";

            List<string> t_rr = new List<string>();

	        for(int i = 0 ; i < rr.Count() ;i++)
	        {
		        if(n_right_answer == -1) // 올바른 정답이 구해지지 않았을 경우에만 들어간다. 이게 한 지문에 However가 두 번 들어가면 이 곳 때문에 헷갈린다.
		        {
			        if(문장삽입_Check(rr[i]))	{s_right_answer = rr[i]; n_right_answer = i;}
			        else							t_rr.Add(rr[i]);
		        }
		        else
			        t_rr.Add(rr[i]);
	        }

	        rr.Clear();

	        for(int i = 0 ; i < t_rr.Count() ; i++) 	rr.Add(t_rr[i]);

	        r = 문장삽입_NUM_cvt((int)rr.Count(), ref q1, ref q2, ref q3, ref q4, ref q5, n_right_answer);

	        return	s_right_answer.Trim();
        }
        public static int 문장삽입_NUM_cvt(int n, ref int nq1, ref int nq2, ref int nq3, ref int nq4, ref int nq5, int n_right_answer)
        {
	        int r = 0;
	        if(		n == 4){	nq1 = 0; nq2 = 1; nq3 = 2; nq4 = 3; nq5 = 4; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}}
	        else if(n == 5){	nq1 = 1; nq2 = 2; nq3 = 3; nq4 = 4; nq5 = 5; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 0; nq2 = 1; nq3 = 2; nq4 = 3; nq5 = 5; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}}
            else if (n == 6){   nq1 = 1; nq2 = 2; nq3 = 3; nq4 = 4; nq5 = 5; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 0; nq2 = 1; nq3 = 2; nq4 = 4; nq5 = 6; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}}
            else if (n == 7){   nq1 = 2; nq2 = 3; nq3 = 4; nq4 = 5; nq5 = 6; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 1; nq2 = 2; nq3 = 3; nq4 = 5; nq5 = 7; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 0; nq2 = 2; nq3 = 3; nq4 = 5; nq5 = 7; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}}
            else if (n == 8){   nq1 = 3; nq2 = 4; nq3 = 5; nq4 = 6; nq5 = 7; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 1; nq2 = 3; nq3 = 4; nq4 = 5; nq5 = 6; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 0; nq2 = 2; nq3 = 4; nq4 = 6; nq5 = 8; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}}
            else if (n == 9){   nq1 = 0; nq2 = 2; nq3 = 4; nq4 = 6; nq5 = 8; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 1; nq2 = 3; nq3 = 5; nq4 = 7; nq5 = 9; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}}
            else if (n == 10){  nq1 = 0; nq2 = 2; nq3 = 4; nq4 = 6; nq5 = 8; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 1; nq2 = 3; nq3 = 5; nq4 = 7; nq5 = 9; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 1; nq2 = 3; nq3 = 5; nq4 = 7; nq5 = 10;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}}
            else if (n == 11){  nq1 = 0; nq2 = 2; nq3 = 4; nq4 = 6; nq5 = 9; if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 1; nq2 = 3; nq3 = 5; nq4 = 7; nq5 = 10;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}
                                nq1 = 1; nq2 = 3; nq3 = 5; nq4 = 8; nq5 = 11;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r;}}
            else if (n == 12){  nq1 = 0; nq2 = 2; nq3 = 4; nq4 = 7; nq5 = 10;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 3; nq3 = 5; nq4 = 8; nq5 = 11;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 3; nq3 = 6; nq4 = 9; nq5 = 12;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }}
            else if (n == 13){  nq1 = 0; nq2 = 2; nq3 = 5; nq4 = 8; nq5 = 11;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 3; nq3 = 6; nq4 = 9; nq5 = 12;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 4; nq3 = 7; nq4 = 10;nq5 = 13;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }}
            else if (n == 14){  nq1 = 0; nq2 = 3; nq3 = 6; nq4 = 9; nq5 = 12;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 4; nq3 = 7; nq4 = 10;nq5 = 13;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 5; nq3 = 8; nq4 = 11;nq5 = 14;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }}
            else if (n == 15){  nq1 = 0; nq2 = 3; nq3 = 6; nq4 = 9; nq5 = 12;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 4; nq3 = 7; nq4 = 10;nq5 = 13;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 5; nq3 = 8; nq4 = 11;nq5 = 14;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 5; nq3 = 8; nq4 = 11;nq5 = 15;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }}
            else if (n == 16){  nq1 = 0; nq2 = 3; nq3 = 6; nq4 = 9; nq5 = 13;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 4; nq3 = 7; nq4 = 10;nq5 = 14;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 5; nq3 = 8; nq4 = 11;nq5 = 15;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 5; nq3 = 8; nq4 = 12;nq5 = 16;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }}
            else if (n == 17){  nq1 = 0; nq2 = 3; nq3 = 6; nq4 = 10;nq5 = 14;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 4; nq3 = 7; nq4 = 11;nq5 = 15;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 5; nq3 = 8; nq4 = 12;nq5 = 16;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 5; nq3 = 9; nq4 = 13;nq5 = 17;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }}
            else if (n == 18){  nq1 = 0; nq2 = 3; nq3 = 7; nq4 = 11;nq5 = 15;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 4; nq3 = 8; nq4 = 12;nq5 = 16;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 5; nq3 = 9; nq4 = 13;nq5 = 17;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 6; nq3 = 10; nq4 = 14;nq5 = 18;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }}
            else if (n == 19){  nq1 = 0; nq2 = 4; nq3 = 8; nq4 = 12;nq5 = 16;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 5; nq3 = 9; nq4 = 13;nq5 = 17;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 6; nq3 = 10; nq4 = 14;nq5 = 18;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 3; nq2 = 7; nq3 = 11;nq4 = 15;nq5 = 19;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }}
            else if (n == 20){  nq1 = 0; nq2 = 4; nq3 = 8; nq4 = 12;nq5 = 16;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 1; nq2 = 5; nq3 = 9; nq4 = 13;nq5 = 17;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 2; nq2 = 6; nq3 = 10; nq4 = 14;nq5 = 18;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 3; nq2 = 7; nq3 = 11;nq4 = 15;nq5 = 19;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }
                                nq1 = 3; nq2 = 7; nq3 = 11;nq4 = 15;nq5 = 29;if(문장삽입_Q_Index(nq1, nq2, nq3, nq4, nq5, n_right_answer, ref r)) { return r; }}
            
            else if (n > 20) { MessageBox.Show(string.Format("접속어 문제로 내기에 너무 지문이 깁니다. 문장이 {0}개가 있습니다.", n)); }

	        return 0;
        }
        // q1 : 본문에서 1번에 해당하는 빈칸이, 실제로는 몇 번째 문장인지.
        // n_right_answer : 정답 문장이,		실제로는 몇 번째 문장인지.
        // r  : 결과적으로 정답은 몇 번이 되는지 가르쳐 준다.
        public static bool 문장삽입_Q_Index(int q1, int q2, int q3, int q4, int q5, int n_right_answer, ref int r)
        {
	        if(q1 == n_right_answer){ r = 1; return true;}
	        if(q2 == n_right_answer){ r = 2; return true;}
	        if(q3 == n_right_answer){ r = 3; return true;}
	        if(q4 == n_right_answer){ r = 4; return true;}
	        if(q5 == n_right_answer){ r = 5; return true;}

	        return false;
        }
        public static bool 문장삽입_Check(string w)
        {
            변환.문자열.문장부호제거(w);

			if (w.Contains("Moreover")) return true;
			if (w.Contains("Furthermore")) return true;


            if(w.Contains("However"	))	return true;
            if(w.Contains("however")) return true;
            if(w.Contains("For example")) return true;
        	if(w.Contains("for example"))	return true;
            if(w.Contains("was the answer")) return true;
            if(w.Contains("This was a mistake")) return true;	// 교과서 지문

	        if(변환.문자열.Left(w, 4) == "But ") return true;
            if(변환.문자열.Left(w, 4) == "Yet ") return true;
            if(변환.문자열.Left(w, 5) == "This ") return true;
            if(변환.문자열.Left(w, 6) == "These ") return true;

	        return false;
        }
        public static bool 문장삽입_01_문제낼수있는지확인(string p, ref List<string> rr)
        {
	        bool	b = false;
            List<string> 문장들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(p, ref 문장들);

	        foreach(string 현재문장 in 문장들)	
	        {
                if (!현재문장.Contains("*")) rr.Add(현재문장);		// 단어 해설 앞에 *이 붙음

                if (문장삽입_Check(현재문장)) b = true;
	        }	

	        if(!b)					return false;

	        if(rr.Count() < 5)	return false;							// 너무 작은 문장 숫자
	        else					return true;

        }
        public static bool 문장삽입_모든문장_01_Pre(string p, ref List<string> rr)
        {
	        bool	b = false;
            List<string> 문장들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(p, ref 문장들);

	        foreach(string 현재문장 in 문장들)	
	        {
                if (!현재문장.Contains("*")) rr.Add(현재문장);		// 단어 해설 앞에 *이 붙음

                if (문장삽입_모든문장_Check(현재문장)) b = true;
	        }	

	        if(!b)					return false;

	        if(rr.Count() < 5)	return false;							// 너무 작은 문장 숫자
	        else					return true;

        }
        public static bool 문장삽입_모든문장_Check(string w)
        {
            // 나중에 쓸 일이 있을지도 모른다.
	        return true;
        }

        #endregion

		#region 순서
		public static bool 다이얼로그여부(string 본문)
		{
			List<string> 개행문자로_구분한_문자열 = new List<string>();

			변환.문자열.개행문자로_구분한_문자열들로(본문, ref 개행문자로_구분한_문자열);

			for(int i = 0; i < 개행문자로_구분한_문자열.Count; i++)
			{
				if (!개행문자로_구분한_문자열[i].Contains(":"))
					return false;
			}

			return true;
		}

		//		5	6	7	8	9	10	11	12	13	14	15
		//	0	B1	B1			B1			B1			B1
		//	1		B2	B1	B1	B2	B1	B1	B2	B1	B1	B2
		//	2	B1	B1	B2	B2	B3	B2	B2	B3	B2	B2	B3
		//	3		B2	B1		B1	B3	B3	B4	B3	B3	B4
		//	4	B1	B1	B2	B1	B2	B1	B1	B1	B4	B4	B5
		//	5		B2	B1	B2	B3	B2		B2	B1	B1	B1
		//	6			B2	B1	B1	B3	B2	B3	B2	B2	B2
		//	7				B2	B2	B1	B3	B4	B3		B3
		//	8					B3	B2	B1	B1	B4	B3	B4
		//	9						B3	B2	B2	B1	B4	B5
		//	10							B3	B3	B2	B1	B1
		//	11								B4	B3	B2	B2
		//	12									B4	B3	B3
		//	13										B4	B4
		//	14											B5
		public static string 글의순서_다이얼로그(string 본문, string 해석)
		{
			List<string> 개행문자로_구분한_문자열 = new List<string>();

			변환.문자열.개행문자로_구분한_문자열들로(본문, ref 개행문자로_구분한_문자열);

			string 결과 = "";

			if(			개행문자로_구분한_문자열.Count < 5 )	{ 결과 = "";																																																						}
			else if(	개행문자로_구분한_문자열.Count == 5)	{ 결과 += DialogFlow_Core(본문, 해석,	0,	2,	4);																																															}
			else if(	개행문자로_구분한_문자열.Count == 6)	{ 결과 += DialogFlow_Core(본문, 해석,	0,	2,	4);  결과 += DialogFlow_Core(본문, 해석,		1,	3,	5);																																				}
			else if(	개행문자로_구분한_문자열.Count == 7)	{ 결과 += DialogFlow_Core(본문, 해석,	1,	3,	5);  결과 += DialogFlow_Core(본문, 해석,		2,	4,	6);																																				}
			else if(	개행문자로_구분한_문자열.Count == 8)	{ 결과 += DialogFlow_Core(본문, 해석,	1,	4,	6);  결과 += DialogFlow_Core(본문, 해석,		2,	5,	7);																																				}
			else if(	개행문자로_구분한_문자열.Count == 9)	{ 결과 += DialogFlow_Core(본문, 해석,	0,	3,	6);  결과 += DialogFlow_Core(본문, 해석,		1,	4,	7);   결과 += DialogFlow_Core(본문, 해석,		2,	5,	8);																								}
			else if(	개행문자로_구분한_문자열.Count == 10)	{ 결과 += DialogFlow_Core(본문, 해석,	1,	4,	7);  결과 += DialogFlow_Core(본문, 해석,		2,	5,	8);   결과 += DialogFlow_Core(본문, 해석,		3,	6,	9);																								}
			else if(	개행문자로_구분한_문자열.Count == 11)	{ 결과 += DialogFlow_Core(본문, 해석,	1,	4,	8);  결과 += DialogFlow_Core(본문, 해석,		2,	6,	9);   결과 += DialogFlow_Core(본문, 해석,		3,	7,	10);																							}
			else if(	개행문자로_구분한_문자열.Count == 12)	{ 결과 += DialogFlow_Core(본문, 해석,	0,	4,	8);  결과 += DialogFlow_Core(본문, 해석,		1,	5,	9);   결과 += DialogFlow_Core(본문, 해석,		2,	6,	10); 결과 += DialogFlow_Core(본문, 해석,		3,	7,	11);												}
			else if(	개행문자로_구분한_문자열.Count == 13)	{ 결과 += DialogFlow_Core(본문, 해석,	1,	5,	9);  결과 += DialogFlow_Core(본문, 해석,		2,	6,	10);  결과 += DialogFlow_Core(본문, 해석,		3,	7,	11); 결과 += DialogFlow_Core(본문, 해석,		4,	8,	12);												}
			else if(	개행문자로_구분한_문자열.Count == 14)	{ 결과 += DialogFlow_Core(본문, 해석,	1,	5,	10); 결과 += DialogFlow_Core(본문, 해석,		2,	6,	11);  결과 += DialogFlow_Core(본문, 해석,		3,	8,	12); 결과 += DialogFlow_Core(본문, 해석,		4,	9,	13);												}
			else if(	개행문자로_구분한_문자열.Count == 15)	{ 결과 += DialogFlow_Core(본문, 해석,	0,	5,	10); 결과 += DialogFlow_Core(본문, 해석,		1,	6,	11);  결과 += DialogFlow_Core(본문, 해석,		2,	7,	12); 결과 += DialogFlow_Core(본문, 해석,		3,	8,	13); 결과 += DialogFlow_Core(본문, 해석,		4,	9,	14);	}
			else												{ 결과 = "";																																																							}

			return 결과;

		}

		public static string DialogFlow_Core(string 본문, string 해석, int s1, int s2, int s3)
		{
			// 2. 문제 유형
			string 출제문제 ; 	출제문제 = "다음 대화문의 빈칸에 들어갈 가장 적절한 표현을 짝지은 것을 고르시오.";

			List<string> 개행문자로_구분한_문자열 = new List<string>();

			변환.문자열.개행문자로_구분한_문자열들로(본문, ref 개행문자로_구분한_문자열);

			string part1, part2, part3;
			part1 = 개행문자로_구분한_문자열[s1]; part1 = part1.Substring(part1.IndexOf(":") + 1); part1 = part1.Trim();
			part2 = 개행문자로_구분한_문자열[s2]; part2 = part2.Substring(part2.IndexOf(":") + 1); part2 = part2.Trim();
			part3 = 개행문자로_구분한_문자열[s3]; part3 = part3.Substring(part3.IndexOf(":") + 1); part3 = part3.Trim();

			출제문제 += "<CAKE>\n";
            출제문제 += "\t<Q> " + _현재번호 + ". 다음 대화문의 빈칸에 들어갈 가장 적절한 표현을 짝지은 것을 고르시오. </Q>\n";
            출제문제 += "\t<T>\n\t";


			for(int i = 0 ; i < 개행문자로_구분한_문자열.Count ; i++)
			{
				string line = 개행문자로_구분한_문자열[i];

				if(i == s1)
				{
					line = line.Left(line.IndexOf(":")); line = line.Trim();
					출제문제 += "\t" + line + " : ___(A)___\r\n";
				}
				else if(i == s2)
				{
					line = line.Left(line.IndexOf(":")); line = line.Trim();
					출제문제 += "\t" + line + " : ___(B)___\r\n";
				}
				else if(i == s3)
				{
					line = line.Left(line.IndexOf(":")); line = line.Trim();
					출제문제 += "\t" + line + " : ___(C)___\r\n";
				}
				else
				{
					line.Trim();
					출제문제 += "\t" + line + "\r\n";
				}
			}

			출제문제 += "\t<TBAR></TBAR>\r\n";
			출제문제 += "\t{보기}\r\n";


			//--------------------------------------------------------------------------------


            int 문장dna = 현재문장DNA(본문);
            문장dna = 문장dna % 5;

            if (문장dna == 0) //(A)-(C)-(B)가 정답
            {
				출제문제 += "\tⓐ " + part1 + "\r\n";
				출제문제 += "\tⓑ " + part3 + "\r\n";
				출제문제 += "\tⓒ " + part2 + "\r\n";
            }
            else if (문장dna == 1) //(B)-(A)-(C)가 정답
            {
				출제문제 += "\tⓐ " + part2 + "\r\n";
				출제문제 += "\tⓑ " + part1 + "\r\n";
				출제문제 += "\tⓒ " + part3 + "\r\n";
            }
            else if (문장dna == 2) //(B)-(C)-(A)가 정답
            {
				출제문제 += "\tⓐ " + part3 + "\r\n";
				출제문제 += "\tⓑ " + part1 + "\r\n";
				출제문제 += "\tⓒ " + part2 + "\r\n";
            }
            else if (문장dna == 3) //(C)-(A)-(B)가 정답
            {
				출제문제 += "\tⓐ " + part2 + "\r\n";
				출제문제 += "\tⓑ " + part3 + "\r\n";
				출제문제 += "\tⓒ " + part1 + "\r\n";
            }
            else if (문장dna == 4) //(C)-(B)-(A)가 정답
            {
				출제문제 += "\tⓐ " + part3 + "\r\n";
				출제문제 += "\tⓑ " + part2 + "\r\n";
				출제문제 += "\tⓒ " + part1 + "\r\n";
            }

			//--------------------------------------------------------------------------------


			출제문제 += "\t</T>\r\n";
			출제문제 += "\t<A>\r\n";
			출제문제 += "\t<A0> (A) …… (B) …… (C) </A0>\r\n";
			출제문제 += "\t<A1> ⓐ …… ⓒ …… ⓑ </A1>\r\n";
			출제문제 += "\t<A2> ⓑ …… ⓐ …… ⓒ </A2>\r\n";
			출제문제 += "\t<A3> ⓑ …… ⓒ …… ⓐ </A3>\r\n";
			출제문제 += "\t<A4> ⓒ …… ⓐ …… ⓑ </A4>\r\n";
			출제문제 += "\t<A5> ⓒ …… ⓑ …… ⓐ </A5>\r\n";
			출제문제 += "\t</A>\r\n";

            출제문제 += "\t<정답>\n";

            if (문장dna == 0){ 출제문제 += "\t정답 ①번\r\n"; }
            if (문장dna == 1) { 출제문제 += "\t정답 ②번\r\n"; }
            if (문장dna == 2) { 출제문제 += "\t정답 ③번\r\n"; }
            if (문장dna == 3) { 출제문제 += "\t정답 ④번\r\n"; }
            if (문장dna == 4) { 출제문제 += "\t정답 ⑤번\r\n"; }

            출제문제 += "\t</정답>\n";
            출제문제 += "\t<해석>\n";
            출제문제 += 해석 + "\n";
            출제문제 += "\t</해석>\n";
            출제문제 += "</CAKE>\n";

			_현재번호++;

			return 출제문제;
		}

		public static bool 글의순서_문제출제가능여부(string 태그있는본문)
		{

			string 본문 = 변환.문자열.문법문제표지제거(태그있는본문); 

			List<string> 글의순서문제낼수없는문장들 = new List<string>();

			변환.Ansi파일.문자열들로(_문제DB루트폴더 + "글의순서문제낼수없는문장들.qst", ref 글의순서문제낼수없는문장들);

			for(int i = 0 ; i < 글의순서문제낼수없는문장들.Count ; i++)
			{
				if(본문.Contains(글의순서문제낼수없는문장들[i]))
					return false;
			}

			return true;
		}

		public static string 글의순서(string 제목, string 태그있는본문, string 해석)
		{
			if (제목.ToLower().Contains("in this lesson"))	return "";
			if (제목.ToLower().Contains("grammar"))			return "";
			if (제목.ToLower().Contains("언어 형식"))		return "";

			string 본문 = 변환.문자열.문법문제표지제거(태그있는본문); 

			if (!글의순서_문제출제가능여부(태그있는본문)) return "";

			if (다이얼로그여부(본문)) return 글의순서_다이얼로그(본문, 해석);

			List<string> 본문_문장들 = new List<string>();
			강력하지만무거운변환.문자열.문장단위의_문자열들로(본문, ref 본문_문장들);

			if(본문_문장들.Count < 3 ) return "";
			else if(본문_문장들.Count == 3) return	글의순서_Core(본문,	해석,	-1,	0,	1,	2);
			else if(본문_문장들.Count == 4) return	글의순서_Core(본문,	해석,	0,	1,	2,	3);
			else if(본문_문장들.Count == 5) return	글의순서_Core(본문,	해석,	0,	2,	3,	4);
			else if(본문_문장들.Count == 6) return	글의순서_Core(본문,	해석,	-1,	0,	2,	4);
			else if(본문_문장들.Count == 7) return	글의순서_Core(본문,	해석,	0,	1,	3,	5);
			else if(본문_문장들.Count == 8) return	글의순서_Core(본문,	해석,	0,	2,	4,	6);
			else if(본문_문장들.Count == 9) return	글의순서_Core(본문,	해석,	-1,	0,	3,	6);
			else if(본문_문장들.Count == 10) return 글의순서_Core(본문,	해석,	0,	1,	4,	7);
			else if(본문_문장들.Count == 11) return 글의순서_Core(본문,	해석,	0,	2,	5,	8);
			else if(본문_문장들.Count == 12) return 글의순서_Core(본문,	해석,	0,	3,	6,	9);
			else if(본문_문장들.Count == 13) return 글의순서_Core(본문,	해석,	0,	1,	5,	9);
			else return "";

		}

		public static string 글의순서_Core(string 본문, string 해석, int s1, int s2, int s3, int s4)
		{

			//--------------------------------------------------------------------------------
			// 1. 문항번호

			// 2. 문제 유형
			string q;
			if(s1 == -1)		q = "(A),(B),(C)를 하나의 글로 구성할 때 가장 적절한 순서는?";
			else				q = "주어진 글 다음에 이어질 글의 순서로 가장 적절한 것은?";

			// 3. 보기
			List<string> 본문_문장들 = new List<string>();
			강력하지만무거운변환.문자열.문장단위의_문자열들로(본문, ref 본문_문장들);

			string part0 = "", part1 = "", part2 = "", part3 = "";
			if(s1 == -1)		part0 = "";
			else
			{
				for(int i = 0 ; i < s2 ; i++){			part0 += 본문_문장들[i];			part0 += " ";		}
			}

			int s5  = 본문_문장들.Count;
			for(int i = s2 ; i < s3 ; i++)	{		part1 += 본문_문장들[i];		part1 += " ";	}
			for(int i = s3 ; i < s4 ; i++)	{		part2 += 본문_문장들[i];		part2 += " ";	}
			for(int i = s4 ; i < s5 ; i++)	{		part3 += 본문_문장들[i];		part3 += " ";	}

			//--------------------------------------------------------------------------------
			//--------------------------------------------------------------------------------

			string r = "";

			r += "<CAKE>\r\n";
			r += "\t<Q> " + _현재번호 + ". " + q + " </Q>\r\n";
			r += "\t<T>\r\n";
	
			if(s1 == -1)		r += "";
			else
			{
				r += "\t" + part0 + "\r\n";
				r += "\t<TBAR></TBAR>\r\n";
			}

			//--------------------------------------------------------------------------------
            int 문장dna = 현재문장DNA(본문);
            문장dna = 문장dna % 5;


			if(문장dna == 0) //(A)-(C)-(B)가 정답
			{
				r += "\t(A) " + part1 + "\r\n";
				r += "\t(B) " + part3 + "\r\n";
				r += "\t(C) " + part2 + "\r\n";
			}
			else if(문장dna == 1) //(B)-(A)-(C)가 정답
			{
				r += "\t(A) " + part2 + "\r\n";
				r += "\t(B) " + part1 + "\r\n";
				r += "\t(C) " + part3 + "\r\n";
			}
			else if(문장dna == 2) //(B)-(C)-(A)가 정답
			{
				r += "\t(A) " + part3 + "\r\n";
				r += "\t(B) " + part1 + "\r\n";
				r += "\t(C) " + part2 + "\r\n";
			}
			else if(문장dna == 3) //(C)-(A)-(B)가 정답
			{
				r += "\t(A) " + part2 + "\r\n";
				r += "\t(B) " + part3 + "\r\n";
				r += "\t(C) " + part1 + "\r\n";
			}
			else if(문장dna == 4) //(C)-(B)-(A)가 정답
			{
				r += "\t(A) " + part3 + "\r\n";
				r += "\t(B) " + part2 + "\r\n";
				r += "\t(C) " + part1 + "\r\n";
			}

			//--------------------------------------------------------------------------------

			r += "\t</T>\r\n";
			r += "\t<A>\r\n";
			r += "\t<A1> (A) …… (C) …… (B) </A1>\r\n";
			r += "\t<A2> (B) …… (A) …… (C) </A2>\r\n";
			r += "\t<A3> (B) …… (C) …… (A) </A3>\r\n";
			r += "\t<A4> (C) …… (A) …… (B) </A4>\r\n";
			r += "\t<A5> (C) …… (B) …… (A) </A5>\r\n";
			r += "\t</A>\r\n";
			r += "\t<정답>\r\n";
			if(문장dna == 0)	r += "\t정답 ①번\r\n";
			if(문장dna == 1)	r += "\t정답 ②번\r\n";
			if(문장dna == 2)	r += "\t정답 ③번\r\n";
			if(문장dna == 3)	r += "\t정답 ④번\r\n";
			if(문장dna == 4)	r += "\t정답 ⑤번\r\n";
			r += "\t</정답>\r\n";

			r += "\t<해석>\r\n";
            r += 해석 + "\n";
			r += "\t</해석>\r\n";

			r += "</CAKE>\r\n";

			_현재번호++;			//문항 번호를 하나씩 자동으로 올려준다.
			return r;
		}


		#endregion

		public static string 일치_영문(string 정답오답보기파일경로, string 지문, string 지문_구조분석만있는, string 해석)
		{
			string 질문 = "다음 글의 내용과 일치하는 것은?";

            string ret = "", 검색용소문자지문;
            검색용소문자지문 = 지문.ToLower();

            List<string> 정답오답보기들 = new List<string>();

            변환.Ansi파일.문자열들로(정답오답보기파일경로, ref 정답오답보기들);
            

            // 문제 입력 파일의 구조는 아래와 같은 구조로 이루어집니다.
            //
            // "검색어"|RW(옳고 그름의 여부)|"보기"

            // 1.현재의 단락에서 "검색어"를 검색합니다. 현재의 단락을 기준으로 옳은 것(R)이 하나 이상, 틀린 것(W)이 네 개 이상 나와야 합니다.
            // 문제는 가급적 5회를 만듭니다. 그러려면, 틀린 것의 갯수가 적어도 다섯개는 나와야 합니다.

            // 2.정답은 오답 4개와 정렬하여 결정합니다.

            // 문제의 형식을 깔끔하게 만들어 줍니다.

            List<정오답보기> 정답인보기들 = new List<정오답보기>();
            List<정오답보기> 오답인보기들 = new List<정오답보기>();

            for (int i = 0; i < 정답오답보기들.Count; i++)
            {
                string 현재의_검색할_키워드 = 구분자의_첫번째부분(정답오답보기들[i]);

                if (!현재의_검색할_키워드.Contains(","))
                {
                    if (검색용소문자지문.Contains(현재의_검색할_키워드.ToLower()))
                    {
                        if (구분자의_두번째부분(정답오답보기들[i]) == "R")
                            정답인보기들.Add(new 정오답보기() { 정오답보기스트링 = 구분자의_세번째부분(정답오답보기들[i]), 가중치 = 현재의_검색할_키워드.Length });
                        else if (구분자의_두번째부분(정답오답보기들[i]) == "W")
                            오답인보기들.Add(new 정오답보기() { 정오답보기스트링 = 구분자의_세번째부분(정답오답보기들[i]), 가중치 = 현재의_검색할_키워드.Length });
                    }
                }
                // 쉼표가 있다면, 검색할 키워드들이 여러 개인 것입니다.
                else
                {
                    string [] 현재의_검색할_키워드들 = 현재의_검색할_키워드.Split(',');

                    bool 검색할_키워드가_지문에_모두_있는지 = true;
                    int 검색키워드점수 = 1;
                    foreach (string 낱개의_검색할_키워드 in 현재의_검색할_키워드들)
                    {
                        if (!검색용소문자지문.Contains(낱개의_검색할_키워드.ToLower()))   검색할_키워드가_지문에_모두_있는지 = false;

                        검색키워드점수 *= 낱개의_검색할_키워드.Length;
                    }

                    if (검색할_키워드가_지문에_모두_있는지 == true)
                    {
                        if (구분자의_두번째부분(정답오답보기들[i]) == "R")
                            정답인보기들.Add(new 정오답보기() { 정오답보기스트링 = 구분자의_세번째부분(정답오답보기들[i]), 가중치 = 검색키워드점수 });

                        else if (구분자의_두번째부분(정답오답보기들[i]) == "W")
                            오답인보기들.Add(new 정오답보기() { 정오답보기스트링 = 구분자의_세번째부분(정답오답보기들[i]), 가중치 = 검색키워드점수 });
                    }
                }
            }

            정답인보기들.Sort();
            오답인보기들.Sort();


            if(정답인보기들.Count() == 0)
            {
                string 만들어낸정답 = 일치_영문_정답만들어내기(지문, 지문_구조분석만있는);

                if(만들어낸정답 != "")
                    정답인보기들.Add(new 정오답보기() { 정오답보기스트링 = 만들어낸정답, 가중치 = 1 });
            }
            
			string 지문조작으로_만든_오답1 = "";
			string 지문조작으로_만든_오답2 = "";

			일치_영문_오답만들어내기(지문, 지문_구조분석만있는, ref 지문조작으로_만든_오답1, ref 지문조작으로_만든_오답2);

            if (((정답인보기들.Count() > 0) && (오답인보기들.Count() > 3)) || ((정답인보기들.Count() > 0) && (오답인보기들.Count() > 2) && 지문조작으로_만든_오답1 != ""))
            {
				List<string> 보기들 = new List<string>();
				보기들.Add(정답인보기들[0].ToString());
				보기들.Add(오답인보기들[0].ToString());
				보기들.Add(오답인보기들[1].ToString());
				보기들.Add(오답인보기들[2].ToString());

				if(지문조작으로_만든_오답1 != "")
					보기들.Add(지문조작으로_만든_오답1);
				else
					보기들.Add(오답인보기들[3].ToString());

				보기들.Sort();

                if (보기들[0] == 정답인보기들[0].ToString())
                    ret += XML로_출제(질문, 지문, 해석, 보기들[0].ToString(), 보기들[1].ToString(), 보기들[2].ToString(), 보기들[3].ToString(), 보기들[4].ToString(), "정답 ①번");
				else if (보기들[1] == 정답인보기들[0].ToString())
                    ret += XML로_출제(질문, 지문, 해석, 보기들[0].ToString(), 보기들[1].ToString(), 보기들[2].ToString(), 보기들[3].ToString(), 보기들[4].ToString(), "정답 ②번");
				else if (보기들[2] == 정답인보기들[0].ToString())
					ret += XML로_출제(질문, 지문, 해석, 보기들[0].ToString(), 보기들[1].ToString(), 보기들[2].ToString(), 보기들[3].ToString(), 보기들[4].ToString(), "정답 ③번");
				else if (보기들[3] == 정답인보기들[0].ToString())
					ret += XML로_출제(질문, 지문, 해석, 보기들[0].ToString(), 보기들[1].ToString(), 보기들[2].ToString(), 보기들[3].ToString(), 보기들[4].ToString(), "정답 ④번");
				else if (보기들[4] == 정답인보기들[0].ToString())
					ret += XML로_출제(질문, 지문, 해석, 보기들[0].ToString(), 보기들[1].ToString(), 보기들[2].ToString(), 보기들[3].ToString(), 보기들[4].ToString(), "정답 ⑤번");
            }

            return ret;

		}

        public static string 질문(string 질문, string 정답오답보기파일경로, string 지문, string 해석, string 옵션)
        {
            string ret = "", 검색용소문자지문;
            검색용소문자지문 = 지문.ToLower();

            List<string> 정답오답보기들 = new List<string>();

            변환.Ansi파일.문자열들로(정답오답보기파일경로, ref 정답오답보기들);
            

            // 문제 입력 파일의 구조는 아래와 같은 구조로 이루어집니다.
            //
            // "검색어"|RW(옳고 그름의 여부)|"보기"

            // 1.현재의 단락에서 "검색어"를 검색합니다. 현재의 단락을 기준으로 옳은 것(R)이 하나 이상, 틀린 것(W)이 네 개 이상 나와야 합니다.
            // 문제는 가급적 5회를 만듭니다. 그러려면, 틀린 것의 갯수가 적어도 다섯개는 나와야 합니다.

            // 2.정답은 오답 4개와 정렬하여 결정합니다.

            // 문제의 형식을 깔끔하게 만들어 줍니다.

            List<정오답보기> 정답인보기들 = new List<정오답보기>();
            List<정오답보기> 오답인보기들 = new List<정오답보기>();

            for (int i = 0; i < 정답오답보기들.Count; i++)
            {
                string 현재의_검색할_키워드 = 구분자의_첫번째부분(정답오답보기들[i]);

                if (!현재의_검색할_키워드.Contains(","))
                {
                    if (검색용소문자지문.Contains(현재의_검색할_키워드.ToLower()))
                    {
                        if (구분자의_두번째부분(정답오답보기들[i]) == "R")
                            정답인보기들.Add(new 정오답보기() { 정오답보기스트링 = 구분자의_세번째부분(정답오답보기들[i]), 가중치 = 현재의_검색할_키워드.Length });
                        else if (구분자의_두번째부분(정답오답보기들[i]) == "W")
                            오답인보기들.Add(new 정오답보기() { 정오답보기스트링 = 구분자의_세번째부분(정답오답보기들[i]), 가중치 = 현재의_검색할_키워드.Length });
                    }
                }
                // 쉼표가 있다면, 검색할 키워드들이 여러 개인 것입니다.
                else
                {
                    string [] 현재의_검색할_키워드들 = 현재의_검색할_키워드.Split(',');

                    bool 검색할_키워드가_지문에_모두_있는지 = true;
                    int 검색키워드점수 = 1;
                    foreach (string 낱개의_검색할_키워드 in 현재의_검색할_키워드들)
                    {
                        if (!검색용소문자지문.Contains(낱개의_검색할_키워드.ToLower()))   검색할_키워드가_지문에_모두_있는지 = false;

                        검색키워드점수 *= 낱개의_검색할_키워드.Length;
                    }

                    if (검색할_키워드가_지문에_모두_있는지 == true)
                    {
                        if (구분자의_두번째부분(정답오답보기들[i]) == "R")
                            정답인보기들.Add(new 정오답보기() { 정오답보기스트링 = 구분자의_세번째부분(정답오답보기들[i]), 가중치 = 검색키워드점수 });

                        else if (구분자의_두번째부분(정답오답보기들[i]) == "W")
                            오답인보기들.Add(new 정오답보기() { 정오답보기스트링 = 구분자의_세번째부분(정답오답보기들[i]), 가중치 = 검색키워드점수 });
                    }
                }
            }

            정답인보기들.Sort();
            오답인보기들.Sort();
            

            if ((정답인보기들.Count() > 0) && (오답인보기들.Count() > 3))
            {
				List<string> 보기들 = new List<string>();
				보기들.Add(정답인보기들[0].ToString());
				보기들.Add(오답인보기들[0].ToString());
				보기들.Add(오답인보기들[1].ToString());
				보기들.Add(오답인보기들[2].ToString());
				보기들.Add(오답인보기들[3].ToString());

				보기들.Sort();

                if (보기들[0] == 정답인보기들[0].ToString())
                    ret += XML로_출제(질문, 지문, 해석, 정답인보기들[0].ToString(), 오답인보기들[0].ToString(), 오답인보기들[1].ToString(), 오답인보기들[2].ToString(), 오답인보기들[3].ToString(), "정답 ①번");
				else if (보기들[1] == 정답인보기들[0].ToString())
                    ret += XML로_출제(질문, 지문, 해석, 오답인보기들[0].ToString(), 정답인보기들[0].ToString(), 오답인보기들[1].ToString(), 오답인보기들[2].ToString(), 오답인보기들[3].ToString(), "정답 ②번");
				else if (보기들[2] == 정답인보기들[0].ToString())
					ret += XML로_출제(질문, 지문, 해석, 오답인보기들[0].ToString(), 오답인보기들[1].ToString(), 정답인보기들[0].ToString(), 오답인보기들[2].ToString(), 오답인보기들[3].ToString(), "정답 ③번");
				else if (보기들[3] == 정답인보기들[0].ToString())
					ret += XML로_출제(질문, 지문, 해석, 오답인보기들[0].ToString(), 오답인보기들[1].ToString(), 오답인보기들[2].ToString(), 정답인보기들[0].ToString(), 오답인보기들[3].ToString(), "정답 ④번");
				else if (보기들[4] == 정답인보기들[0].ToString())
					ret += XML로_출제(질문, 지문, 해석, 오답인보기들[0].ToString(), 오답인보기들[1].ToString(), 오답인보기들[2].ToString(), 오답인보기들[3].ToString(), 정답인보기들[0].ToString(), "정답 ⑤번");
            }

            return ret;

        }

		// 리턴값이 참이면 단수이다. 왠만하면 단수이다.
		public static bool 단수복수_확인(string 확인할문자열)
		{
			확인할문자열 = 확인할문자열.Trim();

			if(확인할문자열.StartsWith("a ")) return true;
			if(확인할문자열.StartsWith("an ")) return true;
			if(확인할문자열.StartsWith("A ")) return true;
			if(확인할문자열.StartsWith("An ")) return true;

			// 확인할 문자열의 맨 마지막 단어를 추출하자.
			string 맨마지막단어 = "";

			if(확인할문자열.Contains(" "))
			{
				맨마지막단어 = 확인할문자열.Substring(확인할문자열.LastIndexOf(' ') + 1);
			}
			else
			{
				맨마지막단어 = 확인할문자열;
			}

			string 검색결과 = _검색.영한사전(맨마지막단어);

			if(검색결과.Contains("복수형") || 검색결과.Contains("s형")) return false;

			return true;
		}


		// 리턴값이 참이면 현재 시제이다.
		public static bool 시제_확인(string 확인할문자열)
		{
			if(확인할문자열.Contains(" is ")) return true;
			if(확인할문자열.Contains(" are ")) return true;

			if(확인할문자열.Contains(" was ")) return false;
			if(확인할문자열.Contains(" were ")) return false;


			return true;
		}
		// 인공지능이 필요한 부분임
		// 인간 지식의 기본요소
		// 1.'같다, 다르다, 포함하다'라는 개념
		// 2.'생각한다, 인정한다'라는 개념
		// 3.'구한다, 얻는다, 충분하다, 부족하다'라는 개념
		// 4.'두렵다'라는 개념

        public static void 일치_영문_오답만들어내기(string 지문, string 지문_구조분석만있는, ref string 지문조작으로_만든_오답1, ref string 지문조작으로_만든_오답2)
		{
			List<string> 문장들_구조분석만있는 = new List<string>();

			강력하지만무거운변환.문자열.문장단위의_문자열들로(지문_구조분석만있는, ref 문장들_구조분석만있는);

			단문복문해석 단문복문해석_객체 = new 단문복문해석();

			bool 단복수확인 = false;
			bool 시제확인 = false;

			string 컴퓨터가_뽑았다고는_믿기_어려운_주어 = "";
			string 컴퓨터가_뽑았다고는_믿기_어려운_주어_백업후보 = "";
			int 컴퓨터가_뽑은_후보의_문장위치 = 0;
			string 컴퓨터가_뽑았다고는_믿기_어려운_목적어 = "";

			for(int i = 문장들_구조분석만있는.Count - 1; i >= 0; i--) // 아래에서부터 위로 긁는다
			{
				단문복문해석_객체.문자열분석(문장들_구조분석만있는[i]);

				// 주어는 살짝 길고 고유명사이면 좋다. 우선 쭉 긁으면서 고유명사이고, 살짝 긴 것을 찾는다.
				// 우선 주어 확인
				string 후보 = 단문복문해석_객체._주어.문법문제표지제거();
				List <string> 어절들 = new List<string>();

				변환.문자열.어절들로(후보, ref 어절들);

				if(어절들.Count > 3)
				{

					컴퓨터가_뽑았다고는_믿기_어려운_주어_백업후보 = 후보;


					for(int j = 0 ; j < 어절들.Count; j++)
					{
						string 검색결과 = _검색.영한사전(어절들[j]);

						if(검색결과 == "" || 검색결과.Contains("이름"))
						{
							컴퓨터가_뽑았다고는_믿기_어려운_주어 = 후보;
							컴퓨터가_뽑은_후보의_문장위치 = i;
							break;
						}
					}
				}
				
			}

			// 없으면 적당히 긴 것을 찾는다.
			if(컴퓨터가_뽑았다고는_믿기_어려운_주어 == ""){		컴퓨터가_뽑았다고는_믿기_어려운_주어 = 컴퓨터가_뽑았다고는_믿기_어려운_주어_백업후보;		}

			// 똑같은 방식으로 목적어를 뽑는다.
			for(int i = 문장들_구조분석만있는.Count - 1; i >= 0; i--) // 아래에서부터 위로 긁는다
			{
				단문복문해석_객체.문자열분석(문장들_구조분석만있는[i]);

				// 목적어 역시 길면 좋다. 고유 명사일 필요까지 없을 것 같지만
				string 후보 = 단문복문해석_객체._목적어.문법문제표지제거();
				string 후보_문법표지있는 = 단문복문해석_객체._목적어;

				List <string> 어절들 = new List<string>();

				변환.문자열.어절들로(후보, ref 어절들);

				if((어절들.Count > 3) && (컴퓨터가_뽑은_후보의_문장위치 != i) && !후보_문법표지있는.Contains("ⓢ")) // 길이가 적당히 길어야 하고, 주어와 같은 위치여서는 안된다. 주어도 없는 것이 좋다. 
				{
					컴퓨터가_뽑았다고는_믿기_어려운_목적어 = 후보;
				}
			}

			string[,] 서술어들 = new string [,] {	{"eradicate", "eradicates", "eradicated"},	{"obliterate", "obliterates", "obliterated" },	{"extirpate", "extirpates", "extirpated" },		{"abrogate", "abrogates", "abrogated" },		{"subvert", "subverts", "subverted" },
													{"revoke", "revokes", "revoked" },			{"nullify", "nullifies", "nullified" },			{"overthrow", "overthrows", "overthrew" },		{"annihilate", "annihilates", "annihilated" },	{"supersede", "supersedes", "superseded" },
													{"expunge","expunges","expunged" },			{"loathe", "loathes", "loathed" },				{"execrate", "execrates", "execrated" },		{"disparage", "disparages", "disparaged" },		{"reproach", "reproaches", "reproached" },	
													{"upbraid","upbraids","upbraided" },		{"asperse", "asperses", "aspersed" },			{"malign", "maligns", "maligned" },				{"slander", "slanders", "slandered" },			{"vituperate","vituperates","vituperated" },	
													{"taunt", "taunts", "taunted" },			{"repudiate","repudiates","repudiated" },		{"delude", "deludes", "deluded" },				{"forfeit",	"forfeits",	"forfeited" },			{"","","" },	
													{"","","" },	{"","","" },	{"","","" },	{"","","" },	{"","","" },	

			};



			//

			if(컴퓨터가_뽑았다고는_믿기_어려운_주어 != "" && 컴퓨터가_뽑았다고는_믿기_어려운_목적어 != "")
			{
				지문조작으로_만든_오답1 = 컴퓨터가_뽑았다고는_믿기_어려운_주어.Trim().대문자로_첫글자만() + " " + 서술어들[0, 1] + " " + 컴퓨터가_뽑았다고는_믿기_어려운_목적어.Trim() + ".";
			}
		}

        public static string 일치_영문_정답만들어내기(string 지문, string 지문_구조분석만있는)
        {
            List<정오답보기> 정답후보들 = new List<정오답보기>();

            List<string> 문장들 = new List<string>();
            List<string> 문장들_구조분석만있는 = new List<string>();


            List<string> 바꿔볼만한목록들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(지문, ref 문장들);
            강력하지만무거운변환.문자열.문장단위의_문자열들로(지문_구조분석만있는, ref 문장들_구조분석만있는);

			// ***************************************** //
			// 
			// 원래 문장 : ⓞ{a free tutoring program ⓧ{ⓒ{open} ⓧ{to all international students at our university}}}
			// 바꿀 문장 : A free tutoring program is open to all international students at our university.
			//
			// ***************************************** //
			// "ⓢ{"나 "ⓞ{"나 "ⓒ{"가 나오면 시작이다. "ⓥ{"이면 레벨만 업이다.
			단문복문해석 단문복문해석_객체 = new 단문복문해석();

			bool 단복수확인 = false;
			bool 시제확인 = false;

            foreach (string 현재문장 in 문장들_구조분석만있는)
            {
				string 유력후보 = "";
				단문복문해석_객체.문자열분석(현재문장);

				if(단문복문해석_객체._주어.Contains("ⓧ{ⓒ{"))
				{
					string 앞부분 = 단문복문해석_객체._주어.Substring(0, 단문복문해석_객체._주어.IndexOf("ⓧ{ⓒ{"));
					string 뒷부분 = 단문복문해석_객체._주어.Substring(단문복문해석_객체._주어.IndexOf("ⓧ{ⓒ{") + 4);

					if(!앞부분.Contains("{")) // 앞부분이 아무 것도 없는 깔끔한 명사구인 것이 좋다. 뭔가 있다면 어떤 이상한 문장이 만들어질 지 알 수 없다.
					{
						단복수확인 = 단수복수_확인(앞부분);
						시제확인 = 시제_확인(지문);

						if(단복수확인 && 시제확인)						유력후보 = 앞부분.Trim().대문자로_첫글자만() + " is " + 뒷부분.문법문제표지제거() + ".";
						else if(단복수확인 && !시제확인)				유력후보 = 앞부분.Trim().대문자로_첫글자만() + " was " + 뒷부분.문법문제표지제거() + ".";
						else if(!단복수확인 && 시제확인)				유력후보 = 앞부분.Trim().대문자로_첫글자만() + " are " + 뒷부분.문법문제표지제거() + ".";
						else if(!단복수확인 && !시제확인)				유력후보 = 앞부분.Trim().대문자로_첫글자만() + " were " + 뒷부분.문법문제표지제거() + ".";

						if(유력후보 != "") return 유력후보;
					}
				}
				else if(단문복문해석_객체._목적어.Contains("ⓧ{ⓒ{"))
				{
					string 앞부분 = 단문복문해석_객체._목적어.Substring(0, 단문복문해석_객체._목적어.IndexOf("ⓧ{ⓒ{"));
					string 뒷부분 = 단문복문해석_객체._목적어.Substring(단문복문해석_객체._목적어.IndexOf("ⓧ{ⓒ{") + 4);

					if(!앞부분.Contains("{")) // 앞부분이 아무 것도 없는 깔끔한 명사구인 것이 좋다. 뭔가 있다면 어떤 이상한 문장이 만들어질 지 알 수 없다.
					{
						단복수확인 = 단수복수_확인(앞부분);
						시제확인 = 시제_확인(지문);

						if(단복수확인 && 시제확인)						유력후보 = 앞부분.Trim().대문자로_첫글자만() + " is " + 뒷부분.문법문제표지제거() + ".";
						else if(단복수확인 && !시제확인)				유력후보 = 앞부분.Trim().대문자로_첫글자만() + " was " + 뒷부분.문법문제표지제거() + ".";
						else if(!단복수확인 && 시제확인)				유력후보 = 앞부분.Trim().대문자로_첫글자만() + " are " + 뒷부분.문법문제표지제거() + ".";
						else if(!단복수확인 && !시제확인)				유력후보 = 앞부분.Trim().대문자로_첫글자만() + " were " + 뒷부분.문법문제표지제거() + ".";

						if(유력후보 != "") return 유력후보;
					}
				}
				else if(단문복문해석_객체._보어.Contains("ⓧ{ⓒ{"))
				{
					string 앞부분 = 단문복문해석_객체._보어.Substring(0, 단문복문해석_객체._보어.IndexOf("ⓧ{ⓒ{"));
					string 뒷부분 = 단문복문해석_객체._보어.Substring(단문복문해석_객체._보어.IndexOf("ⓧ{ⓒ{") + 4);

					if(!앞부분.Contains("{")) // 앞부분이 아무 것도 없는 깔끔한 명사구인 것이 좋다. 뭔가 있다면 어떤 이상한 문장이 만들어질 지 알 수 없다.
					{
						단복수확인 = 단수복수_확인(앞부분);
						시제확인 = 시제_확인(지문);

						if(단복수확인 && 시제확인)						유력후보 = 앞부분.Trim().대문자로_첫글자만() + " is " + 뒷부분.문법문제표지제거() + ".";
						else if(단복수확인 && !시제확인)				유력후보 = 앞부분.Trim().대문자로_첫글자만() + " was " + 뒷부분.문법문제표지제거() + ".";
						else if(!단복수확인 && 시제확인)				유력후보 = 앞부분.Trim().대문자로_첫글자만() + " are " + 뒷부분.문법문제표지제거() + ".";
						else if(!단복수확인 && !시제확인)				유력후보 = 앞부분.Trim().대문자로_첫글자만() + " were " + 뒷부분.문법문제표지제거() + ".";

						if(유력후보 != "") return 유력후보;
					}
				}
			}



			// ***************************************** //
			// ***--- 단순하게 어구를 바꾸는 모듈 ---*** //
			// ***************************************** //
            변환.Ansi파일.문자열들로(_문제DB루트폴더 + "어휘_영어_바꿔볼어구.txt", ref 바꿔볼만한목록들);

            foreach (string 현재문장 in 문장들)
            {
                if (!현재문장.Contains("?")) // 상식적으로 의문문을 일치문제의 정답으로 우길 수는 없다.
                {
                    int 현재문장가중치 = 1;

                    string 바뀐문장 = 현재문장;


                    foreach (string 현재바꿔볼만한목록 in 바꿔볼만한목록들)
                    {
                        if (현재바꿔볼만한목록.Contains(","))
                        {
                            string[] 현재바꿔볼만한목록_구분자로나누기 = 현재바꿔볼만한목록.Split(',');

                            if (바뀐문장.Contains(현재바꿔볼만한목록_구분자로나누기[0]))
                            {
                                바뀐문장 = 바뀐문장.Replace(현재바꿔볼만한목록_구분자로나누기[0], 현재바꿔볼만한목록_구분자로나누기[1]);

                                현재문장가중치 *= 현재바꿔볼만한목록_구분자로나누기[0].Length;
                            }
                        }
                    }

                    if (현재문장가중치 != 1)
                    {
                        정답후보들.Add(new 정오답보기() { 정오답보기스트링 = 바뀐문장, 가중치 = 현재문장가중치 });
                    }
                }
            }

            정답후보들.Sort();
            if (정답후보들.Count() > 0)
            {
                return 정답후보들[0].정오답보기스트링;
            }

            return "";
        }


        public static string XML로_출제(string 질문, string 지문, string 해석, string answer1, string answer2, string answer3, string answer4, string answer5, string rightAnswer)
        {
	        string sRes = "";

	        sRes += "<CAKE>\r";


	        sRes += "\t<Q> " + _현재번호 + ". " + 질문 + " </Q>\r";
	        sRes += "\t<T>\r";


	        지문.Trim();
	        sRes += "\t";
	        sRes += 지문;	sRes += "\r";
	        sRes += "\t</T>\r";


	        sRes += "\t<A>\r";
	        sRes += "\t<A1> "; sRes+= answer1;  sRes+= " </A1>\r";
	        sRes += "\t<A2> "; sRes+= answer2;  sRes+= " </A2>\r";
	        sRes += "\t<A3> "; sRes+= answer3;  sRes+= " </A3>\r";
	        sRes += "\t<A4> "; sRes+= answer4;  sRes+= " </A4>\r";
	        sRes += "\t<A5> "; sRes+= answer5;  sRes+= " </A5>\r";
	        sRes += "\t</A>\r";
	        sRes += "\t<정답>\r";
	        sRes += "\t"; sRes+= rightAnswer; sRes+= "\r";
			sRes += "\t</정답>\r";
			sRes += "\t<해석>\r";
			sRes += "\t" + 해석 + "\r";
			sRes += "\t</해석>\r";

			sRes += "</CAKE>\r";

            _현재번호++;

	        return sRes;
        }
        public static string 구분자의_첫번째부분(string 라인)
        {
            if (!라인.Contains("|")) return "";

            string[] 나뉜것들 = 라인.Split('|');
			string 나뉜것들0 = 나뉜것들[0];
			나뉜것들0 = 나뉜것들0.Replace("\t", "");
			
			while(나뉜것들0.Contains("  "))
				나뉜것들0 = 나뉜것들0.Replace("  ", " ");

			return 나뉜것들0; // Trim을 안쓰는 이유는, 
        }
        public static string 구분자의_두번째부분(string 라인)
        {
            if (!라인.Contains("|")) return "";

            string[] 나뉜것들 = 라인.Split('|');

            if(나뉜것들.Count() > 1)
                return 나뉜것들[1].Trim();
            else
                return "";
        }
        public static string 구분자의_세번째부분(string 라인)
        {
            if (!라인.Contains("|")) return "";

            string[] 나뉜것들 = 라인.Split('|');
            if (나뉜것들.Count() > 2)
                return 나뉜것들[2].Trim();
            else
                return "";
        }

        public static string 어휘문제_후보표시(string 원래지문)
        {
			while(원래지문.Contains("  "))
			{
				원래지문 = 원래지문.Replace("  ", " ");
			}

			원래지문 = 원래지문.Replace(":} ", ":}");
            string 바꾼지문 = "";

            Dictionary<string, string> 어휘문제목록해시;
            어휘문제목록해시 = new Dictionary<string, string>();
            List<string> 어휘문제목록 = new List<string>();
            변환.Ansi파일.문자열들로(_문제DB루트폴더 + "voca.qst", ref 어휘문제목록);

            foreach (string 어휘문제목록_항목 in 어휘문제목록)
            {
                string[] 어휘문제목록_항목_배열 = 어휘문제목록_항목.Split(',');

                if (어휘문제목록_항목_배열.Length > 1)
                {
                    if (!어휘문제목록해시.ContainsKey(어휘문제목록_항목_배열[0].ToLower()))
                        어휘문제목록해시.Add(어휘문제목록_항목_배열[0].ToLower(), 어휘문제목록_항목_배열[1].ToLower());

                    if (!어휘문제목록해시.ContainsKey(어휘문제목록_항목_배열[1].ToLower()))
                        어휘문제목록해시.Add(어휘문제목록_항목_배열[1].ToLower(), 어휘문제목록_항목_배열[0].ToLower());
                }
            }

            List<string> 어절들 = new List<string>();

            변환.문자열.탭과개행문자를살린어절들로(원래지문, ref 어절들);

            for(int i = 0 ; i < 어절들.Count; i++)
            {
                string 현재어절 = 어절들[i];
                string 이전어절 = "";
                if(i != 0)        이전어절 = 어절들[i - 1];




                string 불필요문자와문법표지제거한어절 = 현재어절.불필요제거();

//                if (이전어절.Contains("{어법:") || 이전어절.Contains("{어휘:") || 현재어절.Contains("{어법:") || 현재어절.Contains("{어휘:") || 이전어절.Contains(":}") || 현재어절.Contains(":}"))
                if (현재어절.Contains("{어법:") || 현재어절.Contains("{어휘:") || 현재어절.Contains(":}"))
                {
                    바꾼지문 += 현재어절;
                    바꾼지문 += " ";
                }
                else if (현재어절 == "ENTER엔터ENTER")
                {
                    바꾼지문 += "\n";
                }
                else if (현재어절 == "TAB탭TAB")
                {
                    바꾼지문 += "\t";
                }
                else if (어휘문제목록해시.ContainsKey(불필요문자와문법표지제거한어절.ToLower()))
                {
                    바꾼지문 += "{어휘:≠";
                    바꾼지문 += 어휘문제목록해시[불필요문자와문법표지제거한어절.ToLower()];
                    바꾼지문 += ":}";

                    바꾼지문 += 현재어절;
                    바꾼지문 += " ";
                }
                else
                {
                    바꾼지문 += 현재어절;
                    바꾼지문 += " ";
                }

            }
            return 바꾼지문;
        }
        public static string 어법문제출제가능유형찾아표시하기(string 현재지문, string 첫번째단어나품사, string 두번째단어나품사)
        {
            string 바꾼지문 = "";

            List<string> 어절들 = new List<string>();

            변환.문자열.탭과개행문자를살린어절들로(현재지문, ref 어절들);

            for( int i = 0 ; i < 어절들.Count ; i++)
            {
                string 현재어절 = 어절들[i];
                string 불필요문자와문법표지제거한_현재어절 = 현재어절.불필요제거();
                string 불필요문자와문법표지제거한_다음어절 = "";

                if (i + 1 < 어절들.Count)
                {
                    불필요문자와문법표지제거한_다음어절 = 어절들[i+1].불필요제거();
                }

                if (현재어절 == "ENTER엔터ENTER")
                {
                    바꾼지문 += "\n";
                }
                else if (현재어절 == "TAB탭TAB")
                {
                    바꾼지문 += "\t";
                }
                else if (같은지확인(불필요문자와문법표지제거한_현재어절,첫번째단어나품사))
                {
                    if (i + 1 < 어절들.Count)
                    {
                        if (같은지확인(불필요문자와문법표지제거한_다음어절,두번째단어나품사))
                        {
                            바꾼지문 += "{어법}";
                            바꾼지문 += 현재어절;
                            바꾼지문 += " ";
                        }
                        else
                        {
                            바꾼지문 += 현재어절;
                            바꾼지문 += " ";
                        }
                    }
                    else
                    {
                        바꾼지문 += 현재어절;
                        바꾼지문 += " ";
                    }
                }
                else
                {
                    바꾼지문 += 현재어절;
                    바꾼지문 += " ";
                }

            }
            return 바꾼지문;
        }
        public static bool 같은지확인(string 원래단어, string 비교할단어나품사)
        {
            if (원래단어 == 비교할단어나품사) return true;
            else if (비교할단어나품사 == "동명사")
            {
				if (원래단어 == "")
					return false;
				else if (원래단어.Length < 3)
					return false;
				// worth studying과 같은 표현에 대해서 중요표시를 하기 위해서, worth 다음이 ing인지 아닌지를 확인하는 부분인데,
				// from their nutritional worth 처럼 worth로 끝나는 문장이 있다. 이 경우, worth 다음이 없으므로, 없는 것이 ing와 같은지 확인하게 된다.
				// 따라서 아무 것도 없는 것을 비교하러들어오면, 에러를 낼 필요가 있다.
				else if (원래단어.Substring(원래단어.Length - 3) == "ing")
					return true;
				else
					return false;
            }
            else
                return false;
        }
        public static bool 본문_해석_문장숫자확인(string 본문,	string	해석)
        {
	        if(해석 == "")	return false;

            List<string> 본문_문장들 = new List<string>();
	        List<string> 해석_문장들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(본문, ref 본문_문장들);
            강력하지만무거운변환.문자열.문장단위의_문자열들로(해석, ref 해석_문장들);

	        // 영어 원본과, 해석의 문장 숫자가 다르다고 나온 경우이다.
	        if(본문_문장들.Count != 해석_문장들.Count)
	        {

				if (_본문_해석_문장숫자확인여부 == false) // 메시지가 여러번 출력되는 것을 방지한다.
				{
					string 에러메시지 = "";

					for (int i = 0; i < 본문_문장들.Count; i++)
					{
						에러메시지 += "◎";
						에러메시지 += 본문_문장들[i];
						에러메시지 += "\r\n";
					}

					에러메시지 += "\r\n";

					for (int i = 0; i < 해석_문장들.Count; i++)
					{
						에러메시지 += "◎";
						에러메시지 += 해석_문장들[i];
						에러메시지 += "\r\n";
					}

					에러메시지 += "\r\n";

					MessageBox.Show(에러메시지);

					_본문_해석_문장숫자확인여부 = true;
				}
		        return false;
	        }
	        return true;
        }

        public static bool 본문_해석_문장숫자_무조건_확인(string 본문, string 해석)
        {
            if (해석 == "") return false;

            List<string> 본문_문장들 = new List<string>();
            List<string> 해석_문장들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(본문, ref 본문_문장들);
            강력하지만무거운변환.문자열.문장단위의_문자열들로(해석, ref 해석_문장들);

            string 메시지 = "";

            for (int i = 0; i < 본문_문장들.Count; i++)
            {
                메시지 += "◎";
                메시지 += 본문_문장들[i];
                메시지 += "\r\n";
            }

            메시지 += "\r\n";

            for (int i = 0; i < 해석_문장들.Count; i++)
            {
                메시지 += "◎";
                메시지 += 해석_문장들[i];
                메시지 += "\r\n";
            }

            메시지 += "\r\n";



            // 영어 원본과, 해석의 문장 숫자가 다르다고 나온 경우이다.
            if (본문_문장들.Count != 해석_문장들.Count)
            {
                MessageBox.Show("한영문장숫자가 다릅니다.\n----------\n" + 메시지);

                return false;

            }
            else
            {
                MessageBox.Show("한영문장숫자가 같습니다.\n----------\n" + 메시지);

                return true;
            }
        }
        public static string 중의어(string 본문, string 해석)
        {
	        // if(!본문_해석_문장숫자확인(본문, 해석)) return "";

			List<string> 한번쓴_중의어문제 = new List<string>();


			List<string> 본문_문장들 = new List<string>();
	        List<string> 해석_문장들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(본문, ref 본문_문장들);
            강력하지만무거운변환.문자열.문장단위의_문자열들로(해석, ref 해석_문장들);

			본문_해석_문장숫자_강제로_맞추기(ref 본문_문장들, ref 해석_문장들);

	        중의어_데이터로딩();
	
	        string result = "";

	        for(int i = 0 ;i < 본문_문장들.Count ; i++)
	        {
                List<string> 중의어_찾기용_단어들 = new List<string>();
	            List<string> 원래_단어들 = new List<string>();

                변환.문자열.중의어찾기용단어들로(ref 중의어_찾기용_단어들, ref 원래_단어들, 본문_문장들[i]);



		        for(int j = 0 ; j < 중의어_찾기용_단어들.Count() ; j++)
		        {
					if (!한번쓴_중의어문제.Contains(중의어_찾기용_단어들[j]))
					{

						string 중의어_단어에만_격자가_있는_본문 = 중의어_단어에만_격자가_있는_본문구하기(i, j, 본문);
						string 지금만들어진_중의어문제 = 중의어_문제를_영단어와_단어가_포함된_문장의_해석으로부터_출제하기(중의어_찾기용_단어들[j], 해석_문장들[i], 중의어_단어에만_격자가_있는_본문, 해석);

						if (지금만들어진_중의어문제 != "")
						{
							한번쓴_중의어문제.Add(중의어_찾기용_단어들[j]);
						}
						result += 지금만들어진_중의어문제;

					}
		        }
	        }



	        return result;

        }

		public static string 분위기(string 본문, string 해석)
		{
            if (!본문.Contains("{분위기:")) return "";

            string 처리결과 = "";

            처리결과 += "<CAKE>\r";
            처리결과 += "\t<Q> " + _현재번호 + ". 다음 글의 상황에 나타난 분위기로 가장 적절한 것은? </Q> \r";
            처리결과 += "\t<T>\r";
            처리결과 += "\t" + 변환.문자열.문법문제표지제거(본문) + "\r";
            처리결과 += "\t</T>\r";
			처리결과 += 분위기보기와정답(본문);

            처리결과 += "\t<해석>\r";
            처리결과 += "\t" + 해석 + "\r";
            처리결과 += "\t</해석>\r";

            처리결과 += "</CAKE>\r";

            _현재번호++;

            return 처리결과;
		}

		public static string 분위기보기와정답(string 본문)
		{
			string 처리결과 = "";

			if (본문.Contains("{분위기:desperate:}"))
			{
				처리결과 += "\t<A>\r";
				처리결과 += "\t<A1> calm </A1>\r";
				처리결과 += "\t<A2> festive </A2>\r";
				처리결과 += "\t<A3> amusing </A3>\r";
				처리결과 += "\t<A4> desperate </A4>\r";
				처리결과 += "\t<A5> promising </A5>\r";
				처리결과 += "\t</A>\r";

				처리결과 += "\t<정답>\r";
				처리결과 += "\t정답 ④번\r";
				처리결과 += "\t</정답>\r";

				return 처리결과;
			}
			else if (본문.Contains("{분위기:urgent:}"))
			{
				처리결과 += "\t<A>\r";
				처리결과 += "\t<A1> merry </A1>\r";
				처리결과 += "\t<A2> peaceful </A2>\r";
				처리결과 += "\t<A3> urgent </A3>\r";
				처리결과 += "\t<A4> hopeful </A4>\r";
				처리결과 += "\t<A5> boring </A5>\r";
				처리결과 += "\t</A>\r";

				처리결과 += "\t<정답>\r";
				처리결과 += "\t정답 ③번\r";
				처리결과 += "\t</정답>\r";

				return 처리결과;
			}
			else if (본문.Contains("{분위기:gloomy:}"))
			{
				처리결과 += "\t<A>\r";
				처리결과 += "\t<A1> lively </A1>\r";
				처리결과 += "\t<A2> gloomy </A2>\r";
				처리결과 += "\t<A3> relieved </A3>\r";
				처리결과 += "\t<A4> contended </A4>\r";
				처리결과 += "\t<A5> relaxed </A5>\r";
				처리결과 += "\t</A>\r";

				처리결과 += "\t<정답>\r";
				처리결과 += "\t정답 ②번\r";
				처리결과 += "\t</정답>\r";

				return 처리결과;
			}
			else if (본문.Contains("{분위기:tense:}"))
			{
				처리결과 += "\t<A>\r";
				처리결과 += "\t<A1> tense </A1>\r";
				처리결과 += "\t<A2> monotonous </A2>\r";
				처리결과 += "\t<A3> generous </A3>\r";
				처리결과 += "\t<A4> melancholy </A4>\r";
				처리결과 += "\t<A5> boring </A5>\r";
				처리결과 += "\t</A>\r";

				처리결과 += "\t<정답>\r";
				처리결과 += "\t정답 ①번\r";
				처리결과 += "\t</정답>\r";

				return 처리결과;

			}
			else if (본문.Contains("{분위기:envious:}"))
			{
				처리결과 += "\t<A>\r";
				처리결과 += "\t<A1> optimistic </A1>\r";
				처리결과 += "\t<A2> encouraging </A2>\r";
				처리결과 += "\t<A3> indifferent </A3>\r";
				처리결과 += "\t<A4> regretful </A4>\r";
				처리결과 += "\t<A5> envious </A5>\r";
				처리결과 += "\t</A>\r";

				처리결과 += "\t<정답>\r";
				처리결과 += "\t정답 ⑤번\r";
				처리결과 += "\t</정답>\r";

				return 처리결과;

			}
			else if (본문.Contains("{분위기:jealous:}"))
			{
				처리결과 += "\t<A>\r";
				처리결과 += "\t<A1> apologetic </A1>\r";
				처리결과 += "\t<A2> satisfied </A2>\r";
				처리결과 += "\t<A3> hopeful </A3>\r";
				처리결과 += "\t<A4> pleased </A4>\r";
				처리결과 += "\t<A5> jealous </A5>\r";
				처리결과 += "\t</A>\r";

				처리결과 += "\t<정답>\r";
				처리결과 += "\t정답 ⑤번\r";
				처리결과 += "\t</정답>\r";

				return 처리결과;
			}
			else if (본문.Contains("{분위기:content:}"))
			{
				처리결과 += "\t<A>\r";
				처리결과 += "\t<A1> content </A1>\r";
				처리결과 += "\t<A2> miserable </A2>\r";
				처리결과 += "\t<A3> resentful </A3>\r";
				처리결과 += "\t<A4> horrified </A4>\r";
				처리결과 += "\t<A5> disgusted </A5>\r";
				처리결과 += "\t</A>\r";

				처리결과 += "\t<정답>\r";
				처리결과 += "\t정답 ①번\r";
				처리결과 += "\t</정답>\r";

				return 처리결과;
			}

			else
			{
				MessageBox.Show("분위기 태그에 오류가 있습니다.");
				return "";
			}
		}

        public static string 빈칸주제영작(string 본문, string 해석, string 파일헤더)
        {
            if (!본문.Contains("{주제}")) return "";
            if (!본문.Contains("{/주제}")) return "";

            if (본문.IndexOf("{주제}") > 본문.IndexOf("{/주제}")) return "";

            string 만들어진문제 = 본문.Substring(0, 본문.IndexOf("{주제}")) + "______" + 본문.Substring(본문.IndexOf("{/주제}") + 5);

            만들어진문제 = 변환.문자열.문법문제표지제거(만들어진문제);

            string 정답 = 본문.Substring(본문.IndexOf("{주제}") + 4, 본문.IndexOf("{/주제}") - 본문.IndexOf("{주제}") - 4);
            정답 = 변환.문자열.문법문제표지제거(정답);

            string 처리결과 = "";

            처리결과 += "<CAKE>\r";
            처리결과 += "\t<Q> " + _현재번호 + ". 다음 글을 읽고, 빈칸에 적절한 말을 넣어 글의 주제를 완성하시오. </Q> \r";
            처리결과 += "\t<T>\r";
            처리결과 += "\t" + 만들어진문제 + "\r";
            처리결과 += "\t</T>\r";
            처리결과 += "\t<정답>\r";
            처리결과 += "\t정답 : " + 정답 + "\r";
            처리결과 += "\t</정답>\r";
            처리결과 += "\t<해석>\r";
            처리결과 += "\t" + 해석 + "\r";
            처리결과 += "\t</해석>\r";

            처리결과 += "</CAKE>\r";

            _현재번호++;

            return 처리결과;
        }

		public static void 분사구문_영작문제내기(string 태그있는본문, ref List<string> 문자열들)
		{
			string 태그있는본문_원문 = 태그있는본문;

			string 분사구문맨첫단어 = "";
			while(태그있는본문.Contains("ⓧ{ⓥ{"))
			{
				분사구문맨첫단어 = 태그있는본문.Substring(태그있는본문.IndexOf("ⓧ{ⓥ{") + 4);

				if (분사구문맨첫단어.Contains(" "))
				{
					태그있는본문 = 분사구문맨첫단어.Substring(분사구문맨첫단어.IndexOf(" ") + 1); // 이후의 분사구문도 찾기 위해서 뱅뱅돌려야 한다.

					분사구문맨첫단어 = 변환.문자열.문법문제표지제거(분사구문맨첫단어);

					분사구문맨첫단어 = 분사구문맨첫단어.Substring(0, 분사구문맨첫단어.IndexOf(" "));

					MessageBox.Show(분사구문맨첫단어 + ": 분사구문 영작 문제로 추가합니다.");
					문자열들.Add(분사구문맨첫단어);

				}
				else
					break;
			}

			태그있는본문 = 태그있는본문_원문;

			while(태그있는본문.Contains("ⓧ{ⓒ{"))
			{
				분사구문맨첫단어 = 태그있는본문.Substring(태그있는본문.IndexOf("ⓧ{ⓒ{") + 4);

				if (분사구문맨첫단어.Contains(" "))
				{
					태그있는본문 = 분사구문맨첫단어.Substring(분사구문맨첫단어.IndexOf(" ") + 1); // 이후의 분사구문도 찾기 위해서 뱅뱅돌려야 한다.

					분사구문맨첫단어 = 변환.문자열.문법문제표지제거(분사구문맨첫단어);

					분사구문맨첫단어 = 분사구문맨첫단어.Substring(0, 분사구문맨첫단어.IndexOf(" "));

					MessageBox.Show(분사구문맨첫단어 + ": 분사구문 영작 문제로 추가합니다.");
					문자열들.Add(분사구문맨첫단어);

				}
				else
					break;
			}
		}

		public static int 상관관계측정값(ref List<string>본문_문장들_임시, ref List<string>해석_문장들)
		{
			int 측정값 = 0;

			for(int i = 0; i < 본문_문장들_임시.Count; i++)
			{
				측정값 += Math.Abs(본문_문장들_임시[i].Length - 해석_문장들[i].Length);
			}

			return 측정값;
		}

		public static void 본문_해석_문장숫자_강제로_맞추기(ref List<string>본문_문장들, ref List<string>해석_문장들)
		{
			if (본문_문장들.Count == 해석_문장들.Count)				return;


			int 현재상관관계측정값 = 0;
			int 가장작은상관관계측정값 = 10000;

			List<string> 본문_문장들_임시 = new List<string>();
			List<string> 본문_문장들_상관관계가_가장_큰 = new List<string>();

			List<string> 해석_문장들_임시 = new List<string>();
			List<string> 해석_문장들_상관관계가_가장_큰 = new List<string>();

			// 문장들의 숫자가 다르면, 문장들의 길이를 감안하여, 이리저리 붙혀본다.
			// 1. 문장들의 숫자가 하나만 다르면,
			//		긴 문장의 문장들을 차례대로 두 개씩 연결한다.
			//		그 다음 다른 문장들과, 길이의 '상관관계'를 측정하여, 상관관계가 가장 큰 조합을 추출한다.
			if(본문_문장들.Count > 해석_문장들.Count)
			{
				if(본문_문장들.Count - 해석_문장들.Count == 1)
				{
					for(int i = 0; i < 본문_문장들.Count - 1; i++)
					{
						본문_문장들_임시.Clear();

						for (int j = 0; j < 본문_문장들.Count; j++)
						{
							if(i == j)
							{
								본문_문장들_임시.Add(본문_문장들[j] + " " + 본문_문장들[j+1]);
								j++;
							}
							else
							{
								본문_문장들_임시.Add(본문_문장들[j]);
							}

						}

						현재상관관계측정값 = 상관관계측정값(ref 본문_문장들_임시, ref 해석_문장들);

						if(가장작은상관관계측정값 > 현재상관관계측정값)
						{
							본문_문장들_상관관계가_가장_큰.Clear();

							for(int j = 0; j < 본문_문장들_임시.Count; j++)
							{
								본문_문장들_상관관계가_가장_큰.Add(본문_문장들_임시[j]);
							}

							가장작은상관관계측정값 = 현재상관관계측정값;
						}
					}

					본문_문장들.Clear();

					for(int i = 0; i < 본문_문장들_상관관계가_가장_큰.Count; i++)
					{
						본문_문장들.Add(본문_문장들_상관관계가_가장_큰[i]);
					}
				}
				else
				{
					if (_본문_해석_문장숫자확인여부 == false) // 메시지가 여러번 출력되는 것을 방지한다.
					{
						string 에러메시지 = "";

						for (int i = 0; i < 본문_문장들.Count; i++)
						{
							에러메시지 += "◎";
							에러메시지 += 본문_문장들[i];
							에러메시지 += "\r\n";
						}

						에러메시지 += "\r\n";

						for (int i = 0; i < 해석_문장들.Count; i++)
						{
							에러메시지 += "◎";
							에러메시지 += 해석_문장들[i];
							에러메시지 += "\r\n";
						}

						에러메시지 += "\r\n";

						MessageBox.Show(에러메시지);

						_본문_해석_문장숫자확인여부 = true;
					}
				}
			}
			else
			{
				if(해석_문장들.Count - 본문_문장들.Count == 1)
				{
					for(int i = 0; i < 해석_문장들.Count - 1; i++)
					{
						해석_문장들_임시.Clear();

						for (int j = 0; j < 해석_문장들.Count; j++)
						{
							if(i == j)
							{
								해석_문장들_임시.Add(해석_문장들[j] + " " + 해석_문장들[j+1]);
								j++;
							}
							else
							{
								해석_문장들_임시.Add(해석_문장들[j]);
							}
						}

						현재상관관계측정값 = 상관관계측정값(ref 해석_문장들_임시, ref 본문_문장들);

						if(가장작은상관관계측정값 > 현재상관관계측정값)
						{
							해석_문장들_상관관계가_가장_큰.Clear();

							for(int j = 0; j < 해석_문장들_임시.Count; j++)
							{
								해석_문장들_상관관계가_가장_큰.Add(해석_문장들_임시[j]);
							}

							가장작은상관관계측정값 = 현재상관관계측정값;
						}
					}

					해석_문장들.Clear();

					for(int i = 0; i < 해석_문장들_상관관계가_가장_큰.Count; i++)
					{
						해석_문장들.Add(해석_문장들_상관관계가_가장_큰[i]);
					}
				}
				else
				{
					if (_본문_해석_문장숫자확인여부 == false) // 메시지가 여러번 출력되는 것을 방지한다.
					{
						string 에러메시지 = "";

						for (int i = 0; i < 본문_문장들.Count; i++)
						{
							에러메시지 += "◎";
							에러메시지 += 본문_문장들[i];
							에러메시지 += "\r\n";
						}

						에러메시지 += "\r\n";

						for (int i = 0; i < 해석_문장들.Count; i++)
						{
							에러메시지 += "◎";
							에러메시지 += 해석_문장들[i];
							에러메시지 += "\r\n";
						}

						에러메시지 += "\r\n";

						MessageBox.Show(에러메시지);

						_본문_해석_문장숫자확인여부 = true;
					}
				}
			}
		}

        public static string 영작문제내기(string 태그있는본문, string 해석, string 파일헤더)
		{
			string 처리결과 = "";

			string 본문 = 변환.문자열.문법문제표지제거(태그있는본문); 

			List<string> 본문_문장들 = new List<string>();
			List<string> 해석_문장들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(본문, ref 본문_문장들);
            강력하지만무거운변환.문자열.문장단위의_문자열들로(해석, ref 해석_문장들);

			본문_해석_문장숫자_강제로_맞추기(ref 본문_문장들, ref 해석_문장들);
			//if (!본문_해석_문장숫자확인(본문, 해석)) return "";


			List<string> 영작데이터들 = new List<string>();
			if (파일헤더.Contains("중1"))
				변환.Ansi파일.문자열들로(_문제DB루트폴더 + "영작_주관식_중1.문제", ref 영작데이터들);
			else if (파일헤더.Contains("중2"))
				변환.Ansi파일.문자열들로(_문제DB루트폴더 + "영작_주관식_중2.문제", ref 영작데이터들);
			else if (파일헤더.Contains("중3"))
				변환.Ansi파일.문자열들로(_문제DB루트폴더 + "영작_주관식_중3.문제", ref 영작데이터들);
			else if (파일헤더.Contains("고1"))
				변환.Ansi파일.문자열들로(_문제DB루트폴더 + "영작_주관식_고.문제", ref 영작데이터들);
			else if (파일헤더.Contains("고2"))
				변환.Ansi파일.문자열들로(_문제DB루트폴더 + "영작_주관식_고.문제", ref 영작데이터들);
			else if (파일헤더.Contains("고3"))
				변환.Ansi파일.문자열들로(_문제DB루트폴더 + "영작_주관식_고.문제", ref 영작데이터들);

			분사구문_영작문제내기(태그있는본문, ref 영작데이터들);




			for (int i = 0; i < 본문_문장들.Count; i++)
			{
				string 현재본문문장 = 본문_문장들[i];
				string 현재해석문장 = 해석_문장들[i];

				foreach (string 현재영작데이터 in 영작데이터들)
				{
					if (변환.문자열.Contains강력(현재본문문장, 현재영작데이터))
					{

						// 현재 영작 데이터보다 더 내용이 긴 영작데이터가 있다면, 지금 영작은 문제로 내면 안된다.
						bool 현재영작데이터보다내용긴게있는지 = false;

						foreach (string 현재영작보다긴것 in 영작데이터들)
						{
							if (변환.문자열.Contains강력(현재본문문장, 현재영작보다긴것))
							{
								if (현재영작데이터 != 현재영작보다긴것 && 현재영작보다긴것.Contains(현재영작데이터))
								{
									현재영작데이터보다내용긴게있는지 = true;
								}
							}
						}

						if (현재영작데이터보다내용긴게있는지 == false)
						{
							int 문장dna = 현재문장DNA(현재본문문장);

							string 정답 = "";
							string 만들어진문제 = 현재본문문장영작문제로만들기(현재본문문장, 현재영작데이터, 문장dna, ref 정답);

							if (만들어진문제 != "")
							{

								처리결과 += "<CAKE>\r";
								처리결과 += "\t<Q> " + _현재번호 + ". 단어를 배열하여 영작하되, 필요하면 어형을 바꾸시오. </Q> \r";
								처리결과 += "\t<T>\r";
								처리결과 += "\t" + 만들어진문제 + "\r";
								처리결과 += "\t<TBAR></TBAR>\r";
								처리결과 += "\t" + 현재해석문장 + "\r";
								처리결과 += "\t</T>\r";
								처리결과 += "\t<정답>\r";
								처리결과 += "\t정답 : " + 정답 + "\r";
								처리결과 += "\t</정답>\r";
								처리결과 += "</CAKE>\r";

								_현재번호++;

							}
						}
					}
				}
			}

			return 처리결과;

		}


		//………………………………………………………………………………………………………………………………
		//   0   1  2   3
		// This is my life. 의 경우,맨 처음 startIdx의 크기가 5가 되면, is가 시작일거임.
		// 얼핏보면 순서가 눈에 잘 보이지 않지만, 곰곰히 들여다보면, 순서를 알 수 있게 해준다
		//………………………………………………………………………………………………………………………………
		public static string 현재본문문장영작문제로만들기(string 현재본문문장, string 현재영작데이터, int 문장dna, ref string 정답)
		{
			string 끝의기호들 = "";
			string 현재본문문장에서_영작데이터의_왼쪽부분 = 현재본문문장.Substring(0, 현재본문문장.IndexOf(현재영작데이터));
			string 현재본문문장에서_영작데이터를_포함한_오른쪽부분 = 현재본문문장.Substring(현재본문문장.IndexOf(현재영작데이터));

			string 결과 = 현재본문문장에서_영작데이터의_왼쪽부분;

			List<string> 어절들 = new List<string>();

			변환.문자열.어절들로(현재본문문장에서_영작데이터를_포함한_오른쪽부분, ref 어절들);

			if (어절들.Count <= 2)
			{
				return "";
			}
			else if (어절들.Count <= 6 ) 
			{
				for (int j = 0; j < 어절들.Count; j++) 
				{
					if (j != 어절들.Count - 1)
					{
						정답 += 어절들[j];
						정답 += " ";
					}
					else
					{
						string 남은어절 = "";
						끝의기호들 = 어절들[j].어절에서끝의기호분리(ref 남은어절);

						if (끝의기호들 != "")
						{
							
							정답 += 어절들[j].Substring(0, 어절들[j].Count() - 끝의기호들.Count());
						}
						else
						{
							정답 += 어절들[j];
						}
					}

				}

				List<string> 순서바뀐어절들 = new List<string>();

				for(int j = 0; j < 어절들.Count; j++){ 순서바뀐어절들.Add(""); }

				int 현재인덱스 = 문장dna % 어절들.Count;

				순서바뀐어절들[현재인덱스] = 어절들[0];
				현재인덱스 = (현재인덱스 + 현재단어DNA(어절들[0])) % 어절들.Count;
				

				for (int j = 1; j < 어절들.Count; j++)
				{
					while (순서바뀐어절들[현재인덱스] != "")
					{
						현재인덱스++;
						if (현재인덱스 == 어절들.Count)
							현재인덱스 = 0;
                    }

					순서바뀐어절들[현재인덱스] = 어절들[j];
					현재인덱스 = (현재인덱스 + 현재단어DNA(어절들[j])) % 어절들.Count;
				}

				결과 += "(";
                for (int j = 0; j < 순서바뀐어절들.Count; j++)
				{
					string 추가할어절 = 변환.문자열.불필요문자제거(순서바뀐어절들[j]);
					string 원형사전검색결과 = _검색.원형사전(추가할어절);
					string 부사를형용사로바꾸는변환결과 = _검색.부사를형용사로(추가할어절);

					if(원형사전검색결과 != "")
					{
						결과 += 원형사전검색결과;
					}
					else if(부사를형용사로바꾸는변환결과 != "")
					{
						결과 += 부사를형용사로바꾸는변환결과;
					}
					else
					{
						결과 += 추가할어절;
					}

					if( j != 순서바뀐어절들.Count - 1) 
						결과 += ", ";
                }
				결과 += ")";
				if (끝의기호들 != "") 결과 += 끝의기호들;
	

				if (정답.Contains(":"))
				{
					정답 = ""; 결과 = "";
				}
				return 결과;
			}

			else // 6개가 넘어가면 너무 길어서 영작을 하는게 아니라 퀴즈가 된다. 따라서 6개만 잘라주는 과정을 거친다.
			{
				// 맨 뒤에 .이나 ,가 있는 경우 이것을 문제의 정답에서 자동으로 빼주도록 하자.

				for (int j = 0; j < 6; j++)
				{
					if (j != 5)
					{
						정답 += 어절들[j];
						정답 += " ";
					}
					else
					{
						string 남은어절 = "";
						끝의기호들 = 어절들[j].어절에서끝의기호분리(ref 남은어절);

						if (끝의기호들 != "")
						{
							정답 += 어절들[j].Substring(0, 어절들[j].Count() -끝의기호들.Count());
						}
						else
						{
							정답 += 어절들[j];
						}
					}
				}

				List<string> 순서바뀐어절들 = new List<string>();

				for (int j = 0; j < 6; j++){ 순서바뀐어절들.Add(""); }

				int 현재인덱스 = 문장dna % 6;

				순서바뀐어절들[현재인덱스] = 어절들[0];
				현재인덱스 = (현재인덱스 + 현재단어DNA(어절들[0])) % 6;

				for (int j = 1; j < 6; j++)
				{
					while (순서바뀐어절들[현재인덱스] != "")
					{
						현재인덱스++;
						if (현재인덱스 == 6)
							현재인덱스 = 0;
					}

					순서바뀐어절들[현재인덱스] = 어절들[j];
					현재인덱스 = (현재인덱스 + 현재단어DNA(어절들[j])) % 6;
				}

				결과 += "(";
				for (int j = 0; j < 순서바뀐어절들.Count; j++)
				{
					string 추가할어절 = 변환.문자열.불필요문자제거(순서바뀐어절들[j]);
					string 원형사전검색결과 = _검색.원형사전(추가할어절);
					string 부사를형용사로바꾸는변환결과 = _검색.부사를형용사로(추가할어절);

					if(원형사전검색결과 != "")
					{
						결과 += 원형사전검색결과;
					}
					else if(부사를형용사로바꾸는변환결과 != "")
					{
						결과 += 부사를형용사로바꾸는변환결과;
					}
					else
					{
						결과 += 추가할어절;
					}

					if (j != 순서바뀐어절들.Count - 1)
						결과 += ", ";
				}
				결과 += ")";
				if (끝의기호들 != "") 결과 += 끝의기호들;
				결과 += " ";


				for (int j = 6; j < 어절들.Count; j++)
				{
					결과 += 어절들[j];

					if (j != 어절들.Count - 1)
						결과 += " ";
				}

				if (정답.Contains(":"))
				{
					정답 = ""; 결과 = "";
				}

				return 결과;

			}
		}




		// 주어진 단어의 첫번째 글자를 확인하여, 고유값을 계산해 내는 함수입니다.
		public static int 현재단어DNA(string 단어)
		{
			단어 = 단어.Replace(".", "");
			단어 = 단어.Replace(",", "");
			단어 = 단어.Replace("\"", "");
			단어 = 단어.Replace("\'", "");
			단어 = 단어.Replace("?", "");
			단어 = 단어.Replace("!", "");
			단어 = 단어.Replace(":", "");
			단어 = 단어.Replace(";", "");
			단어 = 단어.Replace("(", "");
			단어 = 단어.Replace(")", "");
			단어 = 단어.Replace("‘", "");
			단어 = 단어.Replace("’", "");
			단어 = 단어.Replace("“", "");
			단어 = 단어.Replace("”", "");
			단어 = 단어.Replace("*", "");

			string key;
			if (단어 != "") { key = 단어.Substring(0, 1); }
			else { key = ""; }

			key = key.ToUpper();

			if (key == "A") return 5;
			else if (key == "B") return 3;
			else if (key == "C") return 2;
			else if (key == "D") return 2;
			else if (key == "E") return 6;
			else if (key == "F") return 5;
			else if (key == "G") return 4;
			else if (key == "H") return 6;
			else if (key == "I") return 2;
			else if (key == "J") return 2;
			else if (key == "K") return 5;
			else if (key == "L") return 3;
			else if (key == "M") return 5;
			else if (key == "N") return 4;
			else if (key == "O") return 0;
			else if (key == "P") return 3;
			else if (key == "Q") return 3;
			else if (key == "R") return 4;
			else if (key == "S") return 2;
			else if (key == "T") return 4;
			else if (key == "U") return 2;
			else if (key == "V") return 3;
			else if (key == "W") return 5;
			else if (key == "X") return 5;
			else if (key == "Y") return 4;
			else if (key == "Z") return 4;
			else if (key == "") return 0;

			return 0;
		}

		public static int 현재문장DNA(string 문장)
		{
			List<string> 어절들 = new List<string>();

			변환.문자열.어절들로(문장, ref 어절들);

			string 맨처음어절 = "";

			if (어절들.Count < 2)
				return 0;

			맨처음어절 = 어절들[1];

			return 현재단어DNA(맨처음어절);

		}


        public static string 주관식_빈칸(string 본문, string 해석, string 파일헤더)
        {
            string 처리결과 = "";

            //if (!본문_해석_문장숫자확인(본문, 해석)) return "";

			#region 데이터

			List<string> 핵심어구데이터들 = new List<string>();
            if(파일헤더.Contains("중1"))
                변환.Ansi파일.문자열들로(_문제DB루트폴더 + "빈칸_주관식_중1.문제", ref 핵심어구데이터들);
            else if (파일헤더.Contains("중2"))
                변환.Ansi파일.문자열들로(_문제DB루트폴더 + "빈칸_주관식_중2.문제", ref 핵심어구데이터들);
            else if (파일헤더.Contains("중3"))
                변환.Ansi파일.문자열들로(_문제DB루트폴더 + "빈칸_주관식_중3.문제", ref 핵심어구데이터들);
            else if (파일헤더.Contains("고1"))
                변환.Ansi파일.문자열들로(_문제DB루트폴더 + "빈칸_주관식_고.문제", ref 핵심어구데이터들);
            else if (파일헤더.Contains("고2"))
                변환.Ansi파일.문자열들로(_문제DB루트폴더 + "빈칸_주관식_고.문제", ref 핵심어구데이터들);
            else if (파일헤더.Contains("고3"))
                변환.Ansi파일.문자열들로(_문제DB루트폴더 + "빈칸_주관식_고.문제", ref 핵심어구데이터들);

			#endregion

			#region 본문과해석문장들로
			List<string> 본문_문장들 = new List<string>();
            List<string> 해석_문장들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(본문, ref 본문_문장들);
            강력하지만무거운변환.문자열.문장단위의_문자열들로(해석, ref 해석_문장들);
			#endregion

			본문_해석_문장숫자_강제로_맞추기(ref 본문_문장들, ref 해석_문장들);


			for (int i = 0 ; i < 본문_문장들.Count; i++)
            {
                string 현재본문문장 = 본문_문장들[i];
                string 현재해석문장 = 해석_문장들[i];

                foreach(string 현재핵심어구데이터 in 핵심어구데이터들)
                {
                    if (변환.문자열.Contains강력(현재본문문장, 현재핵심어구데이터))
                    {

						#region 현재 핵심어구 데이터보다 더 내용이 긴 것은 문제로 내면 안된다.
						bool 현재핵심어구데이터보다내용긴게있는지 = false;

                        foreach (string 현재핵심어구보다긴것 in 핵심어구데이터들)
                        {
                            if(변환.문자열.Contains강력(현재본문문장, 현재핵심어구보다긴것))
                            {
                                if (현재핵심어구데이터 != 현재핵심어구보다긴것 && 현재핵심어구보다긴것.Contains(현재핵심어구데이터))
                                {
                                    현재핵심어구데이터보다내용긴게있는지 = true;
                                }
                            }
                        }
						#endregion

						if (현재핵심어구데이터보다내용긴게있는지 == false)
                        {

                            처리결과 += "<CAKE>\r";
                            처리결과 += "\t<Q> " + _현재번호 + ". 본문의 내용과 뜻이 같도록 빈칸을 채우시오. </Q> \r";
                            처리결과 += "\t<T>\r";

                            string 핵심어구데이터에서문장부호만뺀것 = 현재핵심어구데이터;
                            핵심어구데이터에서문장부호만뺀것 = 핵심어구데이터에서문장부호만뺀것.Replace("?", "");
                            핵심어구데이터에서문장부호만뺀것 = 핵심어구데이터에서문장부호만뺀것.Replace(".", "");
                            핵심어구데이터에서문장부호만뺀것 = 핵심어구데이터에서문장부호만뺀것.Replace("!", "");

							List<string> 핵심어구데이터_어절들로 = new List<string>();
							string 글자수감안한빈칸 = "";

                            변환.문자열.어절들로(핵심어구데이터에서문장부호만뺀것, ref 핵심어구데이터_어절들로);
							for(int j = 0; j < 핵심어구데이터_어절들로.Count; j++)
							{
								글자수감안한빈칸 += "(" + 핵심어구데이터_어절들로[j].Substring(0,1) +  ")______ ";
                            }
							글자수감안한빈칸 = 글자수감안한빈칸.Trim();

                            string 빈칸있는본문 = 현재본문문장.Replace(핵심어구데이터에서문장부호만뺀것, 글자수감안한빈칸).Trim();

                            //빈칸있는본문 = 빈칸있는본문.Replace(" ______ ?", " ______?");
                            //빈칸있는본문 = 빈칸있는본문.Replace(" ______ .", " ______.");

                            처리결과 += "\t" + 빈칸있는본문 + "\r";

                            처리결과 += "\t<TBAR></TBAR>\r";
                            처리결과 += "\t" + 현재해석문장 + "\r";
                            처리결과 += "\t</T>\r";
                            처리결과 += "\t<정답>\r";
                            처리결과 += "\t정답 : " + 핵심어구데이터에서문장부호만뺀것 + "\r";
                            처리결과 += "\t</정답>\r";
                            처리결과 += "</CAKE>\r";

                            _현재번호++;
                        }
                    }
                    else if(현재핵심어구데이터.Contains(","))
                    {
                        string [] 현재핵심어구데이터들 = 현재핵심어구데이터.Split(',');

                        bool 문장내에모두있는지 = true;
                        for (int k = 0; k < 현재핵심어구데이터들.Count(); k++)
                        {
                            if (!변환.문자열.Contains강력(현재본문문장, 현재핵심어구데이터들[k]))
                                문장내에모두있는지 = false;
                        }

						bool 문제내기적합 = false;

						if (문장내에모두있는지)
						{
							문제내기적합 = true;

							int 핵심어구데이터위치 = 0;

							for (int k = 0; k < 현재핵심어구데이터들.Count(); k++)
							{
								if (핵심어구데이터위치 < 현재본문문장.IndexOf(현재핵심어구데이터들[k]))
								{
									핵심어구데이터위치 = 현재본문문장.IndexOf(현재핵심어구데이터들[k]);
								}
								else
								{
									문제내기적합 = false;
								}
							}
						}


						if (문제내기적합)
						{ 
							처리결과 += "<CAKE>\r";
                            처리결과 += "\t<Q> " + _현재번호 + ". 본문의 내용과 뜻이 같도록 빈칸을 채우시오. </Q> \r";
                            처리결과 += "\t<T>\r";
                            string 빈칸있는본문 = 현재본문문장;

							string 바꿀포맷 = "";
                            for (int k = 0; k < 현재핵심어구데이터들.Count(); k++)
                            {

								List<string> 핵심어구데이터_어절들로 = new List<string>();
								string 글자수감안한빈칸 = "";

								변환.문자열.어절들로(현재핵심어구데이터들[k], ref 핵심어구데이터_어절들로);
								for (int j = 0; j < 핵심어구데이터_어절들로.Count; j++)
								{
									글자수감안한빈칸 += "______ ";
								}
								글자수감안한빈칸 = 글자수감안한빈칸.Trim();


								바꿀포맷 = String.Format("({0}){1}", k + 1, 글자수감안한빈칸);

								빈칸있는본문 = 빈칸있는본문.Replace(현재핵심어구데이터들[k], 바꿀포맷).Replace("  ", " ");
							}


							//빈칸있는본문 = 빈칸있는본문.Replace(" " + 바꿀포맷 + " ?", " " + 바꿀포맷 + "?");
							//빈칸있는본문 = 빈칸있는본문.Replace(" " + 바꿀포맷 + " .", " " + 바꿀포맷 + ".");

                            처리결과 += "\t" + 빈칸있는본문 + "\r";

                            처리결과 += "\t<TBAR></TBAR>\r";
                            처리결과 += "\t" + 현재해석문장 + "\r";
                            처리결과 += "\t</T>\r";
                            처리결과 += "\t<정답>\r";
                            처리결과 += "\t정답 : " + 현재핵심어구데이터.Replace(",", ", ").Replace("  ", " ") + "\r";
                            처리결과 += "\t</정답>\r";
                            처리결과 += "</CAKE>\r";

                            _현재번호++;
                        }

                    }
                }
            }

            return 처리결과;
        }
        // letter|글자,문자|a symbol or character that is conventionally used in writing and printing to represent a speech sound and that is part of an alphabet.
        // 위의 예와 같이 한글의 뜻은 '글자', '문자'처럼 둘 이상일 수 있으므로, 한글뜻들을 나누어서 검색해봅니다.
        private static string 중의어_문제를_영단어와_단어가_포함된_문장의_해석으로부터_출제하기(string 영단어, string 단어가_포함된_문장의_해석, string 본문, string 해석)
        {
	        int 올바른_정답의_갯수 = 0; // 올바른 정답의 갯수가 0개이거나, 특히 두 개 이상인 경우에는 이중 정답의 위험성이 있으므로 출제하지 않습니다.
	        string 올바른_정답 = "";

	        string 중의어_1_영어풀이 = "";
	        string 중의어_2_영어풀이 = "";
	        string 중의어_3_영어풀이 = "";
	        string 중의어_4_영어풀이 = "";
	        string 중의어_5_영어풀이 = "";
	        string 중의어_1_해설 = "";
	        string 중의어_2_해설 = "";
	        string 중의어_3_해설 = "";
	        string 중의어_4_해설 = "";
	        string 중의어_5_해설 = "";

	        for(int i = 0 ; i < _중의어_영단어.Count(); i++)
	        {
		        if(영단어 == _중의어_영단어[i])
		        {

			        string [] 중의어_1_한글뜻들 = _중의어_1_한글뜻[i].Split(',');

			        for(int k = 0 ; k < 중의어_1_한글뜻들.Count(); k++)
			        {
				        if(단어가_포함된_문장의_해석.Contains(중의어_1_한글뜻들[k]) && (중의어_1_한글뜻들[k] != ""))
				        {
					        올바른_정답 = "정답 ①번";
					        올바른_정답의_갯수++;
				        }
			        }

			        string [] 중의어_2_한글뜻들 = _중의어_2_한글뜻[i].Split(',');

			        for(int k = 0 ; k < 중의어_2_한글뜻들.Count(); k++)
			        {
				        if(단어가_포함된_문장의_해석.Contains(중의어_2_한글뜻들[k]) && (중의어_2_한글뜻들[k] != ""))
				        {
					        올바른_정답 = "정답 ②번";
					        올바른_정답의_갯수++;
				        }
			        }

			        string [] 중의어_3_한글뜻들 = _중의어_3_한글뜻[i].Split(',');

			        for(int k = 0 ; k < 중의어_3_한글뜻들.Count(); k++)
			        {
				        if(단어가_포함된_문장의_해석.Contains(중의어_3_한글뜻들[k]) && (중의어_3_한글뜻들[k] != ""))
				        {
					        올바른_정답 = "정답 ③번";
					        올바른_정답의_갯수++;
				        }
			        }

			        string [] 중의어_4_한글뜻들 = _중의어_4_한글뜻[i].Split(',');

			        for(int k = 0 ; k < 중의어_4_한글뜻들.Count(); k++)
			        {
				        if(단어가_포함된_문장의_해석.Contains(중의어_4_한글뜻들[k]) && (중의어_4_한글뜻들[k] != ""))
				        {
					        올바른_정답 = "정답 ④번";
					        올바른_정답의_갯수++;
				        }
			        }

			        string [] 중의어_5_한글뜻들 = _중의어_5_한글뜻[i].Split(',');

			        for(int k = 0 ; k < 중의어_5_한글뜻들.Count(); k++)
			        {
				        if(단어가_포함된_문장의_해석.Contains(중의어_5_한글뜻들[k]) && (중의어_5_한글뜻들[k] != ""))
				        {
					        올바른_정답 = "정답 ⑤번";
					        올바른_정답의_갯수++;
				        }
			        }

			        중의어_1_영어풀이 = _중의어_1_영어풀이[i];
			        중의어_2_영어풀이 = _중의어_2_영어풀이[i];
			        중의어_3_영어풀이 = _중의어_3_영어풀이[i];
			        중의어_4_영어풀이 = _중의어_4_영어풀이[i];
			        중의어_5_영어풀이 = _중의어_5_영어풀이[i];

			        중의어_1_해설 = _중의어_1_해설[i];
			        중의어_2_해설 = _중의어_2_해설[i];
			        중의어_3_해설 = _중의어_3_해설[i];
			        중의어_4_해설 = _중의어_4_해설[i];
			        중의어_5_해설 = _중의어_5_해설[i];

		        }
	        }


	        //----------------------------------------------------------------------------------------------------------------
	        // 문제를 만드는 부분

	        string result = "";

	        if(올바른_정답의_갯수 == 1)
	        {
		        본문 = 본문.Trim();
		        result += "<CAKE>\r";

		        result += "\t<Q> " + _현재번호 + ". 다음 문장에서 쓰인 \'" + 영단어 + "\'의 의미로 가장 적절한 것은? </Q>\r";
		        result += "\t<T>\r";


		        result += "\t";
		        result += 본문;	result += "\r";
		        result += "\t</T>\r";


		        result += "\t<A>\r";
		        result += "\t<A1> "; result += 중의어_1_영어풀이;  result += " </A1>\r";
		        result += "\t<A2> "; result += 중의어_2_영어풀이;  result += " </A2>\r";
		        result += "\t<A3> "; result += 중의어_3_영어풀이;  result += " </A3>\r";
		        result += "\t<A4> "; result += 중의어_4_영어풀이;  result += " </A4>\r";
		        result += "\t<A5> "; result += 중의어_5_영어풀이;  result += " </A5>\r";
		        result += "\t</A>\r";
		        result += "\t<정답>\r";
		        result += "\t"; result += 올바른_정답; result += "\r";
				result += "\t</정답>\r";
				result += "\t<해석>\r";
				result += "\t" + 해석 + "\r";
				result += "\t</해석>\r";

				if (중의어_1_해설 != "" || 중의어_2_해설 != "" || 중의어_3_해설 != "" || 중의어_4_해설 != "" || 중의어_5_해설 != "")
				{
					result += "\t<해설>\r";
					result += "\t" + 중의어_1_해설 + " " + 중의어_2_해설 + " " + 중의어_3_해설 + " " + 중의어_4_해설 + " " + 중의어_5_해설 + "\r";
					result += "\t</해설>\r";
				}


				result += "</CAKE>\r";

                _현재번호++;
            }
	        return result;
        }
        private static string 중의어_단어에만_격자가_있는_본문구하기(int 문장번호, int 단어번호, string 본문)
        {
	        string 중의어_단어에만_격자가_있는_본문 = "";

            List<string> 본문_문장들 = new List<string>();

            강력하지만무거운변환.문자열.문장단위의_문자열들로(본문, ref 본문_문장들);

	        for(int i = 0 ; i < 본문_문장들.Count() ; i++)
	        {
		        if(i != 문장번호)
		        {
			        중의어_단어에만_격자가_있는_본문 += 본문_문장들[i];
			        중의어_단어에만_격자가_있는_본문 += " ";
		        }
		        else
		        {
                    List<string> 중의어_찾기용_단어들 = new List<string>();
	                List<string> 원래_단어들 = new List<string>();
    
                    변환.문자열.중의어찾기용단어들로(ref 중의어_찾기용_단어들, ref 원래_단어들, 본문_문장들[i]);

			        for(int j = 0 ; j < 원래_단어들.Count(); j++)
			        {
				        if(j != 단어번호)
				        {
					        중의어_단어에만_격자가_있는_본문 += 원래_단어들[j];
					        중의어_단어에만_격자가_있는_본문 += " ";
				        }
				        else
				        {
					        중의어_단어에만_격자가_있는_본문 += "[";
					        중의어_단어에만_격자가_있는_본문 += 원래_단어들[j];
					        중의어_단어에만_격자가_있는_본문 += "]";
					        중의어_단어에만_격자가_있는_본문 += " ";
				        }
			        }
		        }
	        }

	        return 중의어_단어에만_격자가_있는_본문;
        }

    // letter|편지|a written or printed communication addressed to a person or organization and usually transmitted by mail.
    // letter|글자,문자|a symbol or character that is conventionally used in writing and printing to represent a speech sound and that is part of an alphabet.
    // letter||actual terms or wording; literal meaning, as distinct from implied meaning or intent ( opposed to spirit): the letter of the law.
    // letter||a. literature in general. b. the profession of literature. c. learning; knowledge, esp. of literature.
    // letter||an emblem consisting of the initial or monogram of a school, awarded to a student for extracurricular activity, esp. in athletics.
    //
    //	_중의어_영단어 : letter
    //	_중의어_1_한글뜻			: 편지
    //	_중의어_1_영어풀이		: a written or printed communication addressed to a person or organization and usually transmitted by mail.
    //	_중의어_2_한글뜻			: 글자,문자
    //	_중의어_2_영어풀이		: a symbol or character that is conventionally used in writing and printing to represent a speech sound and that is part of an alphabet.
    //	_중의어_3_한글뜻			: 
    //	_중의어_3_영어풀이		: actual terms or wording; literal meaning, as distinct from implied meaning or intent ( opposed to spirit): the letter of the law.
    //	_중의어_4_한글뜻			: 
    //	_중의어_4_영어풀이		: a. literature in general. b. the profession of literature. c. learning; knowledge, esp. of literature.
    //	_중의어_5_한글뜻			: 
    //	_중의어_5_영어풀이		: an emblem consisting of the initial or monogram of a school, awarded to a student for extracurricular activity, esp. in athletics.

      private static bool 중의어_데이터로딩()
      {
	        _중의어_영단어.Clear();
	        _중의어_1_한글뜻.Clear();
	        _중의어_1_영어풀이.Clear();
	        _중의어_1_해설.Clear();

            _중의어_2_한글뜻.Clear();
	        _중의어_2_영어풀이.Clear();
	        _중의어_2_해설.Clear();

	        _중의어_3_한글뜻.Clear();
	        _중의어_3_영어풀이.Clear();
	        _중의어_3_해설.Clear();

	        _중의어_4_한글뜻.Clear();
	        _중의어_4_영어풀이.Clear();
	        _중의어_4_해설.Clear();

	        _중의어_5_한글뜻.Clear();
	        _중의어_5_영어풀이.Clear();
	        _중의어_5_해설.Clear();
	

	        

            List<string> 중의어데이터들 = new List<string>();

            변환.Ansi파일.문자열들로(_문제DB루트폴더 + "중의어.문제", ref 중의어데이터들);

	        for(int i = 0 ; i < 중의어데이터들.Count; i+= 5)
	        {
		        _중의어_영단어.Add(첫번째부분(중의어데이터들[i]));

		        _중의어_1_한글뜻.Add(두번째부분(중의어데이터들[i]));
		        _중의어_2_한글뜻.Add(두번째부분(중의어데이터들[i+1]));
		        _중의어_3_한글뜻.Add(두번째부분(중의어데이터들[i+2]));
		        _중의어_4_한글뜻.Add(두번째부분(중의어데이터들[i+3]));
		        _중의어_5_한글뜻.Add(두번째부분(중의어데이터들[i+4]));


		        _중의어_1_영어풀이.Add(세번째부분(중의어데이터들[i]));
		        _중의어_2_영어풀이.Add(세번째부분(중의어데이터들[i+1]));
		        _중의어_3_영어풀이.Add(세번째부분(중의어데이터들[i+2]));
		        _중의어_4_영어풀이.Add(세번째부분(중의어데이터들[i+3]));
		        _중의어_5_영어풀이.Add(세번째부분(중의어데이터들[i+4]));

		        _중의어_1_해설.Add(네번째부분(중의어데이터들[i]));
		        _중의어_2_해설.Add(네번째부분(중의어데이터들[i+1]));
		        _중의어_3_해설.Add(네번째부분(중의어데이터들[i+2]));
		        _중의어_4_해설.Add(네번째부분(중의어데이터들[i+3]));
		        _중의어_5_해설.Add(네번째부분(중의어데이터들[i+4]));

	        }
	        return true;
        }
        private static string 첫번째부분(string 문자열)
        {
            string [] 나뉜것 = 문자열.Split('|');

            if(나뉜것.Count() > 0) return 나뉜것[0];
            else return "";
        }

        private static string 두번째부분(string 문자열)
        {
            string [] 나뉜것 = 문자열.Split('|');

            if(나뉜것.Count() > 1) return 나뉜것[1];
            else return "";
        }

        private static string 세번째부분(string 문자열)
        {
            string [] 나뉜것 = 문자열.Split('|');

            if(나뉜것.Count() > 2) return 나뉜것[2];
            else return "";
        }

        private static string 네번째부분(string 문자열)
        {
            string [] 나뉜것 = 문자열.Split('|');

            if(나뉜것.Count() > 3) return 나뉜것[3];
            else return "";
        }

    }

    class 정오답보기 : IComparable<정오답보기>
    {
        public int 가중치 { get; set; }
        public string 정오답보기스트링 { get; set; }

        public int CompareTo(정오답보기 other)
        {
            return other.가중치.CompareTo(this.가중치);
        }

        public override string ToString()
        {
            return this.정오답보기스트링;
        }
    }
}
